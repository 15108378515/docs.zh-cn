---
title: 具有值类型的引用语义
description: 了解安全地最大程度减少结构复制操作的语言功能
ms.date: 11/10/2017
ms.custom: mvc
ms.openlocfilehash: f241219994d7a03192a4aea69b912bf1ac5ed29c
ms.sourcegitcommit: c7f3e2e9d6ead6cc3acd0d66b10a251d0c66e59d
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/08/2018
ms.locfileid: "44209519"
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="3838c-103">具有值类型的引用语义</span><span class="sxs-lookup"><span data-stu-id="3838c-103">Reference semantics with value types</span></span>

<span data-ttu-id="3838c-104">使用值类型的优点之一是通常可避免堆分配。</span><span class="sxs-lookup"><span data-stu-id="3838c-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="3838c-105">缺点是它们按值进行复制。</span><span class="sxs-lookup"><span data-stu-id="3838c-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="3838c-106">由于存在这种折衷，因此难以优化针对大量数据执行的算法。</span><span class="sxs-lookup"><span data-stu-id="3838c-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="3838c-107">C# 7.2 中新增的语言功能可提供支持按具有值类型的引用语义传递的机制。</span><span class="sxs-lookup"><span data-stu-id="3838c-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="3838c-108">请恰当地使用这些功能，以最大程度地减少分配和复制操作。</span><span class="sxs-lookup"><span data-stu-id="3838c-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="3838c-109">本文将介绍这些新功能。</span><span class="sxs-lookup"><span data-stu-id="3838c-109">This article explores those new features.</span></span>

<span data-ttu-id="3838c-110">文本中的很多示例代码演示了 C# 7.2 中增加的功能。</span><span class="sxs-lookup"><span data-stu-id="3838c-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="3838c-111">若要使用这些功能，必须将项目配置为使用 C# 7.2 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="3838c-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="3838c-112">有关设置语言版本的详细信息，请参阅[配置语言版本](language-reference/configure-language-version.md)。</span><span class="sxs-lookup"><span data-stu-id="3838c-112">For more information on setting the language version see [configure the language version](language-reference/configure-language-version.md).</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="3838c-113">按只读引用传递参数</span><span class="sxs-lookup"><span data-stu-id="3838c-113">Passing arguments by readonly reference</span></span>

<span data-ttu-id="3838c-114">C# 7.2 新增 `in` 关键字来补充现有的 `ref` 和 `out` 关键字以按引用传递参数。</span><span class="sxs-lookup"><span data-stu-id="3838c-114">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="3838c-115">`in` 关键字指定按引用传递参数，但调用的方法不修改值。</span><span class="sxs-lookup"><span data-stu-id="3838c-115">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="3838c-116">这一新增功能可提供完整的词汇，以表达你的设计意图。</span><span class="sxs-lookup"><span data-stu-id="3838c-116">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="3838c-117">如果未在方法签名中指定以下任一修饰符，值类型会在传递给调用的方法时进行复制。</span><span class="sxs-lookup"><span data-stu-id="3838c-117">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="3838c-118">每个修饰符指定值类型按引用传递，避免复制。</span><span class="sxs-lookup"><span data-stu-id="3838c-118">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="3838c-119">每个修饰符表达一种不同的意图：</span><span class="sxs-lookup"><span data-stu-id="3838c-119">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="3838c-120">`out`：此方法设置用作此形参的实参的值。</span><span class="sxs-lookup"><span data-stu-id="3838c-120">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="3838c-121">`ref`：此方法可设置用作此形参的实参的值。</span><span class="sxs-lookup"><span data-stu-id="3838c-121">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="3838c-122">`in`：此方法不会修改用作此形参的实参的值。</span><span class="sxs-lookup"><span data-stu-id="3838c-122">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="3838c-123">添加 `in` 修饰符，按引用传递参数，并声明设计意图是为了按引用传递参数，避免不必要的复制操作。</span><span class="sxs-lookup"><span data-stu-id="3838c-123">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="3838c-124">你不打算修改用作该参数的对象。</span><span class="sxs-lookup"><span data-stu-id="3838c-124">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="3838c-125">下面的代码演示了一个方法示例，该方法用于计算三维空间中两点间的距离。</span><span class="sxs-lookup"><span data-stu-id="3838c-125">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="3838c-126">该参数具有两个结构，每个结构包含三个双精度值。</span><span class="sxs-lookup"><span data-stu-id="3838c-126">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="3838c-127">一个双精度值有 8 个字节，所以每个参数有 24 个字节。</span><span class="sxs-lookup"><span data-stu-id="3838c-127">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="3838c-128">通过指定 `in` 修饰符，可向这些参数传递 4 字节或 8 字节引用，具体取决于计算机的体系结构。</span><span class="sxs-lookup"><span data-stu-id="3838c-128">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="3838c-129">大小的差异很小，但是当应用程序使用许多不同的值在一个紧凑的循环中调用此方法时，这些差异可迅速累积。</span><span class="sxs-lookup"><span data-stu-id="3838c-129">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="3838c-130">`in` 修饰符还可以通过其他方式补充 `out` 和 `ref`。</span><span class="sxs-lookup"><span data-stu-id="3838c-130">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="3838c-131">无法创建差异仅为是否具有 `in`、`out` 或 `ref` 的方法的重载。</span><span class="sxs-lookup"><span data-stu-id="3838c-131">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="3838c-132">这些新规则可扩展始终为 `out` 和 `ref` 参数定义的相同行为。</span><span class="sxs-lookup"><span data-stu-id="3838c-132">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="3838c-133">`in` 修饰符可能适用于采用以下参数的任何成员：methods、delegates、lambdas、local functions、indexers 和 operators。</span><span class="sxs-lookup"><span data-stu-id="3838c-133">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="3838c-134">与 `ref` 和 `out` 实参不同，可对 `in` 形参的实参使用文本值或常数。</span><span class="sxs-lookup"><span data-stu-id="3838c-134">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="3838c-135">此外，与 `ref` 或 `out` 参数不同，无需在调用站点应用 `in` 修饰符。</span><span class="sxs-lookup"><span data-stu-id="3838c-135">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="3838c-136">下面的代码演示调用 `CalculateDistance` 方法的两个示例。</span><span class="sxs-lookup"><span data-stu-id="3838c-136">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="3838c-137">第一个示例使用按引用传递的两个本地变量。</span><span class="sxs-lookup"><span data-stu-id="3838c-137">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="3838c-138">第二个示例包含方法调用过程中创建的临时变量。</span><span class="sxs-lookup"><span data-stu-id="3838c-138">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="3838c-139">有多种方法可让编译器确保强制执行 `in` 参数的只读性质。</span><span class="sxs-lookup"><span data-stu-id="3838c-139">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="3838c-140">首先，调用的方法不能直接分配给 `in` 参数。</span><span class="sxs-lookup"><span data-stu-id="3838c-140">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="3838c-141">当值类型为 `struct` 时，不能直接分配给 `in` 参数的任何字段。</span><span class="sxs-lookup"><span data-stu-id="3838c-141">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="3838c-142">此外，不能向使用 `ref` 或 `out` 修饰符的任何方法传递 `in` 参数。</span><span class="sxs-lookup"><span data-stu-id="3838c-142">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="3838c-143">如果字段为 `struct` 类型且该参数也为 `struct` 类型，则这些规则适用于 `in` 参数的任何字段。</span><span class="sxs-lookup"><span data-stu-id="3838c-143">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="3838c-144">事实上，如果所有级别的成员访问类型都是 `structs`，则这些规则适用于多层成员访问。</span><span class="sxs-lookup"><span data-stu-id="3838c-144">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="3838c-145">编译器强制将 `struct` 类型作为 `in` 参数传递，它们的 `struct` 成员用作其他方法的参数时，为只读变量。</span><span class="sxs-lookup"><span data-stu-id="3838c-145">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="3838c-146">使用 `in` 参数可避免产生复制操作可能产生的性能成本。</span><span class="sxs-lookup"><span data-stu-id="3838c-146">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="3838c-147">这不会改变任何方法调用的语义。</span><span class="sxs-lookup"><span data-stu-id="3838c-147">It does not change the semantics of any method call.</span></span> <span data-ttu-id="3838c-148">所以不需要在调用站点指定 `in` 修饰符。</span><span class="sxs-lookup"><span data-stu-id="3838c-148">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="3838c-149">但在调用站点省略 `in` 修饰符就会通知编译器你允许它出于以下原因复制参数：</span><span class="sxs-lookup"><span data-stu-id="3838c-149">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="3838c-150">存在从实参类型到形参类型的隐式转换，但不是标识转换。</span><span class="sxs-lookup"><span data-stu-id="3838c-150">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="3838c-151">该参数是一个表达式，但是没有已知的存储变量。</span><span class="sxs-lookup"><span data-stu-id="3838c-151">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="3838c-152">存在的重载因 `in` 是否存在而有所不同。</span><span class="sxs-lookup"><span data-stu-id="3838c-152">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="3838c-153">在这种情况下，按值重载的匹配度会更高。</span><span class="sxs-lookup"><span data-stu-id="3838c-153">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="3838c-154">在更新现有代码以使用只读引用参数时，这些规则会很有用。</span><span class="sxs-lookup"><span data-stu-id="3838c-154">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="3838c-155">在调用的方法中，可以调用任何使用按值参数的实例方法。</span><span class="sxs-lookup"><span data-stu-id="3838c-155">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="3838c-156">在这些方法中，将创建 `in` 参数的副本。</span><span class="sxs-lookup"><span data-stu-id="3838c-156">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="3838c-157">由于编译器可为任何 `in` 参数创建临时变量，因此还可指定任何 `in` 参数的默认值。</span><span class="sxs-lookup"><span data-stu-id="3838c-157">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="3838c-158">以下代码指定原点（点 0,0）为第二个点的默认值：</span><span class="sxs-lookup"><span data-stu-id="3838c-158">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="3838c-159">要强制编译器按引用传递只读参数，请在调用站点的参数上指定 `in` 修饰符，如下列代码所示：</span><span class="sxs-lookup"><span data-stu-id="3838c-159">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="3838c-160">这样可以更轻松地在大型代码库中采用一段时间的 `in` 参数，从而实现性能提升。</span><span class="sxs-lookup"><span data-stu-id="3838c-160">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="3838c-161">首先，将 `in` 修饰符添加到方法签名。</span><span class="sxs-lookup"><span data-stu-id="3838c-161">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="3838c-162">然后，可以在调用站点添加 `in` 修饰符，并创建 `readonly struct` 类型，让编译器避免在更多位置创建 `in` 参数的防御性副本。</span><span class="sxs-lookup"><span data-stu-id="3838c-162">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="3838c-163">`in` 参数指定还可用于引用类型或数值。</span><span class="sxs-lookup"><span data-stu-id="3838c-163">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="3838c-164">但是，这两种情况下获得的好处都是最少的（如果有）。</span><span class="sxs-lookup"><span data-stu-id="3838c-164">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="3838c-165">`ref readonly` 返回</span><span class="sxs-lookup"><span data-stu-id="3838c-165">`ref readonly` returns</span></span>

<span data-ttu-id="3838c-166">可能还需要按引用返回值类型，但不允许调用方修改该值。</span><span class="sxs-lookup"><span data-stu-id="3838c-166">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="3838c-167">使用 `ref readonly` 修饰符来表达该设计意图。</span><span class="sxs-lookup"><span data-stu-id="3838c-167">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="3838c-168">它将通知读者，即将返回对现有数据的引用，但不允许修改。</span><span class="sxs-lookup"><span data-stu-id="3838c-168">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="3838c-169">编译器可强制调用方不能修改引用。</span><span class="sxs-lookup"><span data-stu-id="3838c-169">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="3838c-170">直接分配给该值的尝试会生成编译时错误。</span><span class="sxs-lookup"><span data-stu-id="3838c-170">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="3838c-171">但是，编译器无法得知某一成员方法是否修改该结构的状态。</span><span class="sxs-lookup"><span data-stu-id="3838c-171">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="3838c-172">若要确保未修改该对象，编译器将创建副本并使用该副本调用成员引用。</span><span class="sxs-lookup"><span data-stu-id="3838c-172">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="3838c-173">任何修改均针对该防御性副本。</span><span class="sxs-lookup"><span data-stu-id="3838c-173">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="3838c-174">使用 `Point3D` 的库通常很可能在代码中使用原点。</span><span class="sxs-lookup"><span data-stu-id="3838c-174">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="3838c-175">每个实例将在堆栈上创建一个新对象。</span><span class="sxs-lookup"><span data-stu-id="3838c-175">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="3838c-176">最好创建一个常数并按引用返回它。</span><span class="sxs-lookup"><span data-stu-id="3838c-176">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="3838c-177">但是，如果返回对内部存储的引用，可能需要强制该调用方不能修改引用的存储。</span><span class="sxs-lookup"><span data-stu-id="3838c-177">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="3838c-178">以下代码定义只读属性，该属性向指定原点的 `Point3D` 返回 `readonly ref`。</span><span class="sxs-lookup"><span data-stu-id="3838c-178">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="3838c-179">创建 ref readonly return 的副本很容易：只需将其分配给未使用 `ref readonly` 修饰符声明的变量即可。</span><span class="sxs-lookup"><span data-stu-id="3838c-179">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="3838c-180">编译器将生成代码，用于在分配过程中复制对象。</span><span class="sxs-lookup"><span data-stu-id="3838c-180">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="3838c-181">当向 `ref readonly return` 分配变量时，可指定 `ref readonly` 变量或只读引用的按值副本：</span><span class="sxs-lookup"><span data-stu-id="3838c-181">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="3838c-182">前面的代码中的第一个分配将创建 `Origin` 常数的副本，并分配该副本。</span><span class="sxs-lookup"><span data-stu-id="3838c-182">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="3838c-183">第二个将分配引用。</span><span class="sxs-lookup"><span data-stu-id="3838c-183">The second assigns a reference.</span></span> <span data-ttu-id="3838c-184">注意，`readonly` 修饰符必须包含在变量声明中。</span><span class="sxs-lookup"><span data-stu-id="3838c-184">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="3838c-185">无法修改该修饰符引用对象的引用。</span><span class="sxs-lookup"><span data-stu-id="3838c-185">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="3838c-186">尝试执行该操作将导致编译时错误。</span><span class="sxs-lookup"><span data-stu-id="3838c-186">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="3838c-187">`readonly struct` 类型</span><span class="sxs-lookup"><span data-stu-id="3838c-187">`readonly struct` type</span></span>

<span data-ttu-id="3838c-188">向结构的高流量使用应用 `ref readonly` 可能已足够。</span><span class="sxs-lookup"><span data-stu-id="3838c-188">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="3838c-189">其他情况下，可能需要创建不可变的结构。</span><span class="sxs-lookup"><span data-stu-id="3838c-189">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="3838c-190">然后便可以按只读引用传递。</span><span class="sxs-lookup"><span data-stu-id="3838c-190">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="3838c-191">该做法将删除防御性副本，该副本创建于访问用作 `in` 参数的结构的方法时。</span><span class="sxs-lookup"><span data-stu-id="3838c-191">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="3838c-192">可通过创建 `readonly struct` 类型执行该操作。</span><span class="sxs-lookup"><span data-stu-id="3838c-192">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="3838c-193">可向结构声明添加 `readonly` 修饰符。</span><span class="sxs-lookup"><span data-stu-id="3838c-193">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="3838c-194">编译器可强制结构的所有实例成员为 `readonly`；`struct` 必须是不可变的。</span><span class="sxs-lookup"><span data-stu-id="3838c-194">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="3838c-195">存在针对 `readonly struct` 的其他优化。</span><span class="sxs-lookup"><span data-stu-id="3838c-195">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="3838c-196">可在 `readonly struct` 为参数的每个位置使用 `in` 修饰符。</span><span class="sxs-lookup"><span data-stu-id="3838c-196">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="3838c-197">此外，如果要返回其生存期超出返回对象的方法的作用域的对象，可返回 `readonly struct` 作为 `ref return`。</span><span class="sxs-lookup"><span data-stu-id="3838c-197">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="3838c-198">最后，调用 `readonly struct` 的成员时，编译器将生成更高效的代码：`this` 引用，而不是接收方的副本，是始终通过对成员方法的引用进行传递的 `in` 参数。</span><span class="sxs-lookup"><span data-stu-id="3838c-198">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="3838c-199">这种优化在你使用 `readonly struct` 时可减少更多复制操作。</span><span class="sxs-lookup"><span data-stu-id="3838c-199">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="3838c-200">`Point3D` 是这项更改的理想候选项。</span><span class="sxs-lookup"><span data-stu-id="3838c-200">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="3838c-201">下面的代码显示更新后的 `ReadonlyPoint3D` 结构：</span><span class="sxs-lookup"><span data-stu-id="3838c-201">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="3838c-202">`ref struct` 类型</span><span class="sxs-lookup"><span data-stu-id="3838c-202">`ref struct` type</span></span>

<span data-ttu-id="3838c-203">另一相关语言功能是声明值类型必须为堆栈分配。</span><span class="sxs-lookup"><span data-stu-id="3838c-203">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="3838c-204">换言之，永远不能在作为另一类的成员的堆上创建这些类型。</span><span class="sxs-lookup"><span data-stu-id="3838c-204">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="3838c-205">此功能的主要动机是 <xref:System.Span%601> 和相关结构。</span><span class="sxs-lookup"><span data-stu-id="3838c-205">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="3838c-206"><xref:System.Span%601> 可能包含托管的指针，作为成员之一，而另一个作为范围的长度。</span><span class="sxs-lookup"><span data-stu-id="3838c-206"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="3838c-207">它的实现方式稍微有些不同，因为 C# 不支持指向不安全上下文之外的托管内存的指针。</span><span class="sxs-lookup"><span data-stu-id="3838c-207">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="3838c-208">更改指针和长度的任何写入都不是原子的。</span><span class="sxs-lookup"><span data-stu-id="3838c-208">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="3838c-209">这意味着如果 <xref:System.Span%601> 不限于单个堆栈帧，它将发生超出范围错误或其他类型安全冲突。</span><span class="sxs-lookup"><span data-stu-id="3838c-209">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="3838c-210">此外，将托管指针置于 GC 堆上通常会在 JIT 时出现故障。</span><span class="sxs-lookup"><span data-stu-id="3838c-210">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="3838c-211">在使用通过 [`stackalloc`](language-reference/keywords/stackalloc.md) 创建的内存或使用互操作 API 中的内存时，可能具有类似要求。</span><span class="sxs-lookup"><span data-stu-id="3838c-211">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="3838c-212">可针对这些需求定义自己的 `ref struct` 类型。</span><span class="sxs-lookup"><span data-stu-id="3838c-212">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="3838c-213">在本文中，请参阅使用 `Span<T>` 的简化示例。</span><span class="sxs-lookup"><span data-stu-id="3838c-213">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="3838c-214">`ref struct` 声明会声明此类型的结构必须位于堆栈上。</span><span class="sxs-lookup"><span data-stu-id="3838c-214">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="3838c-215">语言规则可确保安全使用这些类型。</span><span class="sxs-lookup"><span data-stu-id="3838c-215">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="3838c-216">声明为 `ref struct` 的其他类型包括 <xref:System.ReadOnlySpan%601>。</span><span class="sxs-lookup"><span data-stu-id="3838c-216">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="3838c-217">保持 `ref struct` 类型作为堆栈分配的变量的目标引入了几条编译器针对所有 `ref struct` 类型强制执行的规则。</span><span class="sxs-lookup"><span data-stu-id="3838c-217">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="3838c-218">不能对 `ref struct` 装箱。</span><span class="sxs-lookup"><span data-stu-id="3838c-218">You can't box a `ref struct`.</span></span> <span data-ttu-id="3838c-219">无法向属于 `object`、`dynamic` 或任何接口类型的变量分配 `ref struct` 类型。</span><span class="sxs-lookup"><span data-stu-id="3838c-219">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="3838c-220">不能将 `ref struct` 声明为类或常规结构的成员。</span><span class="sxs-lookup"><span data-stu-id="3838c-220">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="3838c-221">不能声明异步方法中属于 `ref struct` 类型的本地变量。</span><span class="sxs-lookup"><span data-stu-id="3838c-221">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="3838c-222">不能在返回 `Task`、`Task<T>` 或类似 Task 类型的同步方法中声明它们。</span><span class="sxs-lookup"><span data-stu-id="3838c-222">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="3838c-223">无法在迭代器中声明 `ref struct` 本地变量。</span><span class="sxs-lookup"><span data-stu-id="3838c-223">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="3838c-224">无法捕获 Lambda 表达式或本地函数中的 `ref struct` 变量。</span><span class="sxs-lookup"><span data-stu-id="3838c-224">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="3838c-225">这些限制可确保不会以可提升至托管堆的方式意外地使用 `ref struct`。</span><span class="sxs-lookup"><span data-stu-id="3838c-225">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="3838c-226">`readonly ref struct` 类型</span><span class="sxs-lookup"><span data-stu-id="3838c-226">`readonly ref struct` type</span></span>

<span data-ttu-id="3838c-227">将结构声明为 `readonly ref` 兼具 `ref struct` 和 `readonly struct` 声明的优点和限制。</span><span class="sxs-lookup"><span data-stu-id="3838c-227">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> 

<span data-ttu-id="3838c-228">以下示例演示 `readonly ref struct` 的声明。</span><span class="sxs-lookup"><span data-stu-id="3838c-228">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="3838c-229">结论</span><span class="sxs-lookup"><span data-stu-id="3838c-229">Conclusions</span></span>

<span data-ttu-id="3838c-230">C# 语言的这些增强功能专为性能关键型算法设计，在这些算法中，内存分配可能对实现必需的性能至关重要。</span><span class="sxs-lookup"><span data-stu-id="3838c-230">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="3838c-231">你可能会发现，编写代码时不经常使用这些功能。</span><span class="sxs-lookup"><span data-stu-id="3838c-231">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="3838c-232">但是，.NET Framework 中的许多位置已采用这些增强功能。</span><span class="sxs-lookup"><span data-stu-id="3838c-232">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="3838c-233">随着越来越多的 API 使用这些功能，你会发现应用程序的性能得到提升。</span><span class="sxs-lookup"><span data-stu-id="3838c-233">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
