---
title: 具有值类型的引用语义
description: 了解安全地最大程度减少结构复制操作的语言功能
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 8a0cfe83200d50eefa9b01ab51591a5fe0703ec0
ms.sourcegitcommit: c883637b41ee028786edceece4fa872939d2e64c
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/23/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="82ccb-103">具有值类型的引用语义</span><span class="sxs-lookup"><span data-stu-id="82ccb-103">Reference semantics with value types</span></span>

<span data-ttu-id="82ccb-104">使用值类型的优点之一是通常可避免堆分配。</span><span class="sxs-lookup"><span data-stu-id="82ccb-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="82ccb-105">而相应的缺点是它们按值进行复制。</span><span class="sxs-lookup"><span data-stu-id="82ccb-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="82ccb-106">由于存在这种折衷，因此难以优化针对大量数据执行的算法。</span><span class="sxs-lookup"><span data-stu-id="82ccb-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="82ccb-107">C# 7.2 中新增的语言功能可提供支持按具有值类型的引用语义传递的机制。</span><span class="sxs-lookup"><span data-stu-id="82ccb-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="82ccb-108">如果恰当地使用这些功能，可以最大程度地减少分配和复制操作。</span><span class="sxs-lookup"><span data-stu-id="82ccb-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="82ccb-109">本文将介绍这些新功能。</span><span class="sxs-lookup"><span data-stu-id="82ccb-109">This article explores those new features.</span></span>

<span data-ttu-id="82ccb-110">文本中的很多示例代码演示了 C# 7.2 中增加的功能。</span><span class="sxs-lookup"><span data-stu-id="82ccb-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="82ccb-111">若要使用这些功能，必须配置项目，以在项目中使用 C# 7.2 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="82ccb-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="82ccb-112">可以使用 Visual Studio 进行选择。</span><span class="sxs-lookup"><span data-stu-id="82ccb-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="82ccb-113">对于每个项目，从菜单中选择“项目”，然后选择“属性”。</span><span class="sxs-lookup"><span data-stu-id="82ccb-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="82ccb-114">选择“生成”选项卡，然后单击“高级”。</span><span class="sxs-lookup"><span data-stu-id="82ccb-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="82ccb-115">可在此处配置语言版本。</span><span class="sxs-lookup"><span data-stu-id="82ccb-115">From there, you can configure the language version.</span></span> <span data-ttu-id="82ccb-116">选择“7.2”或“最新”。</span><span class="sxs-lookup"><span data-stu-id="82ccb-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="82ccb-117">或者，可以编辑 csproj 文件，并添加以下节点：</span><span class="sxs-lookup"><span data-stu-id="82ccb-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="82ccb-118">可以将“7.2”或“最新”用作值。</span><span class="sxs-lookup"><span data-stu-id="82ccb-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="82ccb-119">指定 `in` 参数</span><span class="sxs-lookup"><span data-stu-id="82ccb-119">Specifying `in` parameters</span></span>

<span data-ttu-id="82ccb-120">编写按引用传递参数的方法时，C# 7.2 新增 `in` 关键字来补充现有的 `ref` 和 `out` 关键字。</span><span class="sxs-lookup"><span data-stu-id="82ccb-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="82ccb-121">`in` 关键字指定要按引用传递参数，并且调用的方法不会修改传递给它的值。</span><span class="sxs-lookup"><span data-stu-id="82ccb-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="82ccb-122">这一新增功能可提供完整的词汇，以表达你的设计意图。</span><span class="sxs-lookup"><span data-stu-id="82ccb-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="82ccb-123">如果未指定以下任一修饰符，值类型会在传递给调用的方法时进行复制。</span><span class="sxs-lookup"><span data-stu-id="82ccb-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="82ccb-124">每个修饰符指定值类型按引用传递，避免复制。</span><span class="sxs-lookup"><span data-stu-id="82ccb-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="82ccb-125">每个修饰符表达一种不同的意图：</span><span class="sxs-lookup"><span data-stu-id="82ccb-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="82ccb-126">`out`：此方法设置用作此形参的实参的值。</span><span class="sxs-lookup"><span data-stu-id="82ccb-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="82ccb-127">`ref`：此方法可设置用作此形参的实参的值。</span><span class="sxs-lookup"><span data-stu-id="82ccb-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="82ccb-128">`in`：此方法不会修改用作此形参的实参的值。</span><span class="sxs-lookup"><span data-stu-id="82ccb-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="82ccb-129">添加 `in` 修饰符，按引用传递参数时，声明设计意图是为了按引用传递参数，避免不必要的复制操作。</span><span class="sxs-lookup"><span data-stu-id="82ccb-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="82ccb-130">你不打算修改用作该参数的对象。</span><span class="sxs-lookup"><span data-stu-id="82ccb-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="82ccb-131">下面的代码演示了一个方法示例，该方法用于计算三维空间中两点间的距离。</span><span class="sxs-lookup"><span data-stu-id="82ccb-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="82ccb-132">该参数具有两个结构，每个结构包含三个双精度值。</span><span class="sxs-lookup"><span data-stu-id="82ccb-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="82ccb-133">一个双精度值有 8 个字节，所以每个参数有 24 个字节。</span><span class="sxs-lookup"><span data-stu-id="82ccb-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="82ccb-134">通过指定 `in` 修饰符，可向这些参数传递 4 字节或 8 字节引用，具体取决于计算机的体系结构。</span><span class="sxs-lookup"><span data-stu-id="82ccb-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="82ccb-135">大小的差异很小，但是当应用程序使用许多不同的值在一个紧凑的循环中调用此方法时，这些差异可迅速累积。</span><span class="sxs-lookup"><span data-stu-id="82ccb-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="82ccb-136">`in` 修饰符还可以通过其他方式补充 `out` 和 `ref`。</span><span class="sxs-lookup"><span data-stu-id="82ccb-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="82ccb-137">无法创建差异仅为是否具有 `in`、`out` 或 `ref` 的方法的重载。</span><span class="sxs-lookup"><span data-stu-id="82ccb-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="82ccb-138">这些新规则可扩展始终为 `out` 和 `ref` 参数定义的相同行为。</span><span class="sxs-lookup"><span data-stu-id="82ccb-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="82ccb-139">`in` 修饰符可能适用于采用以下参数的任何成员：methods、delegates、lambdas、local functions、indexers 和 operators。</span><span class="sxs-lookup"><span data-stu-id="82ccb-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="82ccb-140">与 `ref` 和 `out` 实参不同，可对 `in` 形参的实参使用文本值或常数。</span><span class="sxs-lookup"><span data-stu-id="82ccb-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="82ccb-141">此外，与 `ref` 或 `out` 参数不同，无需在调用站点应用 `in` 修饰符。</span><span class="sxs-lookup"><span data-stu-id="82ccb-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="82ccb-142">下面的代码演示调用 `CalculateDistance` 方法的两个示例。</span><span class="sxs-lookup"><span data-stu-id="82ccb-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="82ccb-143">第一个示例使用按引用传递的两个本地变量。</span><span class="sxs-lookup"><span data-stu-id="82ccb-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="82ccb-144">第二个示例包含方法调用过程中创建的临时变量。</span><span class="sxs-lookup"><span data-stu-id="82ccb-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="82ccb-145">有多种方法可让编译器确保强制执行 `in` 参数的只读性质。</span><span class="sxs-lookup"><span data-stu-id="82ccb-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="82ccb-146">首先，调用的方法不能直接分配给 `in` 参数。</span><span class="sxs-lookup"><span data-stu-id="82ccb-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="82ccb-147">不能直接分配给 `in` 参数的任何字段。</span><span class="sxs-lookup"><span data-stu-id="82ccb-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="82ccb-148">此外，不能向需要 `ref` 或 `out` 修饰符的任何方法传递 `in` 参数。</span><span class="sxs-lookup"><span data-stu-id="82ccb-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="82ccb-149">编译器可强制 `in` 参数为只读变量。</span><span class="sxs-lookup"><span data-stu-id="82ccb-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="82ccb-150">可调用使用按值传递语义的任何实例方法。</span><span class="sxs-lookup"><span data-stu-id="82ccb-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="82ccb-151">在这些方法中，将创建 `in` 参数的副本。</span><span class="sxs-lookup"><span data-stu-id="82ccb-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="82ccb-152">由于编译器可为任何 `in` 参数创建临时变量，因此还可指定任何 `in` 参数的默认值。</span><span class="sxs-lookup"><span data-stu-id="82ccb-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="82ccb-153">下面的代码使用编译器指定原点（点 0,0），将其作为第二个点的默认值：</span><span class="sxs-lookup"><span data-stu-id="82ccb-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="82ccb-154">`in` 参数指定还可用于引用类型或内置数值。</span><span class="sxs-lookup"><span data-stu-id="82ccb-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="82ccb-155">但是，这两种情况下获得的好处都是最少的（如果有）。</span><span class="sxs-lookup"><span data-stu-id="82ccb-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="82ccb-156">`ref readonly` 返回</span><span class="sxs-lookup"><span data-stu-id="82ccb-156">`ref readonly` returns</span></span>

<span data-ttu-id="82ccb-157">可能还需要按引用返回值类型，但不允许调用方修改该值。</span><span class="sxs-lookup"><span data-stu-id="82ccb-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="82ccb-158">使用 `ref readonly` 修饰符来表达该设计意图。</span><span class="sxs-lookup"><span data-stu-id="82ccb-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="82ccb-159">它将通知读者，即将返回对现有数据的引用，但不允许修改。</span><span class="sxs-lookup"><span data-stu-id="82ccb-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="82ccb-160">编译器可强制调用方不能修改引用。</span><span class="sxs-lookup"><span data-stu-id="82ccb-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="82ccb-161">直接分配给该值的尝试生成编译时错误。</span><span class="sxs-lookup"><span data-stu-id="82ccb-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="82ccb-162">但是，编译器无法得知某一成员方法是否修改该结构的状态。</span><span class="sxs-lookup"><span data-stu-id="82ccb-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="82ccb-163">若要确保未修改该对象，编译器将创建副本并使用该副本调用成员引用。</span><span class="sxs-lookup"><span data-stu-id="82ccb-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="82ccb-164">任何修改均针对该防御性副本。</span><span class="sxs-lookup"><span data-stu-id="82ccb-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="82ccb-165">使用 `Point3D` 的库通常很可能在代码中使用原点。</span><span class="sxs-lookup"><span data-stu-id="82ccb-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="82ccb-166">每个实例将在堆栈上创建一个新对象。</span><span class="sxs-lookup"><span data-stu-id="82ccb-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="82ccb-167">最好创建一个常数并按引用返回它。</span><span class="sxs-lookup"><span data-stu-id="82ccb-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="82ccb-168">但是，如果返回对内部存储的引用，可能需要强制该调用方不能修改引用的存储。</span><span class="sxs-lookup"><span data-stu-id="82ccb-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="82ccb-169">以下代码定义只读属性，该属性向指定原点的 `Point3D` 返回 `readonly ref`。</span><span class="sxs-lookup"><span data-stu-id="82ccb-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="82ccb-170">创建 ref readonly return 的副本很容易：只需将其分配给未使用 `ref readonly` 修饰符声明的变量即可。</span><span class="sxs-lookup"><span data-stu-id="82ccb-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="82ccb-171">编译器将生成代码，用于在分配过程中复制对象。</span><span class="sxs-lookup"><span data-stu-id="82ccb-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="82ccb-172">当向 `ref readonly return` 分配变量时，可指定 `ref readonly` 变量或只读引用的按值副本：</span><span class="sxs-lookup"><span data-stu-id="82ccb-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="82ccb-173">前面的代码中的第一个分配将创建 `Origin` 常数的副本，并分配该副本。</span><span class="sxs-lookup"><span data-stu-id="82ccb-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="82ccb-174">第二个将分配引用。</span><span class="sxs-lookup"><span data-stu-id="82ccb-174">The second assigns a reference.</span></span> <span data-ttu-id="82ccb-175">注意，`readonly` 修饰符必须包含在变量声明中。</span><span class="sxs-lookup"><span data-stu-id="82ccb-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="82ccb-176">无法修改该修饰符引用对象的引用。</span><span class="sxs-lookup"><span data-stu-id="82ccb-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="82ccb-177">尝试执行该操作将导致编译时错误。</span><span class="sxs-lookup"><span data-stu-id="82ccb-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="82ccb-178">`readonly struct` 类型</span><span class="sxs-lookup"><span data-stu-id="82ccb-178">`readonly struct` type</span></span>

<span data-ttu-id="82ccb-179">向结构的高流量使用应用 `ref readonly` 可能已足够。</span><span class="sxs-lookup"><span data-stu-id="82ccb-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="82ccb-180">其他情况下，可能需要创建不可变的结构。</span><span class="sxs-lookup"><span data-stu-id="82ccb-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="82ccb-181">然后便可以按 readonly 引用传递。</span><span class="sxs-lookup"><span data-stu-id="82ccb-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="82ccb-182">该做法将删除防御性副本，该副本创建于访问用作 `in` 参数的结构的方法时。</span><span class="sxs-lookup"><span data-stu-id="82ccb-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="82ccb-183">可通过创建 `readonly struct` 类型执行该操作。</span><span class="sxs-lookup"><span data-stu-id="82ccb-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="82ccb-184">可向结构声明添加 `readonly` 修饰符。</span><span class="sxs-lookup"><span data-stu-id="82ccb-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="82ccb-185">编译器可强制结构的所有实例成员为 `readonly`；`struct` 必须是不可变的。</span><span class="sxs-lookup"><span data-stu-id="82ccb-185">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="82ccb-186">存在针对 `readonly struct` 的其他优化。</span><span class="sxs-lookup"><span data-stu-id="82ccb-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="82ccb-187">可在 `readonly struct` 为参数的每个位置使用 `in` 修饰符。</span><span class="sxs-lookup"><span data-stu-id="82ccb-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="82ccb-188">此外，如果要返回其生存期超出返回对象的方法的作用域的对象，可返回 `readonly struct` 作为 `ref return`。</span><span class="sxs-lookup"><span data-stu-id="82ccb-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="82ccb-189">最后，调用 `readonly struct` 的成员时，编译器将生成更高效的代码：`this` 引用，而不是接收方的副本，是始终通过对成员方法的引用进行传递的 `in` 参数。</span><span class="sxs-lookup"><span data-stu-id="82ccb-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="82ccb-190">这种优化在你使用 `readonly struct` 时可减少更多复制操作。</span><span class="sxs-lookup"><span data-stu-id="82ccb-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="82ccb-191">`Point3D` 是这项更改的理想候选项。</span><span class="sxs-lookup"><span data-stu-id="82ccb-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="82ccb-192">下面的代码显示更新后的 `ReadonlyPoint3D` 结构：</span><span class="sxs-lookup"><span data-stu-id="82ccb-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="82ccb-193">`ref struct` 类型</span><span class="sxs-lookup"><span data-stu-id="82ccb-193">`ref struct` type</span></span>

<span data-ttu-id="82ccb-194">另一相关语言功能是声明值类型必须为堆栈分配。</span><span class="sxs-lookup"><span data-stu-id="82ccb-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="82ccb-195">换言之，永远不能在作为另一类的成员的堆上创建这些类型。</span><span class="sxs-lookup"><span data-stu-id="82ccb-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="82ccb-196">此功能的主要动机是 <xref:System.Span%601> 和相关结构。</span><span class="sxs-lookup"><span data-stu-id="82ccb-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="82ccb-197"><xref:System.Span%601> 可能包含托管的指针，作为成员之一，而另一个作为范围的长度。</span><span class="sxs-lookup"><span data-stu-id="82ccb-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="82ccb-198">实际上，它的实现方式稍微有些不同，因为 C# 不支持指向不安全上下文之外的托管内存的指针。</span><span class="sxs-lookup"><span data-stu-id="82ccb-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="82ccb-199">更改指针和长度的任何写入都不是原子的。</span><span class="sxs-lookup"><span data-stu-id="82ccb-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="82ccb-200">这意味着如果 <xref:System.Span%601> 不限于单个堆栈帧，它将发生超出范围错误或其他类型安全冲突。</span><span class="sxs-lookup"><span data-stu-id="82ccb-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="82ccb-201">此外，将托管指针置于 GC 堆上通常会在 JIT 时出现故障。</span><span class="sxs-lookup"><span data-stu-id="82ccb-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="82ccb-202">在使用通过 [`stackalloc`](language-reference/keywords/stackalloc.md) 创建的内存或使用互操作 API 中的内存时，可能具有类似要求。</span><span class="sxs-lookup"><span data-stu-id="82ccb-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="82ccb-203">可针对这些需求定义自己的 `ref struct` 类型。</span><span class="sxs-lookup"><span data-stu-id="82ccb-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="82ccb-204">在本文中，请参阅使用 `Span<T>` 的简化示例。</span><span class="sxs-lookup"><span data-stu-id="82ccb-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="82ccb-205">`ref struct` 声明将声明此类型的结构必须位于堆栈上。</span><span class="sxs-lookup"><span data-stu-id="82ccb-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="82ccb-206">语言规则可确保安全使用这些类型。</span><span class="sxs-lookup"><span data-stu-id="82ccb-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="82ccb-207">声明为 `ref struct` 的其他类型包括 <xref:System.ReadOnlySpan%601>。</span><span class="sxs-lookup"><span data-stu-id="82ccb-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="82ccb-208">保持 `ref struct` 类型作为堆栈分配的变量的目标引入了几条编译器针对所有 `ref struct` 类型强制执行的规则。</span><span class="sxs-lookup"><span data-stu-id="82ccb-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="82ccb-209">不能对 `ref struct` 装箱。</span><span class="sxs-lookup"><span data-stu-id="82ccb-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="82ccb-210">无法向属于 `object`、`dynamic` 或任何接口类型的变量分配 `ref struct` 类型。</span><span class="sxs-lookup"><span data-stu-id="82ccb-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="82ccb-211">不能将 `ref struct` 声明为类或常规结构的成员。</span><span class="sxs-lookup"><span data-stu-id="82ccb-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="82ccb-212">不能声明异步方法中属于 `ref struct` 类型的本地变量。</span><span class="sxs-lookup"><span data-stu-id="82ccb-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="82ccb-213">不能在返回 `Task`、`Task<T>` 或类似 Task 类型的同步方法中声明它们。</span><span class="sxs-lookup"><span data-stu-id="82ccb-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="82ccb-214">无法在迭代器中声明 `ref struct` 本地变量。</span><span class="sxs-lookup"><span data-stu-id="82ccb-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="82ccb-215">无法捕获 Lambda 表达式或本地函数中的 `ref struct` 变量。</span><span class="sxs-lookup"><span data-stu-id="82ccb-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="82ccb-216">这些限制可确保不会以可提升至托管堆的方式意外地使用 `ref struct`。</span><span class="sxs-lookup"><span data-stu-id="82ccb-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="82ccb-217">`readonly ref struct` 类型</span><span class="sxs-lookup"><span data-stu-id="82ccb-217">`readonly ref struct` type</span></span>

<span data-ttu-id="82ccb-218">将结构声明为 `readonly ref` 兼具 `ref struct` 和 `readonly struct` 声明的优点和限制。</span><span class="sxs-lookup"><span data-stu-id="82ccb-218">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` delcarations.</span></span> 

<span data-ttu-id="82ccb-219">以下示例演示 `readonly ref struct` 的声明。</span><span class="sxs-lookup"><span data-stu-id="82ccb-219">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="82ccb-220">结论</span><span class="sxs-lookup"><span data-stu-id="82ccb-220">Conclusions</span></span>

<span data-ttu-id="82ccb-221">C# 语言的这些增强功能专为性能关键型算法设计，在这些算法中，内存分配可能对实现必需的性能至关重要。</span><span class="sxs-lookup"><span data-stu-id="82ccb-221">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="82ccb-222">你可能会发现，编写代码时不经常使用这些功能。</span><span class="sxs-lookup"><span data-stu-id="82ccb-222">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="82ccb-223">但是，.NET Framework 中的许多位置已采用这些增强功能。</span><span class="sxs-lookup"><span data-stu-id="82ccb-223">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="82ccb-224">随着越来越多的 API 使用这些功能，你会发现应用程序的性能得到提升。</span><span class="sxs-lookup"><span data-stu-id="82ccb-224">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
