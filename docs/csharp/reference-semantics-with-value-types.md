---
title: "具有值类型的引用语义"
description: "了解最大程度减少复制结构安全地的语言功能"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="4b7ce-103">具有值类型的引用语义</span><span class="sxs-lookup"><span data-stu-id="4b7ce-103">Reference semantics with value types</span></span>

<span data-ttu-id="4b7ce-104">为使用值类型的一个优点是它们通常避免堆分配。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="4b7ce-105">相应的缺点是通过值复制。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="4b7ce-106">权衡导致难优化对大量数据进行操作的算法。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="4b7ce-107">在 C# 7.2 的新语言功能提供支持与值类型的按引用传递语义的机制。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="4b7ce-108">如果你使用这些功能可以最大程度减少两个分配和复制操作。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="4b7ce-109">本文探讨这些新功能。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-109">This article explores those new features.</span></span>

<span data-ttu-id="4b7ce-110">很多这篇文章中的示例代码演示了在 C# 7.2 中添加的功能。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="4b7ce-111">若要使用这些功能，你必须配置您的项目以在你的项目中使用 C# 7.2 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="4b7ce-112">可以使用 Visual Studio 以将其选中。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="4b7ce-113">对于每个项目，选择**项目**的菜单，然后从**属性**。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="4b7ce-114">选择**生成**选项卡，单击**高级**。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="4b7ce-115">在这里，你可以配置的语言版本。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-115">From there, you can configure the language version.</span></span> <span data-ttu-id="4b7ce-116">选择"7.2"最新"。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="4b7ce-117">也可以在编辑*csproj*文件并添加以下节点：</span><span class="sxs-lookup"><span data-stu-id="4b7ce-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="4b7ce-118">值，可以使用"7.2"最新"。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="4b7ce-119">指定`in`参数</span><span class="sxs-lookup"><span data-stu-id="4b7ce-119">Specifying `in` parameters</span></span>

<span data-ttu-id="4b7ce-120">C# 7.2 添加`in`关键字来补充了现有`ref`和`out`关键字时编写的方法，通过引用传递的自变量。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="4b7ce-121">`in`关键字指定您要通过引用传递参数，而调用的方法没有修改传递给它的值。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="4b7ce-122">此新增提供了完整的词汇来表示你的设计意图。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="4b7ce-123">值类型时传递给调用的方法，如果不指定任何以下修饰符复制。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="4b7ce-124">这些修饰符的每个指定的值类型按引用传递，避免副本。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="4b7ce-125">每个修饰符表示不同的意图：</span><span class="sxs-lookup"><span data-stu-id="4b7ce-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="4b7ce-126">`out`： 此方法设置为此参数中使用的参数的值。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="4b7ce-127">`ref`： 此方法可能会将设置为此参数中使用的参数的值。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="4b7ce-128">`in`： 此方法没有修改作为此参数中使用的参数的值。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="4b7ce-129">当你将添加`in`修饰符来通过引用传递自变量声明你的设计意图是按引用以避免不必要复制传递自变量。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="4b7ce-130">你不打算修改用作该自变量的对象。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="4b7ce-131">下面的代码演示了计算在三维空间中的两个点之间的距离方法的示例。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="4b7ce-132">这些参数是，每个包含三个双精度型值的两个结构。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="4b7ce-133">双精度值是 8 个字节，因此每个自变量为 24 字节。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="4b7ce-134">通过指定`in`修饰符，4 字节或 8 字节引用传递到这些自变量，具体取决于计算机的体系结构。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="4b7ce-135">大小的差异很少，但当你的应用程序使用许多不同的值出现紧凑循环中调用此方法可以快速添加。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="4b7ce-136">`in`修饰符补充`out`和`ref`用其他方式。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="4b7ce-137">无法创建与不同，仅存在的方法的重载`in`，`out`或`ref`。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="4b7ce-138">这些新的规则扩展必须始终为已定义的行为相同`out`和`ref`参数。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="4b7ce-139">`in`修饰符可应用于任何采用参数的成员： 方法、 委托、 lambda、 本地函数、 索引器、 运算符。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="4b7ce-140">与不同`ref`和`out`自变量，你可以使用文本值或常量的自变量为`in`参数。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="4b7ce-141">此外，与不同`ref`或`out`参数，你不需要将应用`in`调用站点的修饰符。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="4b7ce-142">下面的代码演示调用的两个示例`CalculateDistance`方法。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="4b7ce-143">第一个命令使用通过引用传递的两个本地变量。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="4b7ce-144">第二个包含方法调用的一部分创建的临时变量。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="4b7ce-145">有几种方法在其中编译器可确保的只读的性质`in`强制执行自变量。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="4b7ce-146">首先，调用的方法不能将直接分配到`in`参数。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="4b7ce-147">它不能将直接分配到的任何字段`in`参数。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="4b7ce-148">此外，不能将传递`in`参数到任何方法要求严苛`ref`或`out`修饰符。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="4b7ce-149">编译器强制实施的`in`自变量是只读变量。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="4b7ce-150">你可以调用使用按值传递语义的任何实例方法。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="4b7ce-151">在这些情况下，一份`in`创建参数。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="4b7ce-152">因为编译器可以为任何创建的临时变量`in`参数，你还可以为任何指定默认值`in`参数。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="4b7ce-153">以下代码使用该值来指定为第二个点的默认值的来源 （点 0，0）：</span><span class="sxs-lookup"><span data-stu-id="4b7ce-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="4b7ce-154">`in`参数代码也可以用于引用类型或内置的数字值。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="4b7ce-155">但是，这两种情况的好处是最小，如果有的话。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="4b7ce-156">`ref readonly`返回</span><span class="sxs-lookup"><span data-stu-id="4b7ce-156">`ref readonly` returns</span></span>

<span data-ttu-id="4b7ce-157">你可能还想要通过引用，返回值类型，但不允许调用方修改该值。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="4b7ce-158">使用`ref readonly`修饰符来表示该设计意图。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="4b7ce-159">它将返回的引用现有数据，但不是允许修改通知读取器。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="4b7ce-160">编译器强制实施，调用方不能修改引用。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="4b7ce-161">尝试将直接分配给值会生成编译时错误。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="4b7ce-162">但是，编译器无法知道是否任何成员方法会修改该结构的状态。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="4b7ce-163">若要确保不修改该对象，编译器将创建副本，并调用使用该副本的引用的成员。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="4b7ce-164">任何修改都是到该防御性的副本。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="4b7ce-165">很可能，库使用`Point3D`通常将使用在整个代码的来源。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="4b7ce-166">每个实例在堆栈上创建一个新对象。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="4b7ce-167">它可能会创建一个常数，并通过引用返回它更有利。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="4b7ce-168">但是，如果返回到内部存储的引用，你可能需要强制，调用方不能修改引用的存储。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="4b7ce-169">下面的代码定义一个只读属性，返回`readonly ref`到`Point3D`指定的来源。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="4b7ce-170">创建一份 ref readonly 返回很容易： 只需将其分配给具有未声明的变量`ref readonly`修饰符。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="4b7ce-171">编译器将生成代码以将对象复制到分配的一部分。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="4b7ce-172">将分配到的变量时`ref readonly return`，你可以指定`ref readonly`变量或按值副本的 readonly 引用：</span><span class="sxs-lookup"><span data-stu-id="4b7ce-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="4b7ce-173">在前面的代码的第一个分配创建的副本`Origin`常量和复制的分配。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="4b7ce-174">第二个指定的引用。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-174">The second assigns a reference.</span></span> <span data-ttu-id="4b7ce-175">请注意，`readonly`修饰符必须是变量的声明的一部分。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="4b7ce-176">不能修改它所引用的引用。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="4b7ce-177">尝试这样做将导致编译时错误。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="4b7ce-178">`readonly struct` 类型</span><span class="sxs-lookup"><span data-stu-id="4b7ce-178">`readonly struct` type</span></span>

<span data-ttu-id="4b7ce-179">应用`ref readonly`到高流量使用的结构可能已足够。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="4b7ce-180">其他情况下，你可能想要创建不可变的结构。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="4b7ce-181">然后你可以始终传递 readonly 引用。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="4b7ce-182">当访问用作一个结构的方法时，做法删除被动复制发生`in`参数。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="4b7ce-183">你可以通过创建执行的操作`readonly struct`类型。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="4b7ce-184">你可以添加`readonly`修饰符添加到结构声明构造。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="4b7ce-185">编译器强制实施该结构的所有成员都是`readonly`;`struct`必须是不可变。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-185">The compiler enforces that all members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="4b7ce-186">有的其他优化`readonly struct`。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="4b7ce-187">你可以使用`in`在每个位置的修饰符其中`readonly struct`是的自变量。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="4b7ce-188">此外，你可以返回`readonly struct`作为`ref return`当您在返回其生存期超出返回对象的方法的作用域的对象。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="4b7ce-189">最后，编译器将生成更高效的代码调用的成员时`readonly struct`:`this`引用，而不是一份接收方，始终是`in`参数通过引用传递给成员方法。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="4b7ce-190">此优化将保存多个复制，当你使用`readonly struct`。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="4b7ce-191">`Point3D`是使此更改的理想。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="4b7ce-192">下面的代码显示了已更新`ReadonlyPoint3D`结构：</span><span class="sxs-lookup"><span data-stu-id="4b7ce-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="4b7ce-193">`ref struct` 类型</span><span class="sxs-lookup"><span data-stu-id="4b7ce-193">`ref struct` type</span></span>

<span data-ttu-id="4b7ce-194">另一个相关的语言功能是能够声明必须是堆栈中分配的值类型。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="4b7ce-195">换而言之，这些类型可以永远不会创建在堆上作为另一个类的成员。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="4b7ce-196">此功能的主要动机是<xref:System.Span%601>和相关的结构。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="4b7ce-197"><xref:System.Span%601>可能包含托管的指针作为其成员之一的另一个执行范围的长度。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="4b7ce-198">因为 C# 不支持在不安全的上下文之外的托管内存指针，则它是实际稍有不同实现。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="4b7ce-199">更改指针和长度的任何写入不是原子的。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="4b7ce-200">这意味着<xref:System.Span%601>将受制于超出范围错误或其他类型安全冲突是它不限于单个堆栈帧。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="4b7ce-201">此外，通常在 GC 堆上放置的托管的指针崩溃 JIT 时。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="4b7ce-202">你可能有类似要求使用内存使用创建[ `stackalloc` ](language-reference/keywords/stackalloc.md)或者使用互操作 Api 中的内存时。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="4b7ce-203">你可以定义自己`ref struct`为了满足这些需求的类型。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="4b7ce-204">在本文中，请参阅示例使用`Span<T>`为简单起见。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="4b7ce-205">`ref struct`声明会声明这种类型的结构，必须在堆栈上。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="4b7ce-206">使用语言规则确保这些类型的安全使用。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="4b7ce-207">其他类型声明为`ref struct`包括<xref:System.ReadOnlySpan%601>。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="4b7ce-208">若要保持的目标`ref struct`类型作为堆栈分配变量引入了几条规则，则编译器强制执行所有`ref struct`类型。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="4b7ce-209">不能装箱`ref struct`。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="4b7ce-210">不能将分配`ref struct`类型设置为变量的类型`object`， `dynamic`，或任何接口类型。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="4b7ce-211">不能声明`ref struct`作为一个类或正常结构的成员。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="4b7ce-212">你不能声明本地变量`ref struct`在异步方法中的类型。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="4b7ce-213">您可以在返回的同步方法中声明它们`Task`，`Task<T>`或类似任务的类型。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="4b7ce-214">不能声明`ref struct`迭代器中的本地变量。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="4b7ce-215">无法捕获`ref struct`在 lambda 表达式或本地函数中的变量。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="4b7ce-216">这些限制确保是你不会意外地使用`ref struct`无法将其提升为托管堆的方式。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="4b7ce-217">结论</span><span class="sxs-lookup"><span data-stu-id="4b7ce-217">Conclusions</span></span>

<span data-ttu-id="4b7ce-218">为 C# 语言的这些增强功能旨在用于内存分配可在其中实现必要的性能关键的性能关键算法。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="4b7ce-219">你可能会发现，通常不在你编写的代码中使用这些功能。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="4b7ce-220">但是，这些增强功能已在.NET Framework 中的许多位置已采用。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="4b7ce-221">随着越来越多的 Api 进行使用这些功能，你将看到自己的应用程序的性能改进。</span><span class="sxs-lookup"><span data-stu-id="4b7ce-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
