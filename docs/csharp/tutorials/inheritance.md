---
title: "C# 中的继承"
description: "了解如何在 C# 库和应用程序中运用继承。"
keywords: "继承 (C#), 基类, 派生类, 抽象基类"
author: rpetrusha
manager: wpickett
ms.author: ronpet
ms.date: 08/16/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 39de8879fd902c714a58cf59c70f0a4914b2ff6e
ms.sourcegitcommit: 9bee08539b1886c9d57fa3d5bd8a58dfdd7cad94
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/12/2017
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="5c400-104">C# 和 .NET 中的继承</span><span class="sxs-lookup"><span data-stu-id="5c400-104">Inheritance in C# and .NET</span></span>

<span data-ttu-id="5c400-105">此教程将介绍 C# 中的继承。</span><span class="sxs-lookup"><span data-stu-id="5c400-105">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="5c400-106">继承是面向对象的编程语言的一项功能，可方便你定义提供特定功能（数据和行为）的基类，并定义继承或重写此功能的派生类。</span><span class="sxs-lookup"><span data-stu-id="5c400-106">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="5c400-107">先决条件</span><span class="sxs-lookup"><span data-stu-id="5c400-107">Prerequisites</span></span>

<span data-ttu-id="5c400-108">阅读此教程的前提是，你已安装 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="5c400-108">This tutorial assumes that you've installed .NET Core.</span></span> <span data-ttu-id="5c400-109">有关安装说明，请参阅 [.NET Core 安装指南](https://www.microsoft.com/net/core)。</span><span class="sxs-lookup"><span data-stu-id="5c400-109">For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core).</span></span> <span data-ttu-id="5c400-110">还需要安装代码编辑器。</span><span class="sxs-lookup"><span data-stu-id="5c400-110">You also need a code editor.</span></span> <span data-ttu-id="5c400-111">此教程使用 [Visual Studio Code](https://code.visualstudio.com)，但你可以选择使用任何代码编辑器。</span><span class="sxs-lookup"><span data-stu-id="5c400-111">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="5c400-112">运行示例</span><span class="sxs-lookup"><span data-stu-id="5c400-112">Running the examples</span></span>

<span data-ttu-id="5c400-113">若要创建并运行此教程中的示例，请通过命令行使用 [dotnet](../../core/tools/dotnet.md) 实用工具。</span><span class="sxs-lookup"><span data-stu-id="5c400-113">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="5c400-114">对于每个示例，请按照以下步骤操作：</span><span class="sxs-lookup"><span data-stu-id="5c400-114">Follow these steps for each example:</span></span>

1. <span data-ttu-id="5c400-115">创建用于存储示例的目录。</span><span class="sxs-lookup"><span data-stu-id="5c400-115">Create a directory to store the example.</span></span>
1. <span data-ttu-id="5c400-116">在命令提示符处，输入 [dotnet new console](../../core/tools/dotnet-new.md) 命令，新建 .NET Core 项目。</span><span class="sxs-lookup"><span data-stu-id="5c400-116">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="5c400-117">将示例中的代码复制并粘贴到代码编辑器中。</span><span class="sxs-lookup"><span data-stu-id="5c400-117">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="5c400-118">在命令行处输入 [dotnet restore](../../core/tools/dotnet-restore.md) 命令，加载或还原项目的依赖项。</span><span class="sxs-lookup"><span data-stu-id="5c400-118">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="5c400-119">输入 [dotnet run](../../core/tools/dotnet-run.md) 命令，编译并执行示例。</span><span class="sxs-lookup"><span data-stu-id="5c400-119">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>


## <a name="background-what-is-inheritance"></a><span data-ttu-id="5c400-120">背景知识：什么是继承？</span><span class="sxs-lookup"><span data-stu-id="5c400-120">Background: What is inheritance?</span></span>

<span data-ttu-id="5c400-121">*继承*是面向对象的编程的一种基本特性。</span><span class="sxs-lookup"><span data-stu-id="5c400-121">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="5c400-122">借助继承，能够定义可重用（继承）、扩展或修改父类行为的子类。</span><span class="sxs-lookup"><span data-stu-id="5c400-122">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="5c400-123">成员被继承的类称为*基类*。</span><span class="sxs-lookup"><span data-stu-id="5c400-123">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="5c400-124">继承基类成员的类称为*派生类*。</span><span class="sxs-lookup"><span data-stu-id="5c400-124">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="5c400-125">C# 和 .NET 只支持*单一继承*。</span><span class="sxs-lookup"><span data-stu-id="5c400-125">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="5c400-126">也就是说，类只能继承自一个类。</span><span class="sxs-lookup"><span data-stu-id="5c400-126">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="5c400-127">不过，继承是可传递的。这样一来，就可以为一组类型定义继承层次结构。</span><span class="sxs-lookup"><span data-stu-id="5c400-127">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="5c400-128">换言之，类型 `D` 可继承自类型 `C`，其中类型 `C` 继承自类型 `B`，类型 `B` 又继承自基类类型 `A`。</span><span class="sxs-lookup"><span data-stu-id="5c400-128">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="5c400-129">由于继承是可传递的，因此类型 `D` 继承了类型 `A` 的成员。</span><span class="sxs-lookup"><span data-stu-id="5c400-129">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="5c400-130">并非所有基类成员都可供派生类继承。</span><span class="sxs-lookup"><span data-stu-id="5c400-130">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="5c400-131">以下成员无法继承：</span><span class="sxs-lookup"><span data-stu-id="5c400-131">The following members are not inherited:</span></span>

- <span data-ttu-id="5c400-132">[静态构造函数](../programming-guide/classes-and-structs/static-constructors.md)：用于初始化类的静态数据。</span><span class="sxs-lookup"><span data-stu-id="5c400-132">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="5c400-133">[实例构造函数](../programming-guide/classes-and-structs/constructors.md)：在创建类的新实例时调用。</span><span class="sxs-lookup"><span data-stu-id="5c400-133">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="5c400-134">每个类都必须定义自己的构造函数。</span><span class="sxs-lookup"><span data-stu-id="5c400-134">Each class must define its own constructors.</span></span>

- <span data-ttu-id="5c400-135">[终结器](../programming-guide/classes-and-structs/destructors.md)：由运行时的垃圾回收器调用，用于销毁类实例。</span><span class="sxs-lookup"><span data-stu-id="5c400-135">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="5c400-136">虽然基类的其他所有成员都可供派生类继承，但这些成员是否可见取决于它们的可访问性。</span><span class="sxs-lookup"><span data-stu-id="5c400-136">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="5c400-137">成员的可访问性决定了其是否在派生类中可见，如下所述：</span><span class="sxs-lookup"><span data-stu-id="5c400-137">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="5c400-138">只有在基类中嵌套的派生类中，[私有](../language-reference/keywords/private.md)成员才可见。</span><span class="sxs-lookup"><span data-stu-id="5c400-138">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="5c400-139">否则，此类成员在派生类中不可见。</span><span class="sxs-lookup"><span data-stu-id="5c400-139">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="5c400-140">在以下示例中，`A.B` 是派生自 `A` 的嵌套类，而 `C` 则派生自 `A`。</span><span class="sxs-lookup"><span data-stu-id="5c400-140">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="5c400-141">私有 `A.value` 字段在 A.B 中可见。</span><span class="sxs-lookup"><span data-stu-id="5c400-141">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="5c400-142">不过，如果从 `C.GetValue` 方法中删除注释并尝试编译示例，则会生成编译器错误 CS0122：“'A.value' 不可访问，因为它具有一定的保护级别。”</span><span class="sxs-lookup"><span data-stu-id="5c400-142">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="5c400-143">[受保护](../language-reference/keywords/protected.md)成员仅在派生类中可见。</span><span class="sxs-lookup"><span data-stu-id="5c400-143">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="5c400-144">[内部](../language-reference/keywords/internal.md)成员仅在与基类同属一个程序集的派生类中可见，</span><span class="sxs-lookup"><span data-stu-id="5c400-144">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="5c400-145">在与基类属于不同程序集的派生类中不可见。</span><span class="sxs-lookup"><span data-stu-id="5c400-145">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="5c400-146">[公共](../language-reference/keywords/public.md)成员在派生类中可见，并且属于派生类的公共接口。</span><span class="sxs-lookup"><span data-stu-id="5c400-146">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="5c400-147">可以调用继承的公共成员，就像它们是在派生类中定义一样。</span><span class="sxs-lookup"><span data-stu-id="5c400-147">Public inherited members can be called just as if they were defined in the derived class.</span></span> <span data-ttu-id="5c400-148">在以下示例中，类 `A` 定义 `Method1` 方法，类 `B` 继承自类 `A`。</span><span class="sxs-lookup"><span data-stu-id="5c400-148">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="5c400-149">然后，以下示例调用 `Method1`，就像它是 `B` 中的实例方法一样。</span><span class="sxs-lookup"><span data-stu-id="5c400-149">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="5c400-150">派生类还可以通过提供重写实现代码来*重写*继承的成员。</span><span class="sxs-lookup"><span data-stu-id="5c400-150">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="5c400-151">基类成员必须标记有 [virtual](../language-reference/keywords/virtual.md) 关键字，才能重写继承的成员。</span><span class="sxs-lookup"><span data-stu-id="5c400-151">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="5c400-152">默认情况下，基类成员没有 `virtual` 标记，因此无法被重写。</span><span class="sxs-lookup"><span data-stu-id="5c400-152">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="5c400-153">如果尝试重写非虚成员（如以下示例所示），则会生成编译器错误 CS0506：“<member> 无法重写继承的成员 <member>，因为继承的成员没有 virtual、abstract 或 override 标记。”</span><span class="sxs-lookup"><span data-stu-id="5c400-153">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "<member> cannot override inherited member <member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="5c400-154">在某些情况下，派生类*必须*重写基类实现代码。</span><span class="sxs-lookup"><span data-stu-id="5c400-154">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="5c400-155">标记有 [abstract](../language-reference/keywords/abstract.md) 关键字的基类成员要求派生类必须重写它们。</span><span class="sxs-lookup"><span data-stu-id="5c400-155">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="5c400-156">如果尝试编译以下示例，则会生成编译器错误 CS0534：“<class> 不实现继承的抽象成员 <member>，因为类 `B` 没有提供 `A.Method1` 的实现代码。”</span><span class="sxs-lookup"><span data-stu-id="5c400-156">Attempting to compile the following example generates compiler error CS0534, "<class> does not implement inherited abstract member <member>', because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="5c400-157">继承仅适用于类和接口。</span><span class="sxs-lookup"><span data-stu-id="5c400-157">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="5c400-158">其他各种类型（结构、委托和枚举）均不支持继承。</span><span class="sxs-lookup"><span data-stu-id="5c400-158">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="5c400-159">因此，如果尝试编译以下代码，则会生成编译器错误 CS0527：“接口列表中的类型 'ValueType' 不是接口。”</span><span class="sxs-lookup"><span data-stu-id="5c400-159">Because of this, attempting to compile code like the following produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="5c400-160">此错误消息指明，尽管可以定义结构实现的接口，但不支持继承。</span><span class="sxs-lookup"><span data-stu-id="5c400-160">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="5c400-161">隐式继承</span><span class="sxs-lookup"><span data-stu-id="5c400-161">Implicit inheritance</span></span>

<span data-ttu-id="5c400-162">.NET 类型系统中的所有类型除了可以通过单一继承进行继承之外，还可以隐式继承自 <xref:System.Object> 或其派生的类型。</span><span class="sxs-lookup"><span data-stu-id="5c400-162">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="5c400-163">这就确保了常见功能可用于任何类型。</span><span class="sxs-lookup"><span data-stu-id="5c400-163">This ensures that common functionality is available to any type.</span></span>

<span data-ttu-id="5c400-164">为了说明隐式继承的具体含义，让我们来定义一个新类 `SimpleClass`，这只是一个空类定义：</span><span class="sxs-lookup"><span data-stu-id="5c400-164">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="5c400-165">然后，我们可以使用反射（方便我们检查类型的元数据，从而获取此类型的相关信息），获取 `SimpleClass` 类型的成员列表。</span><span class="sxs-lookup"><span data-stu-id="5c400-165">We can then use reflection (which lets us inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="5c400-166">尽管我们没有在 `SimpleClass` 类中定义任何成员，但示例输出表明它实际上有九个成员。</span><span class="sxs-lookup"><span data-stu-id="5c400-166">Although we haven't defined any members in our `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="5c400-167">其中之一是由 C# 编译器自动为 `SimpleClass` 类型提供的无参数（或默认）构造函数。</span><span class="sxs-lookup"><span data-stu-id="5c400-167">One of these is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="5c400-168">剩余八个是 <xref:System.Object>（.NET 类型系统中的所有类和接口最终隐式继承自的类型）的成员。</span><span class="sxs-lookup"><span data-stu-id="5c400-168">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="5c400-169">由于隐式继承自 <xref:System.Object> 类，因此 `SimpleClass` 类可以使用下面这些方法：</span><span class="sxs-lookup"><span data-stu-id="5c400-169">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="5c400-170">公共 `ToString` 方法将 `SimpleClass` 对象转换为字符串表示形式，返回完全限定的类型名称。</span><span class="sxs-lookup"><span data-stu-id="5c400-170">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="5c400-171">在这种情况下，`ToString` 方法返回字符串“SimpleClass”。</span><span class="sxs-lookup"><span data-stu-id="5c400-171">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="5c400-172">三个用于测试两个对象是否相等的方法：公共实例 `Equals(Object)` 方法、公共静态 `Equals(Object, Object)` 方法和公共静态 `ReferenceEquals(Object, Object)` 方法。</span><span class="sxs-lookup"><span data-stu-id="5c400-172">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="5c400-173">默认情况下，这三个方法测试的是引用相等性；也就是说，两个对象变量必须引用同一个对象，才算相等。</span><span class="sxs-lookup"><span data-stu-id="5c400-173">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="5c400-174">公共 `GetHashCode` 方法：计算允许在经哈希处理的集合中使用类型实例的值。</span><span class="sxs-lookup"><span data-stu-id="5c400-174">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="5c400-175">公共 `GetType` 方法：返回表示 `SimpleClass` 类型的 <xref:System.Type> 对象。</span><span class="sxs-lookup"><span data-stu-id="5c400-175">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="5c400-176">受保护 <xref:System.Object.Finalize%2A> 方法：用于在垃圾回收器回收对象的内存之前释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="5c400-176">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="5c400-177">受保护 <xref:System.Object.MemberwiseClone%2A> 方法：创建当前对象的浅表克隆。</span><span class="sxs-lookup"><span data-stu-id="5c400-177">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="5c400-178">由于是隐式继承，因此我们可以调用 `SimpleClass` 对象中任何继承的成员，就像它实际上是 `SimpleClass` 类中定义的成员一样。</span><span class="sxs-lookup"><span data-stu-id="5c400-178">Because of implicit inheritance, we can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="5c400-179">例如，下面的示例调用 `SimpleClass` 从 <xref:System.Object> 继承而来的 `SimpleClass.ToString` 方法。</span><span class="sxs-lookup"><span data-stu-id="5c400-179">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="5c400-180">下表列出了可以在 C# 中创建的各种类型及其隐式继承自的类型。</span><span class="sxs-lookup"><span data-stu-id="5c400-180">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="5c400-181">每个基类型通过继承向隐式派生的类型提供一组不同的成员。</span><span class="sxs-lookup"><span data-stu-id="5c400-181">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="5c400-182">类型类别</span><span class="sxs-lookup"><span data-stu-id="5c400-182">Type category</span></span> | <span data-ttu-id="5c400-183">隐式继承自</span><span class="sxs-lookup"><span data-stu-id="5c400-183">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="5c400-184">类</span><span class="sxs-lookup"><span data-stu-id="5c400-184">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="5c400-185">struct</span><span class="sxs-lookup"><span data-stu-id="5c400-185">struct</span></span>        | <span data-ttu-id="5c400-186"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="5c400-186"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="5c400-187">enum</span><span class="sxs-lookup"><span data-stu-id="5c400-187">enum</span></span>          | <span data-ttu-id="5c400-188"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="5c400-188"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="5c400-189">委托</span><span class="sxs-lookup"><span data-stu-id="5c400-189">delegate</span></span>      | <span data-ttu-id="5c400-190"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="5c400-190"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="5c400-191">继承和“is a”关系</span><span class="sxs-lookup"><span data-stu-id="5c400-191">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="5c400-192">通常情况下，继承用于表示基类和一个或多个派生类之间的“is a”关系，其中派生类是基类的特定版本；派生类是基类的具体类型。</span><span class="sxs-lookup"><span data-stu-id="5c400-192">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="5c400-193">例如，`Publication` 类表示任何类型的出版物，`Book` 和 `Magazine` 类表示出版物的具体类型。</span><span class="sxs-lookup"><span data-stu-id="5c400-193">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="5c400-194">一个类或结构可以实现一个或多个接口。</span><span class="sxs-lookup"><span data-stu-id="5c400-194">A class or struct can implement one more interfaces.</span></span> <span data-ttu-id="5c400-195">虽然接口实现代码通常用作单一继承的解决方法或对结构使用继承的方法，但它旨在表示接口与其实现类型之间的不同关系（即“can do”关系），而不是继承关系。</span><span class="sxs-lookup"><span data-stu-id="5c400-195">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="5c400-196">接口定义了其向实现类型提供的一部分功能（如测试相等性、比较或排序对象，或支持区域性敏感的分析和格式设置）。</span><span class="sxs-lookup"><span data-stu-id="5c400-196">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="5c400-197">请注意，“is a”还表示类型与其特定实例化之间的关系。</span><span class="sxs-lookup"><span data-stu-id="5c400-197">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="5c400-198">在以下示例中，`Automobile` 类包含三个唯一只读属性：`Make`（汽车制造商）、`Model`（汽车型号）和 `Year`（汽车出厂年份）。</span><span class="sxs-lookup"><span data-stu-id="5c400-198">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="5c400-199">`Automobile` 类还有一个自变量被分配给属性值的构造函数，并将 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法重写为生成唯一标识 `Automobile` 实例（而不是 `Automobile` 类）的字符串。</span><span class="sxs-lookup"><span data-stu-id="5c400-199">Our `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="5c400-200">在这种情况下，我们不得依赖继承来表示特定汽车品牌和型号。</span><span class="sxs-lookup"><span data-stu-id="5c400-200">In this case, we should not rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="5c400-201">例如，我们不需要定义 `Packard` 类型来表示帕卡德制造的汽车。</span><span class="sxs-lookup"><span data-stu-id="5c400-201">For example, we do not need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="5c400-202">相反，我们可以通过创建将相应值传递给其类构造函数的 `Automobile` 对象来进行表示，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="5c400-202">Instead, we can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="5c400-203">基于继承的“is a”关系最适用于基类和向基类添加附加成员或需要基类没有的其他功能的派生类。</span><span class="sxs-lookup"><span data-stu-id="5c400-203">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="5c400-204">设计基类及其派生类</span><span class="sxs-lookup"><span data-stu-id="5c400-204">Designing the base class and derived classes</span></span>

<span data-ttu-id="5c400-205">让我们来看看如何设计基类及其派生类。</span><span class="sxs-lookup"><span data-stu-id="5c400-205">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="5c400-206">在此部分中，我们将定义一个基类 `Publication`，用于表示任何类型的出版物，如书籍、杂志、报纸、期刊、文章等。我们还将定义一个从 `Publication` 派生的 `Book` 类。</span><span class="sxs-lookup"><span data-stu-id="5c400-206">In this section, we'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="5c400-207">我们可以将示例轻松扩展为定义其他派生类，如 `Magazine`、`Journal`、`Newspaper` 和 `Article`。</span><span class="sxs-lookup"><span data-stu-id="5c400-207">We could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="5c400-208">Publication 基类</span><span class="sxs-lookup"><span data-stu-id="5c400-208">The base Publication class</span></span>

<span data-ttu-id="5c400-209">设计 `Publication` 类时，我们需要做出下面几项设计决策：</span><span class="sxs-lookup"><span data-stu-id="5c400-209">In designing our `Publication` class, we need to make several design decisions:</span></span>

- <span data-ttu-id="5c400-210">要在 `Publication` 基类中添加哪些成员、`Publication` 成员是否提供方法实现代码，或 `Publication` 是否是用作派生类模板的抽象基类。</span><span class="sxs-lookup"><span data-stu-id="5c400-210">What members to include in our base `Publication` class, and whether the `Publication` members provide method implementations, or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="5c400-211">在此示例中，`Publication` 类提供方法实现代码。</span><span class="sxs-lookup"><span data-stu-id="5c400-211">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="5c400-212">[设计抽象基类及其派生类](#abstract)部分中的示例就使用抽象基类定义派生类必须重写的方法。</span><span class="sxs-lookup"><span data-stu-id="5c400-212">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="5c400-213">派生类可以随时提供适合派生类型的任意实现代码。</span><span class="sxs-lookup"><span data-stu-id="5c400-213">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="5c400-214">能够重用代码（即多个派生类共用基类方法的声明和实现代码，无需重写它们）是非抽象基类的优势所在。</span><span class="sxs-lookup"><span data-stu-id="5c400-214">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="5c400-215">因此，如果代码可能由某些或大多数特定 `Publication` 类型共用，我们应该向 `Publication` 添加成员。</span><span class="sxs-lookup"><span data-stu-id="5c400-215">Therefore, we should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="5c400-216">如果不能有效执行此操作，那么我们最终将不得不在派生类中提供基本相同的成员实现代码，而不是共用基类中的同一实现代码。</span><span class="sxs-lookup"><span data-stu-id="5c400-216">If we fail to do this efficiently, we'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="5c400-217">如果需要在多个位置保留重复的代码，可能会导致 bug 出现。</span><span class="sxs-lookup"><span data-stu-id="5c400-217">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="5c400-218">为了最大限度地提高代码重用性并创建合乎逻辑的直观继承层次结构，我们希望确保在 `Publication` 类中只添加所有或大多数出版物通用的数据和功能。</span><span class="sxs-lookup"><span data-stu-id="5c400-218">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="5c400-219">然后，派生类可以实现所表示的特定出版物种类的唯一成员。</span><span class="sxs-lookup"><span data-stu-id="5c400-219">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="5c400-220">类层次结构的扩展空间大小。</span><span class="sxs-lookup"><span data-stu-id="5c400-220">How far to extend our class hierarchy.</span></span> <span data-ttu-id="5c400-221">是否要开发包含三个或多个类的层次结构，而不是仅包含一个基类和一个或多个派生类？</span><span class="sxs-lookup"><span data-stu-id="5c400-221">Do we want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="5c400-222">例如，`Publication` 可以是 `Periodical` 的基类，而后者又是 `Magazine`、`Journal` 和 `Newspaper` 的基类。</span><span class="sxs-lookup"><span data-stu-id="5c400-222">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="5c400-223">在我们的示例中，我们将使用包含 `Publication` 类和一个派生类 `Book` 的简单层次结构。</span><span class="sxs-lookup"><span data-stu-id="5c400-223">For our example, we'll use the simple hierarchy of a `Publication` class and a single derived classes, `Book`.</span></span> <span data-ttu-id="5c400-224">我们可以将此示例轻松扩展为创建其他许多派生自 `Publication` 的类，如 `Magazine` 和 `Article`。</span><span class="sxs-lookup"><span data-stu-id="5c400-224">We could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="5c400-225">能否实例化基类。</span><span class="sxs-lookup"><span data-stu-id="5c400-225">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="5c400-226">如果不可以，我们应向类应用 [abstract](../language-reference/keywords/abstract.md) 关键字。</span><span class="sxs-lookup"><span data-stu-id="5c400-226">If it does not, we should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="5c400-227">如果尝试通过直接调用类构造函数来实例化标记有 `abstract` 关键字的类，则 C# 编译器会生成错误 CS0144：“无法创建抽象类或接口的实例。”</span><span class="sxs-lookup"><span data-stu-id="5c400-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="5c400-228">如果尝试使用反射来实例化类，则反射方法会抛出 <xref:System.MemberAccessException>。</span><span class="sxs-lookup"><span data-stu-id="5c400-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span> <span data-ttu-id="5c400-229">否则，可通过调用类构造函数来实例化 `Publication` 类。</span><span class="sxs-lookup"><span data-stu-id="5c400-229">Otherwise, our `Publication` class can be instantiated by calling its class constructor.</span></span>

  <span data-ttu-id="5c400-230">默认情况下，可以通过调用类构造函数来实例化基类。</span><span class="sxs-lookup"><span data-stu-id="5c400-230">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="5c400-231">请注意，我们无需显式定义类构造函数。</span><span class="sxs-lookup"><span data-stu-id="5c400-231">Note that we do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="5c400-232">如果基类的源代码中没有类构造函数，C# 编译器会自动提供默认的（无参数）构造函数。</span><span class="sxs-lookup"><span data-stu-id="5c400-232">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="5c400-233">对于我们的示例，我们将把 `Publication` 类标记为 [abstract](../language-reference/keywords/abstract.md)，使其无法实例化。</span><span class="sxs-lookup"><span data-stu-id="5c400-233">For our example, we'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>

- <span data-ttu-id="5c400-234">派生类是否必须继承特定成员的基类实现代码，或能否重写基类实现代码。</span><span class="sxs-lookup"><span data-stu-id="5c400-234">Whether derived classes must inherit the base class implementation of a particular members, or whether they have the option to override the base class implementation.</span></span> <span data-ttu-id="5c400-235">我们必须使用 [virtual](../language-reference/keywords/virtual.md) 关键字，才能允许派生类重写基类方法。</span><span class="sxs-lookup"><span data-stu-id="5c400-235">We have to use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="5c400-236">默认情况下，*不*可重写基类中定义的方法。</span><span class="sxs-lookup"><span data-stu-id="5c400-236">By default, methods defined in the base class are *not* overridable.</span></span>

- <span data-ttu-id="5c400-237">派生类是否表示继承层次结构中的最终类，且本身不能用作其他派生类的基类。</span><span class="sxs-lookup"><span data-stu-id="5c400-237">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="5c400-238">默认情况下，任何类都可以用作基类。</span><span class="sxs-lookup"><span data-stu-id="5c400-238">By default, any class can serve as a base class.</span></span> <span data-ttu-id="5c400-239">我们可以应用 [sealed](../language-reference/keywords/sealed.md) 关键字，以指明类不能用作其他任何类的基类。</span><span class="sxs-lookup"><span data-stu-id="5c400-239">We can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="5c400-240">如果尝试从密封类派生，则会生成编译器错误 CS0509：“无法从密封类型 <typeName> 派生。”</span><span class="sxs-lookup"><span data-stu-id="5c400-240">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type <typeName>".</span></span>

  <span data-ttu-id="5c400-241">对于我们的示例，我们将把派生类标记为 `sealed`。</span><span class="sxs-lookup"><span data-stu-id="5c400-241">For our example, we'll mark our derived class as `sealed`.</span></span>

<span data-ttu-id="5c400-242">以下示例展示了 `Publication` 类的源代码，以及 `Publication.PublicationType` 属性返回的 `PublicationType` 枚举。</span><span class="sxs-lookup"><span data-stu-id="5c400-242">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="5c400-243">除了继承自 <xref:System.Object> 的成员之外，`Publication` 类还定义了以下唯一成员和成员重写：</span><span class="sxs-lookup"><span data-stu-id="5c400-243">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="5c400-244">构造函数</span><span class="sxs-lookup"><span data-stu-id="5c400-244">A constructor</span></span>

  <span data-ttu-id="5c400-245">由于 `Publication` 类标记有 `abstract`，因此无法直接通过以下代码进行实例化：</span><span class="sxs-lookup"><span data-stu-id="5c400-245">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="5c400-246">不过，它的实例构造函数可以直接通过派生类构造函数进行调用，如 `Book` 类的源代码所示。</span><span class="sxs-lookup"><span data-stu-id="5c400-246">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="5c400-247">两个与出版物相关的属性</span><span class="sxs-lookup"><span data-stu-id="5c400-247">Two publication-related properties</span></span>

  <span data-ttu-id="5c400-248">`Title` 是只读 <xref:System.String> 属性，其值通过调用 `Publication` 构造函数提供。</span><span class="sxs-lookup"><span data-stu-id="5c400-248">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="5c400-249">`Pages` 是读写 <xref:System.Int32> 属性，用于指明出版物的总页数。</span><span class="sxs-lookup"><span data-stu-id="5c400-249">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="5c400-250">值存储在 `totalPages` 私有字段中。</span><span class="sxs-lookup"><span data-stu-id="5c400-250">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="5c400-251">值必须为正数，否则会抛出 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="5c400-251">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="5c400-252">与出版商相关的成员</span><span class="sxs-lookup"><span data-stu-id="5c400-252">Publisher-related members</span></span>

  <span data-ttu-id="5c400-253">两个只读属性：`Publisher` 和 `Type`。</span><span class="sxs-lookup"><span data-stu-id="5c400-253">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="5c400-254">值最初是通过调用 `Publication` 类构造函数来提供。</span><span class="sxs-lookup"><span data-stu-id="5c400-254">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="5c400-255">与出版相关的成员</span><span class="sxs-lookup"><span data-stu-id="5c400-255">Publishing-related members</span></span>

  <span data-ttu-id="5c400-256">两个方法（`Publish` 和 `GetPublicationDate`）用于设置并返回发布日期。</span><span class="sxs-lookup"><span data-stu-id="5c400-256">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="5c400-257">调用时，`Publish` 方法会将 `published` 标志设置为 `true`，并将传递给它的日期作为自变量分配给 `datePublished` 私有字段。</span><span class="sxs-lookup"><span data-stu-id="5c400-257">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="5c400-258">如果 `published` 标志为 `false`，`GetPublicationDate` 方法会返回字符串“NYP”；如果为 `true`，则会返回 `datePublished` 字段的值。</span><span class="sxs-lookup"><span data-stu-id="5c400-258">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="5c400-259">与版权相关的成员</span><span class="sxs-lookup"><span data-stu-id="5c400-259">Copyright-related members</span></span>

  <span data-ttu-id="5c400-260">`Copyright` 方法需要将版权所有者的姓名和版权授予年份用作参数，并将它们分配给属性 `CopyrightName` 和 `CopyrightDate`。</span><span class="sxs-lookup"><span data-stu-id="5c400-260">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="5c400-261">重写 `ToString` 方法</span><span class="sxs-lookup"><span data-stu-id="5c400-261">An override of the `ToString` method</span></span>

  <span data-ttu-id="5c400-262">如果类型不重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法，则返回类型的完全限定的名称，这对于区分实例没什么用。</span><span class="sxs-lookup"><span data-stu-id="5c400-262">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="5c400-263">`Publication` 类将 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 重写为返回 `Title` 属性值。</span><span class="sxs-lookup"><span data-stu-id="5c400-263">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="5c400-264">下图展示了基类 `Publication` 及其隐式继承类 <xref:System.Object> 之间的关系。</span><span class="sxs-lookup"><span data-stu-id="5c400-264">The following figure illustrates the relationship between our base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Object 和 Publication 类](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="5c400-266">`Book` 类</span><span class="sxs-lookup"><span data-stu-id="5c400-266">The `Book` class</span></span>

<span data-ttu-id="5c400-267">`Book` 类表示作为一种特定类型出版物的书籍。</span><span class="sxs-lookup"><span data-stu-id="5c400-267">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="5c400-268">下面的示例展示了 `Book` 类的源代码。</span><span class="sxs-lookup"><span data-stu-id="5c400-268">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="5c400-269">除了继承自 `Publication` 的成员之外，`Book` 类还定义了以下唯一成员和成员重写：</span><span class="sxs-lookup"><span data-stu-id="5c400-269">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="5c400-270">两个构造函数</span><span class="sxs-lookup"><span data-stu-id="5c400-270">Two constructors</span></span>

  <span data-ttu-id="5c400-271">两个 `Book` 构造函数共用三个常见参数。</span><span class="sxs-lookup"><span data-stu-id="5c400-271">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="5c400-272">其中两个参数（*title* 和 *publisher*）对应于 `Publication` 构造函数的相应参数。</span><span class="sxs-lookup"><span data-stu-id="5c400-272">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="5c400-273">第三个参数是 *author*，存储在 `authorName` 私有字段中。</span><span class="sxs-lookup"><span data-stu-id="5c400-273">The third is *author*, which is stored to a private `authorName` field.</span></span> <span data-ttu-id="5c400-274">其中一个构造函数包含存储在 `ISBN` 自动属性中的 isbn 参数。</span><span class="sxs-lookup"><span data-stu-id="5c400-274">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="5c400-275">第一个构造函数使用 [this](../language-reference/keywords/this.md) 关键字来调用另一个构造函数。</span><span class="sxs-lookup"><span data-stu-id="5c400-275">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="5c400-276">这是常见的构造函数定义模式。</span><span class="sxs-lookup"><span data-stu-id="5c400-276">This is a common pattern in defining constructors.</span></span> <span data-ttu-id="5c400-277">调用参数最多的构造函数时，由参数较少的构造函数提供默认值。</span><span class="sxs-lookup"><span data-stu-id="5c400-277">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="5c400-278">第二个构造函数使用 [base](../language-reference/keywords/base.md) 关键字，将标题和出版商名称传递给基类构造函数。</span><span class="sxs-lookup"><span data-stu-id="5c400-278">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="5c400-279">如果没有在源代码中显式调用基类构造函数，那么 C# 编译器会自动提供对基类的默认或无参数构造函数的调用。</span><span class="sxs-lookup"><span data-stu-id="5c400-279">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="5c400-280">只读 `ISBN` 属性，用于返回 `Book` 对象的国际标准书号，即 10 位或 13 位的专属编号。</span><span class="sxs-lookup"><span data-stu-id="5c400-280">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="5c400-281">ISBN 作为参数提供给 `Book` 构造函数之一。</span><span class="sxs-lookup"><span data-stu-id="5c400-281">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="5c400-282">ISBN 存储在私有支持字段中，由编译器自动生成。</span><span class="sxs-lookup"><span data-stu-id="5c400-282">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="5c400-283">只读 `Author` 属性。</span><span class="sxs-lookup"><span data-stu-id="5c400-283">A read-only `Author` property.</span></span> <span data-ttu-id="5c400-284">作者姓名作为自变量提供给两个 `Book` 构造函数，并存储在 `authorName` 私有字段中。</span><span class="sxs-lookup"><span data-stu-id="5c400-284">The author name is supplied as an argument to both `Book` constructors and is stored in the private `authorName` field.</span></span>

- <span data-ttu-id="5c400-285">两个与价格相关的只读属性（`Price` 和 `Currency`）。</span><span class="sxs-lookup"><span data-stu-id="5c400-285">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="5c400-286">值作为自变量提供给调用的 `SetPrice` 方法。</span><span class="sxs-lookup"><span data-stu-id="5c400-286">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="5c400-287">价格存储在 `bookPrice` 私有字段中。</span><span class="sxs-lookup"><span data-stu-id="5c400-287">The price is stored in a private field, `bookPrice`.</span></span> <span data-ttu-id="5c400-288">`Currency` 属性是三位的 ISO 货币符号（例如，USD 表示美元），并存储在 `ISOCurrencySymbol` 私有字段中。</span><span class="sxs-lookup"><span data-stu-id="5c400-288">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private `ISOCurrencySymbol` field.</span></span> <span data-ttu-id="5c400-289">可以从 <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> 属性检索 ISO 货币符号。</span><span class="sxs-lookup"><span data-stu-id="5c400-289">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span>

- <span data-ttu-id="5c400-290">`SetPrice` 方法，用于设置 `bookPrice` 和 `ISOCurrencySymbol` 字段的值。</span><span class="sxs-lookup"><span data-stu-id="5c400-290">A `SetPrice` method, which sets the values of the `bookPrice` and `ISOCurrencySymbol` fields.</span></span> <span data-ttu-id="5c400-291">这些是 `Price` 和 `Currency` 属性返回的值。</span><span class="sxs-lookup"><span data-stu-id="5c400-291">These are the values returned by the `Price` and `Currency` properties.</span></span>

- <span data-ttu-id="5c400-292">重写 `ToString` 方法（继承自 `Publication`）、<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 和 <xref:System.Object.GetHashCode%2A> 方法（继承自 <xref:System.Object>）。</span><span class="sxs-lookup"><span data-stu-id="5c400-292">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="5c400-293">除非重写，否则 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法测试的是引用相等性。</span><span class="sxs-lookup"><span data-stu-id="5c400-293">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="5c400-294">也就是说，两个对象变量必须引用同一个对象，才算相等。</span><span class="sxs-lookup"><span data-stu-id="5c400-294">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="5c400-295">相比之下，对于 `Book` 类，两个 `Book` 对象必须包含相同的 ISBN，才算相等。</span><span class="sxs-lookup"><span data-stu-id="5c400-295">In the case of the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="5c400-296">重写 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 方法时，还必须重写 <xref:System.Object.GetHashCode%2A> 方法，此方法返回运行时为了实现高效检索，在经哈希处理的集合中存储项所使用的值。</span><span class="sxs-lookup"><span data-stu-id="5c400-296">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="5c400-297">哈希代码应返回与测试相等性一致的值。</span><span class="sxs-lookup"><span data-stu-id="5c400-297">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="5c400-298">由于我们已将 <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> 重写为在两个 `Book` 对象的 ISBN 属性相等时返回 `true`，因此我们返回的哈希代码是通过调用 `ISBN` 属性返回的字符串的 <xref:System.String.GetHashCode%2A> 方法计算得出。</span><span class="sxs-lookup"><span data-stu-id="5c400-298">Since we've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, we return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="5c400-299">下图展示了 `Book` 类及其基类 `Publication` 之间的关系。</span><span class="sxs-lookup"><span data-stu-id="5c400-299">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Publication 和 Book 类](media/book-class.jpg)

<span data-ttu-id="5c400-301">现在，我们可以实例化 `Book` 对象，调用其唯一成员和继承的成员，并将其作为自变量传递给需要 `Publication` 或 `Book` 类型参数的方法，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="5c400-301">We can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="5c400-302">设计抽象基类及其派生类</span><span class="sxs-lookup"><span data-stu-id="5c400-302">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="5c400-303">在上面的示例中，我们定义了一个基类，它提供了许多方法的实现代码，以便派生类可以共用代码。</span><span class="sxs-lookup"><span data-stu-id="5c400-303">In the previous example, we defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="5c400-304">然而，在许多情况下，我们并不希望基类提供实现代码。</span><span class="sxs-lookup"><span data-stu-id="5c400-304">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="5c400-305">相反，基类是*抽象类*，用作定义每个派生类必须实现的成员的模板。</span><span class="sxs-lookup"><span data-stu-id="5c400-305">Instead, the base class is an *abstract class*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="5c400-306">通常情况下，对于抽象基类，每个派生类型的实现代码都是相应类型的专属代码。</span><span class="sxs-lookup"><span data-stu-id="5c400-306">Typically in the case of an abstract base class, the implementation of each derived type is unique to that type.</span></span>

<span data-ttu-id="5c400-307">例如，每个封闭的二维几何形状都包含两个属性：面积（即形状的内部空间）和周长（或沿形状一周的长度）。</span><span class="sxs-lookup"><span data-stu-id="5c400-307">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="5c400-308">然而，这两个属性的计算方式完全取决于具体的形状。</span><span class="sxs-lookup"><span data-stu-id="5c400-308">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="5c400-309">例如，圆和三角形的周长计算公式就迥然不同。</span><span class="sxs-lookup"><span data-stu-id="5c400-309">The formula for calculating the perimeter (or circumference) of a circle, for example, is very different from that of a triangle.</span></span>

<span data-ttu-id="5c400-310">以下示例定义了 `Shape` 抽象基类，此基类又定义了两个属性：`Area` 和 `Perimeter`。</span><span class="sxs-lookup"><span data-stu-id="5c400-310">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="5c400-311">请注意，除了用 [abstract](../language-reference/keywords/abstract.md) 关键字标记类之外，还需要用 [abstract](../language-reference/keywords/abstract.md) 关键字标记每个实例成员。</span><span class="sxs-lookup"><span data-stu-id="5c400-311">Note that, in addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="5c400-312">在此示例中，`Shape` 还将 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 方法重写为返回类型的名称，而不是其完全限定的名称。</span><span class="sxs-lookup"><span data-stu-id="5c400-312">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="5c400-313">基类还定义了两个静态成员（`GetArea` 和 `GetPerimeter`），以便调用方可以轻松检索任何派生类实例的面积和周长。</span><span class="sxs-lookup"><span data-stu-id="5c400-313">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="5c400-314">将派生类实例传递给两个方法中的任意一个时，运行时调用的是派生类重写的方法。</span><span class="sxs-lookup"><span data-stu-id="5c400-314">When we pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="5c400-315">然后，我们可以从表示特定形状的 `Shape` 派生一些类。</span><span class="sxs-lookup"><span data-stu-id="5c400-315">We can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="5c400-316">以下示例定义了三个类：`Triangle`、`Rectangle` 和 `Circle`。</span><span class="sxs-lookup"><span data-stu-id="5c400-316">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="5c400-317">每个类都使用特定形状的专属公式来计算面积和周长。</span><span class="sxs-lookup"><span data-stu-id="5c400-317">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="5c400-318">一些派生类还定义所表示形状的专属属性（如 `Rectangle.Diagonal` 和 `Circle.Diameter`）。</span><span class="sxs-lookup"><span data-stu-id="5c400-318">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="5c400-319">以下示例使用派生自 `Shape` 的对象。</span><span class="sxs-lookup"><span data-stu-id="5c400-319">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="5c400-320">它实例化派生自 `Shape` 的一组对象，然后调用 `Shape` 类的静态方法，用于包装返回的 `Shape` 属性值。</span><span class="sxs-lookup"><span data-stu-id="5c400-320">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="5c400-321">请注意，运行时从派生类型的重写属性检索值。</span><span class="sxs-lookup"><span data-stu-id="5c400-321">Note that the runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="5c400-322">以下示例还将数组中的每个 `Shape` 对象显式转换成其派生类型；如果显式转换成功，则检索 `Shape` 的特定子类的属性。</span><span class="sxs-lookup"><span data-stu-id="5c400-322">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span> 

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="5c400-323">请参阅</span><span class="sxs-lookup"><span data-stu-id="5c400-323">See also</span></span>

<span data-ttu-id="5c400-324">[类和对象](../tour-of-csharp/classes-and-objects.md) </span><span class="sxs-lookup"><span data-stu-id="5c400-324">[Classes and objects](../tour-of-csharp/classes-and-objects.md) </span></span>  
[<span data-ttu-id="5c400-325">继承（C# 编程指南）</span><span class="sxs-lookup"><span data-stu-id="5c400-325">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
