---
title: "使用客户端访问服务"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
ms.assetid: c8329832-bf66-4064-9034-bf39f153fc2d
caps.latest.revision: "15"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 180367920eb6f900fbb6b234b94f3b3a2c7fe52f
ms.sourcegitcommit: ce279f2d7fe2220e6ea0a25a8a7a5370ddf8d9f0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/02/2017
---
# <a name="accessing-services-using-a-client"></a><span data-ttu-id="58d17-102">使用客户端访问服务</span><span class="sxs-lookup"><span data-stu-id="58d17-102">Accessing Services Using a Client</span></span>
<span data-ttu-id="58d17-103">客户端应用程序必须创建、配置和使用 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 客户端或通道对象，以便与服务进行通信。</span><span class="sxs-lookup"><span data-stu-id="58d17-103">Client applications must create, configure, and use [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] client or channel objects to communicate with services.</span></span> <span data-ttu-id="58d17-104">[WCF 客户端概述](../../../../docs/framework/wcf/wcf-client-overview.md)主题提供的对象和创建基本的客户端和通道对象和使用它们所涉及的步骤概述。</span><span class="sxs-lookup"><span data-stu-id="58d17-104">The [WCF Client Overview](../../../../docs/framework/wcf/wcf-client-overview.md) topic provides an overview of the objects and steps involved in creating basic client and channel objects and using them.</span></span>  
  
 <span data-ttu-id="58d17-105">本主题提供有关某些客户端应用程序问题以及客户端和通道对象问题的详细信息，根据方案的具体情况，这些信息可能会有用处。</span><span class="sxs-lookup"><span data-stu-id="58d17-105">This topic provides in-depth information about some of the issues with client applications and client and channel objects that may be useful depending upon your scenario.</span></span>  
  
## <a name="overview"></a><span data-ttu-id="58d17-106">概述</span><span class="sxs-lookup"><span data-stu-id="58d17-106">Overview</span></span>  
 <span data-ttu-id="58d17-107">本主题描述与以下内容相关的行为和问题：</span><span class="sxs-lookup"><span data-stu-id="58d17-107">This topic describes behavior and issues relating to:</span></span>  
  
-   <span data-ttu-id="58d17-108">通道和会话生存期。</span><span class="sxs-lookup"><span data-stu-id="58d17-108">Channel and session lifetimes.</span></span>  
  
-   <span data-ttu-id="58d17-109">处理异常。</span><span class="sxs-lookup"><span data-stu-id="58d17-109">Handling exceptions.</span></span>  
  
-   <span data-ttu-id="58d17-110">了解阻塞问题。</span><span class="sxs-lookup"><span data-stu-id="58d17-110">Understanding blocking issues.</span></span>  
  
-   <span data-ttu-id="58d17-111">以交互方式初始化通道。</span><span class="sxs-lookup"><span data-stu-id="58d17-111">Initializing channels interactively.</span></span>  
  
### <a name="channel-and-session-lifetimes"></a><span data-ttu-id="58d17-112">通道和会话生存期</span><span class="sxs-lookup"><span data-stu-id="58d17-112">Channel and Session Lifetimes</span></span>  
 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]<span data-ttu-id="58d17-113"> 应用程序包含两个类别的通道：数据报通道和会话通道。</span><span class="sxs-lookup"><span data-stu-id="58d17-113"> applications includes two categories of channels, datagram and sessionful.</span></span>  
  
 <span data-ttu-id="58d17-114">A*数据报*通道是在其中所有消息都是不相关的通道。</span><span class="sxs-lookup"><span data-stu-id="58d17-114">A *datagram* channel is a channel in which all messages are uncorrelated.</span></span> <span data-ttu-id="58d17-115">使用数据报通道时，如果输入或输出操作失败，下一个操作通常不会受到影响，并且同一个通道可以重用。</span><span class="sxs-lookup"><span data-stu-id="58d17-115">With a datagram channel, if an input or output operation fails, the next operation is typically unaffected, and the same channel can be reused.</span></span> <span data-ttu-id="58d17-116">因此，数据报通道通常不会出错。</span><span class="sxs-lookup"><span data-stu-id="58d17-116">Because of this, datagram channels typically do not fault.</span></span>  
  
 <span data-ttu-id="58d17-117">*会话*通道，但是，是与另一个终结点的连接的通道。</span><span class="sxs-lookup"><span data-stu-id="58d17-117">*Sessionful* channels, however, are channels with a connection to the other endpoint.</span></span> <span data-ttu-id="58d17-118">某一端会话中的消息总是与另一端的同一会话相关联。</span><span class="sxs-lookup"><span data-stu-id="58d17-118">Messages in a session on one side are always correlated with the same session on the other side.</span></span> <span data-ttu-id="58d17-119">另外，会话的两个参与者必须商定，只有彼此的对话要求得到满足，才能认为该会话是成功的。</span><span class="sxs-lookup"><span data-stu-id="58d17-119">In addition, both participants in a session must agree that the requirements of their conversation were met for that session to be considered successful.</span></span> <span data-ttu-id="58d17-120">如果他们无法商定，则会话通道可能会出错。</span><span class="sxs-lookup"><span data-stu-id="58d17-120">If they cannot agree, the sessionful channel may fault.</span></span>  
  
 <span data-ttu-id="58d17-121">通过调用第一个操作显式或隐式打开客户端。</span><span class="sxs-lookup"><span data-stu-id="58d17-121">Open clients explicitly or implicitly by calling the first operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58d17-122">试图显式检测出错的会话通道通常是没有用处的，因为您何时得到通知取决于会话实现。</span><span class="sxs-lookup"><span data-stu-id="58d17-122">Trying to explicitly detect faulted sessionful channels is not typically useful, because when you are notified depends upon the session implementation.</span></span> <span data-ttu-id="58d17-123">例如，因为 <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType>（禁用了可靠会话）表现了 TCP 连接会话的状态，所以，如果您在服务或客户端上侦听 <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> 事件，则在出现网络故障时，您可能会很快得到通知。</span><span class="sxs-lookup"><span data-stu-id="58d17-123">For example, because the <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> event on the service or the client you are likely to be notified quickly in the event of a network failure.</span></span> <span data-ttu-id="58d17-124">但是，可靠会话（由启用了 <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> 的绑定建立）旨在防止服务受到小型网络故障的影响。</span><span class="sxs-lookup"><span data-stu-id="58d17-124">But reliable sessions (established by bindings in which the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> is enabled) are designed to insulate services from small network failures.</span></span> <span data-ttu-id="58d17-125">如果可以在一段合理的时间内重新建立会话，则同一绑定（为可靠会话而配置）可能不会出错，除非中断持续了一段较长的时间。</span><span class="sxs-lookup"><span data-stu-id="58d17-125">If the session can be reestablished within a reasonable period of time, the same binding—configured for reliable sessions—might not fault until the interruption continued for a longer period of time.</span></span>  
  
 <span data-ttu-id="58d17-126">默认情况下，大多数由系统提供的绑定（它们向应用程序层公开通道）都使用会话，但 <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> 不使用会话。</span><span class="sxs-lookup"><span data-stu-id="58d17-126">Most of the system-provided bindings (which expose channels to the application layer) use sessions by default, but the <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> does not.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="58d17-127">[使用会话](../../../../docs/framework/wcf/using-sessions.md)。</span><span class="sxs-lookup"><span data-stu-id="58d17-127"> [Using Sessions](../../../../docs/framework/wcf/using-sessions.md).</span></span>  
  
### <a name="the-proper-use-of-sessions"></a><span data-ttu-id="58d17-128">正确使用会话</span><span class="sxs-lookup"><span data-stu-id="58d17-128">The Proper Use of Sessions</span></span>  
 <span data-ttu-id="58d17-129">会话提供了一种了解整个消息交换是否已完成以及会话双方是否都认为交换成功的方式。</span><span class="sxs-lookup"><span data-stu-id="58d17-129">Sessions provide a way to know if the entire message exchange is complete, and if both sides considered it successful.</span></span> <span data-ttu-id="58d17-130">建议让调用应用程序在一个 try 块内打开、使用和关闭通道。</span><span class="sxs-lookup"><span data-stu-id="58d17-130">It is recommended that a calling application open the channel, use it, and close the channel inside one try block.</span></span> <span data-ttu-id="58d17-131">如果会话通道打开，然后调用了一次 <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> 方法，并且该调用成功返回，则会话是成功的。</span><span class="sxs-lookup"><span data-stu-id="58d17-131">If a session channel is open, and the <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> method is called once, and that call returns successfully, then the session was successful.</span></span> <span data-ttu-id="58d17-132">在此情况下，成功意味着绑定所指定的所有传递保证都得到满足，并且另一方在调用 <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> 之前没有对通道调用 <xref:System.ServiceModel.ICommunicationObject.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="58d17-132">Successful in this case means that all delivery guarantees the binding specified were met, and the other side did not call <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> on the channel before calling <xref:System.ServiceModel.ICommunicationObject.Close%2A>.</span></span>  
  
 <span data-ttu-id="58d17-133">下一节提供了此客户端方法的一个示例。</span><span class="sxs-lookup"><span data-stu-id="58d17-133">The following section provides an example of this client approach.</span></span>  
  
### <a name="handling-exceptions"></a><span data-ttu-id="58d17-134">处理异常</span><span class="sxs-lookup"><span data-stu-id="58d17-134">Handling Exceptions</span></span>  
 <span data-ttu-id="58d17-135">在客户端应用程序中处理异常是非常简单的。</span><span class="sxs-lookup"><span data-stu-id="58d17-135">Handling exceptions in client applications is straightforward.</span></span> <span data-ttu-id="58d17-136">如果在一个 try 块内打开、使用并关闭通道，则除非引发了异常，否则对话都是成功的。</span><span class="sxs-lookup"><span data-stu-id="58d17-136">If a channel is opened, used, and closed inside a try block, then the conversation has succeeded, unless an exception is thrown.</span></span> <span data-ttu-id="58d17-137">通常情况下，如果引发了异常，则会中止对话。</span><span class="sxs-lookup"><span data-stu-id="58d17-137">Typically, if an exception is thrown the conversation is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58d17-138">建议不要使用 `using` 语句（在 `Using` 中为 [!INCLUDE[vbprvb](../../../../includes/vbprvb-md.md)]）。</span><span class="sxs-lookup"><span data-stu-id="58d17-138">Use of the `using` statement (`Using` in [!INCLUDE[vbprvb](../../../../includes/vbprvb-md.md)]) is not recommended.</span></span> <span data-ttu-id="58d17-139">这是因为 `using` 语句的末尾会引发异常，这些异常会屏蔽您可能需要了解的其他异常。</span><span class="sxs-lookup"><span data-stu-id="58d17-139">This is because the end of the `using` statement can cause exceptions that can mask other exceptions you may need to know about.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="58d17-140">[避免出现与 Using 语句问题](../../../../docs/framework/wcf/samples/avoiding-problems-with-the-using-statement.md)。</span><span class="sxs-lookup"><span data-stu-id="58d17-140"> [Avoiding Problems with the Using Statement](../../../../docs/framework/wcf/samples/avoiding-problems-with-the-using-statement.md).</span></span>  
  
 <span data-ttu-id="58d17-141">下面的代码示例演示使用 try/catch 块而不是 `using` 语句的推荐客户端模式。</span><span class="sxs-lookup"><span data-stu-id="58d17-141">The following code example shows the recommended client pattern using a try/catch block and not the `using` statement.</span></span>  
  
 [!code-csharp[FaultContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
 [!code-vb[FaultContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]  
  
> [!NOTE]
>  <span data-ttu-id="58d17-142">检查 <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> 属性的值是一个争用条件，建议不要使用此检查来确定是重用还是关闭通道。</span><span class="sxs-lookup"><span data-stu-id="58d17-142">Checking the value of the <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> property is a race condition and is not recommended to determine whether to reuse or close a channel.</span></span>  
  
 <span data-ttu-id="58d17-143">即使在关闭数据报通道时出现异常，这些通道也从来不会出错。</span><span class="sxs-lookup"><span data-stu-id="58d17-143">Datagram channels never fault even if exceptions occur when they are closed.</span></span> <span data-ttu-id="58d17-144">另外，使用安全对话但未能通过身份验证的非双工客户端通常会引发 <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="58d17-144">In addition, non-duplex clients that fail to authenticate using a secure conversation typically throw a <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58d17-145">但是，与此不同的是，如果使用安全对话的双工客户端未能通过身份验证，该客户端会收到 <xref:System.TimeoutException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="58d17-145">However if the duplex client using a secure conversation fails to authenticate, the client receives a <xref:System.TimeoutException?displayProperty=nameWithType> instead.</span></span>  
  
 <span data-ttu-id="58d17-146">有关使用应用程序级别的错误信息的更完整信息，请参阅[指定和处理在协定和服务中的错误](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)。</span><span class="sxs-lookup"><span data-stu-id="58d17-146">For more complete information about working with error information at the application level, see [Specifying and Handling Faults in Contracts and Services](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).</span></span> <span data-ttu-id="58d17-147">[预期异常](../../../../docs/framework/wcf/samples/expected-exceptions.md)描述预期的异常，并显示如何处理它们。</span><span class="sxs-lookup"><span data-stu-id="58d17-147">[Expected Exceptions](../../../../docs/framework/wcf/samples/expected-exceptions.md) describes expected exceptions and shows how to handle them.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="58d17-148">如何在开发通道时处理错误，请参阅[处理异常和错误](../../../../docs/framework/wcf/extending/handling-exceptions-and-faults.md)。</span><span class="sxs-lookup"><span data-stu-id="58d17-148"> how to handle errors when developing channels, see [Handling Exceptions and Faults](../../../../docs/framework/wcf/extending/handling-exceptions-and-faults.md).</span></span>  
  
### <a name="client-blocking-and-performance"></a><span data-ttu-id="58d17-149">客户端阻塞和性能</span><span class="sxs-lookup"><span data-stu-id="58d17-149">Client Blocking and Performance</span></span>  
 <span data-ttu-id="58d17-150">当应用程序同步调用请求-答复操作时，客户端会阻塞，直到接收到返回值或引发异常（例如 <xref:System.TimeoutException?displayProperty=nameWithType>）为止。</span><span class="sxs-lookup"><span data-stu-id="58d17-150">When an application synchronously calls a request-reply operation, the client blocks until a return value is received or an exception (such as a <xref:System.TimeoutException?displayProperty=nameWithType>) is thrown.</span></span> <span data-ttu-id="58d17-151">此行为与本地行为类似。</span><span class="sxs-lookup"><span data-stu-id="58d17-151">This behavior is similar to local behavior.</span></span> <span data-ttu-id="58d17-152">当应用程序同步调用 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 客户端对象或通道上的操作时，客户端将直到通道层可以向网络写入数据或引发异常时才返回。</span><span class="sxs-lookup"><span data-stu-id="58d17-152">When an application synchronously invokes an operation on a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] client object or channel, the client does not return until the channel layer can write the data to the network or until an exception is thrown.</span></span> <span data-ttu-id="58d17-153">虽然单向消息交换模式（通过标记操作来指定，即将 <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> 设置为 `true`）可以使某些客户端更快做出响应，但是根据绑定和已经发送的消息的性质，单向操作也可能阻塞。</span><span class="sxs-lookup"><span data-stu-id="58d17-153">And while the one-way message exchange pattern (specified by marking an operation with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> set to `true`) can make some clients more responsive, one-way operations can also block, depending upon the binding and what messages have already been sent.</span></span> <span data-ttu-id="58d17-154">单向操作仅与消息交换有关。</span><span class="sxs-lookup"><span data-stu-id="58d17-154">One-way operations are only about the message exchange, no more and no less.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="58d17-155">[的单向服务](../../../../docs/framework/wcf/feature-details/one-way-services.md)。</span><span class="sxs-lookup"><span data-stu-id="58d17-155"> [One-Way Services](../../../../docs/framework/wcf/feature-details/one-way-services.md).</span></span>  
  
 <span data-ttu-id="58d17-156">无论使用何种消息交换模式，大的数据块都会降低客户端的处理速度。</span><span class="sxs-lookup"><span data-stu-id="58d17-156">Large data chunks can slow client processing no matter what the message exchange pattern.</span></span> <span data-ttu-id="58d17-157">若要了解如何处理这些问题，请参阅[大型数据和流式处理](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)。</span><span class="sxs-lookup"><span data-stu-id="58d17-157">To understand how to handle these issues, see [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="58d17-158">如果应用程序在操作完成过程中必须做更多的工作，则应在 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 客户端实现的服务协定接口上创建一个异步方法对。</span><span class="sxs-lookup"><span data-stu-id="58d17-158">If your application must do more work while an operation completes, you should create an asynchronous method pair on the service contract interface that your [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] client implements.</span></span> <span data-ttu-id="58d17-159">若要执行此操作的最简单方法是使用`/async`切换[ServiceModel 元数据实用工具 (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)。</span><span class="sxs-lookup"><span data-stu-id="58d17-159">The easiest way to do this is to use the `/async` switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="58d17-160">有关示例，请参阅[如何： 以异步方式调用服务操作](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)。</span><span class="sxs-lookup"><span data-stu-id="58d17-160">For an example, see [How to: Call Service Operations Asynchronously](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md).</span></span>  
  
 [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="58d17-161">增加客户端性能，请参阅[中间层客户端应用程序](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md)。</span><span class="sxs-lookup"><span data-stu-id="58d17-161"> increasing client performance, see [Middle-Tier Client Applications](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md).</span></span>  
  
### <a name="enabling-the-user-to-select-credentials-dynamically"></a><span data-ttu-id="58d17-162">使用户可以动态选择凭据</span><span class="sxs-lookup"><span data-stu-id="58d17-162">Enabling the User to Select Credentials Dynamically</span></span>  
 <span data-ttu-id="58d17-163"><xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> 接口使应用程序可以显示一个用户界面，用户可以使用该界面选择凭据，以便用来在超时计时器启动之前创建通道。</span><span class="sxs-lookup"><span data-stu-id="58d17-163">The <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> interface enables applications to display a user interface that enables the user to choose credentials with which a channel is created before the timeout timers start.</span></span>  
  
 <span data-ttu-id="58d17-164">应用程序开发人员可以通过两种方式利用一个插入的 <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer>。</span><span class="sxs-lookup"><span data-stu-id="58d17-164">Application developers can make use of an inserted <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> in two ways.</span></span> <span data-ttu-id="58d17-165">客户端应用程序可以调用<xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType>或<xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType>（或异步版本） 在打开通道之前 (*显式*方法) 或调用的第一个操作 (*隐式*方法)。</span><span class="sxs-lookup"><span data-stu-id="58d17-165">The client application can call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version) prior to opening the channel (the *explicit* approach) or call the first operation (the *implicit* approach).</span></span>  
  
 <span data-ttu-id="58d17-166">如果使用隐式方法，则应用程序必须调用 <xref:System.ServiceModel.ClientBase%601> 或 <xref:System.ServiceModel.IClientChannel> 扩展上的第一个操作。</span><span class="sxs-lookup"><span data-stu-id="58d17-166">If using the implicit approach, the application must call the first operation on a <xref:System.ServiceModel.ClientBase%601> or <xref:System.ServiceModel.IClientChannel> extension.</span></span> <span data-ttu-id="58d17-167">如果它调用除第一个操作以外的任何操作，则将引发异常。</span><span class="sxs-lookup"><span data-stu-id="58d17-167">If it calls anything other than the first operation, an exception is thrown.</span></span>  
  
 <span data-ttu-id="58d17-168">如果使用显式方法，应用程序必须按顺序执行下面的操作：</span><span class="sxs-lookup"><span data-stu-id="58d17-168">If using the explicit approach, the application must perform the following steps in order:</span></span>  
  
1.  <span data-ttu-id="58d17-169">调用 <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> 或 <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType>（或异步版本）。</span><span class="sxs-lookup"><span data-stu-id="58d17-169">Call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version).</span></span>  
  
2.  <span data-ttu-id="58d17-170">当初始值设定项已返回时，针对 <xref:System.ServiceModel.ICommunicationObject.Open%2A> 对象或从 <xref:System.ServiceModel.IClientChannel> 属性返回的 <xref:System.ServiceModel.IClientChannel> 对象来调用 <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="58d17-170">When the initializers have returned, call either the <xref:System.ServiceModel.ICommunicationObject.Open%2A> method on the <xref:System.ServiceModel.IClientChannel> object or on the <xref:System.ServiceModel.IClientChannel> object returned from the <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> property.</span></span>  
  
3.  <span data-ttu-id="58d17-171">调用操作。</span><span class="sxs-lookup"><span data-stu-id="58d17-171">Call operations.</span></span>  
  
 <span data-ttu-id="58d17-172">建议通过采用显式方法，由可投入实际生产运行的应用程序来控制用户界面过程。</span><span class="sxs-lookup"><span data-stu-id="58d17-172">It is recommended that production-quality applications control the user-interface process by adopting the explicit approach.</span></span>  
  
 <span data-ttu-id="58d17-173">使用隐式方法的应用程序调用用户界面初始值设定项，但是如果应用程序的用户没有在绑定的发送超时期限内做出响应，则当用户界面返回时，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="58d17-173">Applications that use the implicit approach invoke the user-interface initializers, but if the user of the application fails to respond within the send timeout period of the binding, an exception is thrown when the user interface returns.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="58d17-174">另请参阅</span><span class="sxs-lookup"><span data-stu-id="58d17-174">See Also</span></span>  
 [<span data-ttu-id="58d17-175">双工服务</span><span class="sxs-lookup"><span data-stu-id="58d17-175">Duplex Services</span></span>](../../../../docs/framework/wcf/feature-details/duplex-services.md)  
 [<span data-ttu-id="58d17-176">如何： 访问服务使用单向和请求-答复协定</span><span class="sxs-lookup"><span data-stu-id="58d17-176">How to: Access Services with One-Way and Request-Reply Contracts</span></span>](../../../../docs/framework/wcf/feature-details/how-to-access-wcf-services-with-one-way-and-request-reply-contracts.md)  
 [<span data-ttu-id="58d17-177">如何： 使用双工协定访问服务</span><span class="sxs-lookup"><span data-stu-id="58d17-177">How to: Access Services with a Duplex Contract</span></span>](../../../../docs/framework/wcf/feature-details/how-to-access-services-with-a-duplex-contract.md)  
 [<span data-ttu-id="58d17-178">如何： 访问 WSE 3.0 服务</span><span class="sxs-lookup"><span data-stu-id="58d17-178">How to: Access a WSE 3.0 Service</span></span>](../../../../docs/framework/wcf/feature-details/how-to-access-a-wse-3-0-service-with-a-wcf-client.md)  
 [<span data-ttu-id="58d17-179">如何： 使用 ChannelFactory</span><span class="sxs-lookup"><span data-stu-id="58d17-179">How to: Use the ChannelFactory</span></span>](../../../../docs/framework/wcf/feature-details/how-to-use-the-channelfactory.md)  
 [<span data-ttu-id="58d17-180">如何： 以异步方式调用服务操作</span><span class="sxs-lookup"><span data-stu-id="58d17-180">How to: Call Service Operations Asynchronously</span></span>](../../../../docs/framework/wcf/feature-details/how-to-call-wcf-service-operations-asynchronously.md)  
 [<span data-ttu-id="58d17-181">中间层客户端应用程序</span><span class="sxs-lookup"><span data-stu-id="58d17-181">Middle-Tier Client Applications</span></span>](../../../../docs/framework/wcf/feature-details/middle-tier-client-applications.md)
