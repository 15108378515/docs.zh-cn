---
title: WPF 中的代码隐藏和 XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], code-behind
- code-behind files [WPF], XAML
ms.assetid: 9df6d3c9-aed3-471c-af36-6859b19d999f
ms.openlocfilehash: 09d4f010ca53c5e3d2d9dede172e7ae2102261b9
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/04/2018
ms.locfileid: "33541543"
---
# <a name="code-behind-and-xaml-in-wpf"></a><span data-ttu-id="8b4fe-102">WPF 中的代码隐藏和 XAML</span><span class="sxs-lookup"><span data-stu-id="8b4fe-102">Code-Behind and XAML in WPF</span></span>
<a name="introduction"></a> <span data-ttu-id="8b4fe-103">代码隐藏是一个术语用于描述与采用标记定义的对象联接的代码时[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]页进行标记编译。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-103">Code-behind is a term used to describe the code that is joined with markup-defined objects, when a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] page is markup-compiled.</span></span> <span data-ttu-id="8b4fe-104">本主题介绍隐藏代码的要求以及中的代码的可选内联代码机制[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-104">This topic describes requirements for code-behind as well as an alternative inline code mechanism for code in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="8b4fe-105">本主题包含以下各节：</span><span class="sxs-lookup"><span data-stu-id="8b4fe-105">This topic contains the following sections:</span></span>  
  
-   [<span data-ttu-id="8b4fe-106">先决条件</span><span class="sxs-lookup"><span data-stu-id="8b4fe-106">Prerequisites</span></span>](#Prerequisites)  
  
-   [<span data-ttu-id="8b4fe-107">代码隐藏和 XAML 语言</span><span class="sxs-lookup"><span data-stu-id="8b4fe-107">Code-Behind and the XAML Language</span></span>](#codebehind_and_the_xaml_language)  
  
-   [<span data-ttu-id="8b4fe-108">代码隐藏、 事件处理程序和 WPF 中的分部类要求</span><span class="sxs-lookup"><span data-stu-id="8b4fe-108">Code-behind, Event Handler, and Partial Class Requirements in WPF</span></span>](#Code_behind__Event_Handler__and_Partial_Class)  
  
-   [<span data-ttu-id="8b4fe-109">x： 代码</span><span class="sxs-lookup"><span data-stu-id="8b4fe-109">x:Code</span></span>](#x_Code)  
  
-   [<span data-ttu-id="8b4fe-110">内联代码限制</span><span class="sxs-lookup"><span data-stu-id="8b4fe-110">Inline Code Limitations</span></span>](#Inline_Code_Limitations)  
  
<a name="Prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="8b4fe-111">系统必备</span><span class="sxs-lookup"><span data-stu-id="8b4fe-111">Prerequisites</span></span>  
 <span data-ttu-id="8b4fe-112">本主题假定你已阅读[XAML 概述 (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)及具有一些基本知识的[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]和面向对象的编程。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-112">This topic assumes that you have read the [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md) and have some basic knowledge of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] and object-oriented programming.</span></span>  
  
<a name="codebehind_and_the_xaml_language"></a>   
## <a name="code-behind-and-the-xaml-language"></a><span data-ttu-id="8b4fe-113">代码隐藏和 XAML 语言</span><span class="sxs-lookup"><span data-stu-id="8b4fe-113">Code-Behind and the XAML Language</span></span>  
 <span data-ttu-id="8b4fe-114">XAML 语言包括语言级别功能，使它可以将代码文件与标记文件，从标记文件端相关联。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-114">The XAML language includes language-level features that make it possible to associate code files with markup files, from the markup file side.</span></span> <span data-ttu-id="8b4fe-115">具体而言，XAML 语言定义的语言功能[X:class 指令](../../../../docs/framework/xaml-services/x-class-directive.md)， [X:subclass 指令](../../../../docs/framework/xaml-services/x-subclass-directive.md)，和[X:classmodifier 指令](../../../../docs/framework/xaml-services/x-classmodifier-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-115">Specifically, the XAML language defines the language features [x:Class Directive](../../../../docs/framework/xaml-services/x-class-directive.md), [x:Subclass Directive](../../../../docs/framework/xaml-services/x-subclass-directive.md), and [x:ClassModifier Directive](../../../../docs/framework/xaml-services/x-classmodifier-directive.md).</span></span> <span data-ttu-id="8b4fe-116">完全应生成代码的方式，以及如何将标记和代码，进行不是 XAML 语言指定的一部分。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-116">Exactly how the code should be produced, and how to integrate markup and code, is not part of what the XAML language specifies.</span></span> <span data-ttu-id="8b4fe-117">它处于框架，例如 WPF 来确定如何将代码集成到，如何使用 XAML 在应用程序的编程模型和生成操作或其他支持的所有这些要求。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-117">It is left up to frameworks such as WPF to determine how to integrate the code, how to use XAML in the application and programming models, and the build actions or other support that all this requires.</span></span>  
  
<a name="Code_behind__Event_Handler__and_Partial_Class"></a>   
## <a name="code-behind-event-handler-and-partial-class-requirements-in-wpf"></a><span data-ttu-id="8b4fe-118">代码隐藏、 事件处理程序和 WPF 中的分部类要求</span><span class="sxs-lookup"><span data-stu-id="8b4fe-118">Code-behind, Event Handler, and Partial Class Requirements in WPF</span></span>  
  
-   <span data-ttu-id="8b4fe-119">分部类必须派生自支持的根元素的类型。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-119">The partial class must derive from the type that backs the root element.</span></span>  
  
-   <span data-ttu-id="8b4fe-120">请注意下的标记编译生成操作的默认行为，你可以将派生留空的分部类定义中的代码隐藏端。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-120">Note that under the default behavior of the markup compile build actions, you can leave the derivation blank in the partial class definition on the code-behind side.</span></span> <span data-ttu-id="8b4fe-121">编译的结果将假定页面根的后备类型是分部类中，作为基础，即使未指定。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-121">The compiled result will assume the page root's backing type to be the basis for the partial class, even if it not specified.</span></span> <span data-ttu-id="8b4fe-122">但是，依赖于此行为不是一种最佳做法。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-122">However, relying on this behavior is not a best practice.</span></span>  
  
-   <span data-ttu-id="8b4fe-123">在后面的代码中编写的事件处理程序必须是实例方法，并且不能为静态方法。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-123">The event handlers you write in the code behind must be instance methods and cannot be static methods.</span></span> <span data-ttu-id="8b4fe-124">这些方法必须由标识的 CLR 命名空间中的分部类定义`x:Class`。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-124">These methods must be defined by the partial class within the CLR namespace identified by `x:Class`.</span></span> <span data-ttu-id="8b4fe-125">您不能限定事件处理程序，以指示名称[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]处理器的事件处理程序事件布线，另一个类作用域中查找。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-125">You cannot qualify the name of an event handler to instruct a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor to look for an event handler for event wiring in a different class scope.</span></span>  
  
-   <span data-ttu-id="8b4fe-126">处理程序必须在后备类型系统中匹配相应的事件的委托。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-126">The handler must match the delegate for the appropriate event in the backing type system.</span></span>  
  
-   <span data-ttu-id="8b4fe-127">对于 Microsoft Visual Basic 语言具体而言，你使用的是特定于语言的`Handles`关键字将与实例和处理程序声明，而不是附加处理程序中的属性中的事件的处理程序[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-127">For the Microsoft Visual Basic language specifically, you can use the language-specific `Handles` keyword to associate handlers with instances and events in the handler declaration, instead of attaching handlers with attributes in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="8b4fe-128">但是，此技术也存在一些限制，因为`Handles`关键字不能支持所有的特定功能[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]事件系统，如某些路由事件方案或附加事件。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-128">However, this technique does have some limitations because the `Handles` keyword cannot support all of the specific features of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system, such as certain routed event scenarios or attached events.</span></span> <span data-ttu-id="8b4fe-129">有关详细信息，请参阅[Visual Basic 和 WPF 的事件处理](../../../../docs/framework/wpf/advanced/visual-basic-and-wpf-event-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-129">For details, see [Visual Basic and WPF Event Handling](../../../../docs/framework/wpf/advanced/visual-basic-and-wpf-event-handling.md).</span></span>  
  
<a name="x_Code"></a>   
## <a name="xcode"></a><span data-ttu-id="8b4fe-130">x： 代码</span><span class="sxs-lookup"><span data-stu-id="8b4fe-130">x:Code</span></span>  
 <span data-ttu-id="8b4fe-131">[X:code](../../../../docs/framework/xaml-services/x-code-intrinsic-xaml-type.md)中定义的指令元素[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-131">[x:Code](../../../../docs/framework/xaml-services/x-code-intrinsic-xaml-type.md) is a directive element defined in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="8b4fe-132">`x:Code`指令元素可以包含内联编程代码。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-132">An `x:Code` directive element can contain inline programming code.</span></span> <span data-ttu-id="8b4fe-133">以内联方式定义的代码可以与进行交互[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]同一页面上。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-133">The code that is defined inline can interact with the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] on the same page.</span></span> <span data-ttu-id="8b4fe-134">下面的示例阐释了内联 C# 代码。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-134">The following example illustrates inline C# code.</span></span> <span data-ttu-id="8b4fe-135">请注意，代码是内部`x:Code`元素和代码必须用引起`<CDATA[`...`]]>`进行转义的内容[!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)]，以便[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]处理器 (解释[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]架构或[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]架构) 不会尝试解释内容按原义作为[!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-135">Notice that the code is inside the `x:Code` element and that the code must be surrounded by `<CDATA[`...`]]>` to escape the contents for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)], so that a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor (interpreting either the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] schema or the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] schema) will not try to interpret the contents literally as [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)].</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ButtonWithInlineCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page4.xaml#buttonwithinlinecode)]  
  
<a name="Inline_Code_Limitations"></a>   
## <a name="inline-code-limitations"></a><span data-ttu-id="8b4fe-136">内联代码限制</span><span class="sxs-lookup"><span data-stu-id="8b4fe-136">Inline Code Limitations</span></span>  
 <span data-ttu-id="8b4fe-137">你应考虑避免或限制使用内联代码。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-137">You should consider avoiding or limiting the use of inline code.</span></span> <span data-ttu-id="8b4fe-138">在体系结构和编码原理，方面维护标记和代码隐藏之间的分隔保留设计器和开发人员角色得更为明显。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-138">In terms of architecture and coding philosophy, maintaining a separation between markup and code-behind keeps the designer and developer roles much more distinct.</span></span> <span data-ttu-id="8b4fe-139">在更多技术级，为内联代码编写的代码可能难以编写，因为始终写入[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]生成分部类中，并且只能使用默认的 XML 命名空间映射。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-139">On a more technical level, the code that you write for inline code can be awkward to write, because you are always writing into the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] generated partial class, and can only use the default XML namespace mappings.</span></span> <span data-ttu-id="8b4fe-140">因为不能添加`using`语句，您必须完全限定的许多[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]所做的调用。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-140">Because you cannot add `using` statements, you must fully qualify many of the [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] calls that you make.</span></span> <span data-ttu-id="8b4fe-141">默认值[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]映射包括大多数而非全部[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]命名空间中存在[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]程序集; 你将需要完全限定的类型和成员的其他 CLR 命名空间中包含的调用。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-141">The default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] mappings include most but not all [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] namespaces that are present in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] assemblies; you will have to fully qualify calls to types and members contained within the other CLR namespaces.</span></span> <span data-ttu-id="8b4fe-142">你还不能定义分部类以外在内联代码中，并且你引用的所有用户代码实体必须都存在作为成员或生成的分部类中的变量。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-142">You also cannot define anything beyond the partial class in the inline code, and all user code entities you reference must exist as a member or variable within the generated partial class.</span></span> <span data-ttu-id="8b4fe-143">其他语言特定编程功能，例如宏或`#ifdef`对全局变量或生成变量，也是可用。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-143">Other language specific programming features, such as macros or `#ifdef` against global variables or build variables, are also not available.</span></span> <span data-ttu-id="8b4fe-144">有关详细信息，请参阅[X:code 内部 XAML 类型](../../../../docs/framework/xaml-services/x-code-intrinsic-xaml-type.md)。</span><span class="sxs-lookup"><span data-stu-id="8b4fe-144">For more information, see [x:Code Intrinsic XAML Type](../../../../docs/framework/xaml-services/x-code-intrinsic-xaml-type.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8b4fe-145">请参阅</span><span class="sxs-lookup"><span data-stu-id="8b4fe-145">See Also</span></span>  
 [<span data-ttu-id="8b4fe-146">XAML 概述 (WPF)</span><span class="sxs-lookup"><span data-stu-id="8b4fe-146">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="8b4fe-147">x:Code 内部 XAML 类型</span><span class="sxs-lookup"><span data-stu-id="8b4fe-147">x:Code Intrinsic XAML Type</span></span>](../../../../docs/framework/xaml-services/x-code-intrinsic-xaml-type.md)  
 [<span data-ttu-id="8b4fe-148">生成 WPF 应用程序</span><span class="sxs-lookup"><span data-stu-id="8b4fe-148">Building a WPF Application</span></span>](../../../../docs/framework/wpf/app-development/building-a-wpf-application-wpf.md)  
 [<span data-ttu-id="8b4fe-149">XAML 语法详述</span><span class="sxs-lookup"><span data-stu-id="8b4fe-149">XAML Syntax In Detail</span></span>](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)
