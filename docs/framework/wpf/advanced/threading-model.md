---
title: "线程处理模型"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
caps.latest.revision: "33"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: f0badceeb9ce085dc68fce2c59ec6c42877f2622
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/22/2017
---
# <a name="threading-model"></a><span data-ttu-id="d7a68-102">线程处理模型</span><span class="sxs-lookup"><span data-stu-id="d7a68-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="d7a68-103"> 旨在帮助开发人员处理复杂的线程处理问题。</span><span class="sxs-lookup"><span data-stu-id="d7a68-103"> is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="d7a68-104">因此，大多数[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]开发人员不需要编写一个接口，使用多个线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="d7a68-105">由于多线程程序既复杂又难以调试，因此当存在单线程解决方案时，应避免使用多线程程序。</span><span class="sxs-lookup"><span data-stu-id="d7a68-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="d7a68-106">无论程度而设计，但是，否[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]framework 曾经将能够为每个排序的问题提供一个单线程的解决方案。</span><span class="sxs-lookup"><span data-stu-id="d7a68-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="d7a68-107">接近，但仍存在其中多个线程来提高的情况下[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]响应能力或应用程序的性能。</span><span class="sxs-lookup"><span data-stu-id="d7a68-107"> comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="d7a68-108">基于上文所述的背景材料，本文对上述情况进行探讨，然后通过对一些低级别的细节进行讨论作出总结。</span><span class="sxs-lookup"><span data-stu-id="d7a68-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  
  

  
> [!NOTE]
>  <span data-ttu-id="d7a68-109">本主题讨论使用线程处理<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>异步调用的方法。</span><span class="sxs-lookup"><span data-stu-id="d7a68-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="d7a68-110">你还可以通过调用进行异步调用<xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>方法，它采用<xref:System.Action>或<xref:System.Func%601>作为参数。</span><span class="sxs-lookup"><span data-stu-id="d7a68-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="d7a68-111"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>方法返回<xref:System.Windows.Threading.DispatcherOperation>或<xref:System.Windows.Threading.DispatcherOperation%601>，它具有<xref:System.Windows.Threading.DispatcherOperation.Task%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="d7a68-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="d7a68-112">你可以使用`await`使用关键字<xref:System.Windows.Threading.DispatcherOperation>或关联<xref:System.Threading.Tasks.Task>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="d7a68-113">如果你需要同步等待<xref:System.Threading.Tasks.Task>返回<xref:System.Windows.Threading.DispatcherOperation>或<xref:System.Windows.Threading.DispatcherOperation%601>，调用<xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A>扩展方法。</span><span class="sxs-lookup"><span data-stu-id="d7a68-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="d7a68-114">调用<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>将导致死锁。</span><span class="sxs-lookup"><span data-stu-id="d7a68-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="d7a68-115">有关使用<xref:System.Threading.Tasks.Task>若要执行异步操作，请参阅任务并行。</span><span class="sxs-lookup"><span data-stu-id="d7a68-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="d7a68-116"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>方法还有采用重载<xref:System.Action>或<xref:System.Func%601>作为参数。</span><span class="sxs-lookup"><span data-stu-id="d7a68-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="d7a68-117">你可以使用<xref:System.Windows.Threading.Dispatcher.Invoke%2A>方法来进行同步调用通过在委托中，传入<xref:System.Action>或<xref:System.Func%601>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="d7a68-118">概述和调度程序</span><span class="sxs-lookup"><span data-stu-id="d7a68-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="d7a68-119">通常情况下，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]两个线程启动的应用程序： 一个用于处理呈现和另一个用于管理[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="d7a68-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="d7a68-120">呈现线程有效地隐藏在后台运行[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程接收输入、 处理事件、 绘制屏幕，并运行应用程序代码。</span><span class="sxs-lookup"><span data-stu-id="d7a68-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="d7a68-121">大多数应用程序使用单个[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程，但在某些情况下也最佳同时使用多个。</span><span class="sxs-lookup"><span data-stu-id="d7a68-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="d7a68-122">我们将稍后通过示例对此进行讨论。</span><span class="sxs-lookup"><span data-stu-id="d7a68-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="d7a68-123">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程队列工作项内对象称为<xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="d7a68-124"><xref:System.Windows.Threading.Dispatcher> 基于优先级选择工作项，并运行每一个工作项直到完成。</span><span class="sxs-lookup"><span data-stu-id="d7a68-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="d7a68-125">每个[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程都必须具有至少一个<xref:System.Windows.Threading.Dispatcher>，和每个<xref:System.Windows.Threading.Dispatcher>可以在恰好一个线程中执行工作项。</span><span class="sxs-lookup"><span data-stu-id="d7a68-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="d7a68-126">为生成响应、 用户友好应用程序的作用在于最大限度地<xref:System.Windows.Threading.Dispatcher>通过将工作项保持小的吞吐量。</span><span class="sxs-lookup"><span data-stu-id="d7a68-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="d7a68-127">这样，工作项永远不会获得陈旧坐在<xref:System.Windows.Threading.Dispatcher>等待处理的队列。</span><span class="sxs-lookup"><span data-stu-id="d7a68-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="d7a68-128">输入和响应间任何可察觉的延迟都会让用户不满。</span><span class="sxs-lookup"><span data-stu-id="d7a68-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="d7a68-129">如何则[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]应用程序应以处理大操作？</span><span class="sxs-lookup"><span data-stu-id="d7a68-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="d7a68-130">如果代码涉及大型计算，或需要查询某些远程服务器上的数据库，应该怎么办？</span><span class="sxs-lookup"><span data-stu-id="d7a68-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="d7a68-131">通常情况下，答案是处理中单独的线程，这样的大操作[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程可以自由地在工作项<xref:System.Windows.Threading.Dispatcher>队列。</span><span class="sxs-lookup"><span data-stu-id="d7a68-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="d7a68-132">完成大操作时，它可以报告其结果返回到[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程以进行显示。</span><span class="sxs-lookup"><span data-stu-id="d7a68-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="d7a68-133">从历史上看，[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]允许[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]只能由创建它们的线程访问的元素。</span><span class="sxs-lookup"><span data-stu-id="d7a68-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="d7a68-134">这意味着，负责长时间运行任务的后台线程无法在任务完成时更新文本框。</span><span class="sxs-lookup"><span data-stu-id="d7a68-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="d7a68-135">这样做是为了确保的完整性[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]组件。</span><span class="sxs-lookup"><span data-stu-id="d7a68-135"> does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="d7a68-136">如果在绘制过程中后台线程更新了列表框的内容，则此列表框看起来可能会很奇怪。</span><span class="sxs-lookup"><span data-stu-id="d7a68-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="d7a68-137"> 具有内置互相排斥机制，此机制能强制执行这种协调。</span><span class="sxs-lookup"><span data-stu-id="d7a68-137"> has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="d7a68-138">中的大多数类[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]派生自<xref:System.Windows.Threading.DispatcherObject>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="d7a68-139">在构造，<xref:System.Windows.Threading.DispatcherObject>存储到的引用<xref:System.Windows.Threading.Dispatcher>链接到当前正在运行的线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="d7a68-140">实际上，<xref:System.Windows.Threading.DispatcherObject>将创建它的线程与相关联。</span><span class="sxs-lookup"><span data-stu-id="d7a68-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="d7a68-141">在程序执行期间<xref:System.Windows.Threading.DispatcherObject>可以调用它的公共<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d7a68-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="d7a68-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>检查<xref:System.Windows.Threading.Dispatcher>与当前线程关联，并将其到<xref:System.Windows.Threading.Dispatcher>构造过程中存储的引用。</span><span class="sxs-lookup"><span data-stu-id="d7a68-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="d7a68-143">如果不匹配，<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>引发异常。</span><span class="sxs-lookup"><span data-stu-id="d7a68-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="d7a68-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>用于进行调用属于每个方法的开头<xref:System.Windows.Threading.DispatcherObject>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="d7a68-145">如果只有一个线程可以修改[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]，如何执行后台线程与用户交互？</span><span class="sxs-lookup"><span data-stu-id="d7a68-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="d7a68-146">后台线程可以要求[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程来执行其代表的操作。</span><span class="sxs-lookup"><span data-stu-id="d7a68-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="d7a68-147">这是通过注册与工作项<xref:System.Windows.Threading.Dispatcher>的[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="d7a68-148"><xref:System.Windows.Threading.Dispatcher>类提供两种方法来注册工作项：<xref:System.Windows.Threading.Dispatcher.Invoke%2A>和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="d7a68-149">这两种方法都计划一个用于执行的委托。</span><span class="sxs-lookup"><span data-stu-id="d7a68-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="d7a68-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>是的同步调用 – 也就是说，它不返回直到[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程实际完成执行委托。</span><span class="sxs-lookup"><span data-stu-id="d7a68-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="d7a68-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是异步的将立即返回。</span><span class="sxs-lookup"><span data-stu-id="d7a68-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="d7a68-152"><xref:System.Windows.Threading.Dispatcher>按优先级别的元素其队列中进行排序。</span><span class="sxs-lookup"><span data-stu-id="d7a68-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="d7a68-153">有可能时添加一个元素到指定的十个级别<xref:System.Windows.Threading.Dispatcher>队列。</span><span class="sxs-lookup"><span data-stu-id="d7a68-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="d7a68-154">在中维护这些优先级<xref:System.Windows.Threading.DispatcherPriority>枚举。</span><span class="sxs-lookup"><span data-stu-id="d7a68-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="d7a68-155">有关详细信息<xref:System.Windows.Threading.DispatcherPriority>在找不到级别[!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)]文档。</span><span class="sxs-lookup"><span data-stu-id="d7a68-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="d7a68-156">实际线程：示例</span><span class="sxs-lookup"><span data-stu-id="d7a68-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="d7a68-157">具有长时间运行计算的单线程应用程序</span><span class="sxs-lookup"><span data-stu-id="d7a68-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="d7a68-158">大多数[!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)]花费大部分其时间处于空闲状态等待在响应用户交互中生成的事件。</span><span class="sxs-lookup"><span data-stu-id="d7a68-158">Most [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="d7a68-159">使用小心编程时，此空闲时间可用建设性，而不会影响的响应能力[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="d7a68-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="d7a68-160">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]线程处理模型不允许输入以中断操作中发生的情况[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="d7a68-161">这意味着你必须确保以返回到<xref:System.Windows.Threading.Dispatcher>定期到挂起的输入的事件，然后进行陈旧的进程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="d7a68-162">请看下面的示例：</span><span class="sxs-lookup"><span data-stu-id="d7a68-162">Consider the following example:</span></span>  
  
 <span data-ttu-id="d7a68-163">![质数屏幕快照](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span><span class="sxs-lookup"><span data-stu-id="d7a68-163">![Prime numbers screen shot](../../../../docs/framework/wpf/advanced/media/threadingprimenumberscreenshot.PNG "ThreadingPrimeNumberScreenShot")</span></span>  
  
 <span data-ttu-id="d7a68-164">这个简单的应用程序从 3 开始向上计数以搜索质数。</span><span class="sxs-lookup"><span data-stu-id="d7a68-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="d7a68-165">当用户单击**启动**按钮，开始执行搜索。</span><span class="sxs-lookup"><span data-stu-id="d7a68-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="d7a68-166">当程序查找到一个质数时，它将根据其发现内容更新用户界面。</span><span class="sxs-lookup"><span data-stu-id="d7a68-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="d7a68-167">用户可随时停止搜索。</span><span class="sxs-lookup"><span data-stu-id="d7a68-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="d7a68-168">尽管十分简单，但对质数的搜索可以永远持续下去，这会带来一些问题。</span><span class="sxs-lookup"><span data-stu-id="d7a68-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="d7a68-169">如果我们处理整个搜索按钮的 click 事件处理程序内，我们从不会赋予[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程一个机会处理其他事件。</span><span class="sxs-lookup"><span data-stu-id="d7a68-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="d7a68-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]将无法响应输入或处理消息。</span><span class="sxs-lookup"><span data-stu-id="d7a68-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="d7a68-171">它将永远不会重绘，也永远不会响应按钮单击。</span><span class="sxs-lookup"><span data-stu-id="d7a68-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="d7a68-172">可以在单独的线程中搜索质数，但这样的话，我们需要处理一些同步问题。</span><span class="sxs-lookup"><span data-stu-id="d7a68-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="d7a68-173">通过单线程方法，可以直接更新列出所找到的最大质数的标签。</span><span class="sxs-lookup"><span data-stu-id="d7a68-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="d7a68-174">如果我们分解成易于管理多个块的计算的任务时，我们可以定期返回到<xref:System.Windows.Threading.Dispatcher>，处理的事件。</span><span class="sxs-lookup"><span data-stu-id="d7a68-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="d7a68-175">我们能否[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]重绘和处理输入的机会。</span><span class="sxs-lookup"><span data-stu-id="d7a68-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="d7a68-176">拆分计算和事件处理之间的处理时间的最好办法是管理计算从<xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="d7a68-177">通过使用<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>方法，我们可以计划中的质数检查的同一队列[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]从中提取事件。</span><span class="sxs-lookup"><span data-stu-id="d7a68-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="d7a68-178">在我们的示例中，一次仅计划一个质数检查。</span><span class="sxs-lookup"><span data-stu-id="d7a68-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="d7a68-179">完成质数检查后，立即计划下一个检查。</span><span class="sxs-lookup"><span data-stu-id="d7a68-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="d7a68-180">此检查之后才继续挂起[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]在处理事件。</span><span class="sxs-lookup"><span data-stu-id="d7a68-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 <span data-ttu-id="d7a68-181">![调度程序队列图](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span><span class="sxs-lookup"><span data-stu-id="d7a68-181">![Dispatcher queue illustration](../../../../docs/framework/wpf/advanced/media/threadingdispatcherqueue.PNG "ThreadingDispatcherQueue")</span></span>  
  
 [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)]<span data-ttu-id="d7a68-182"> 通过此机制完成拼写检查。</span><span class="sxs-lookup"><span data-stu-id="d7a68-182"> accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="d7a68-183">在后台使用的空闲时间执行了拼写检查[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="d7a68-184">我们来看一看代码。</span><span class="sxs-lookup"><span data-stu-id="d7a68-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="d7a68-185">下列示例显示了创建用户界面的 XAML。</span><span class="sxs-lookup"><span data-stu-id="d7a68-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="d7a68-186">以下示例显示了代码隐藏。</span><span class="sxs-lookup"><span data-stu-id="d7a68-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="d7a68-187">下面的示例演示的事件处理程序<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="d7a68-188">除了上更新的文本<xref:System.Windows.Controls.Button>，此处理程序是负责计划通过将添加到委托的第一项的质数检查<xref:System.Windows.Threading.Dispatcher>队列。</span><span class="sxs-lookup"><span data-stu-id="d7a68-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="d7a68-189">此事件处理程序完成其工作后, 一段时间内<xref:System.Windows.Threading.Dispatcher>将选择执行此委托。</span><span class="sxs-lookup"><span data-stu-id="d7a68-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="d7a68-190">如前文所述，<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是<xref:System.Windows.Threading.Dispatcher>成员用来安排执行的委托。</span><span class="sxs-lookup"><span data-stu-id="d7a68-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="d7a68-191">在这种情况下，我们选择<xref:System.Windows.Threading.DispatcherPriority.SystemIdle>优先级。</span><span class="sxs-lookup"><span data-stu-id="d7a68-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="d7a68-192"><xref:System.Windows.Threading.Dispatcher>仅当不没有要处理任何重要事件时，将执行此委托。</span><span class="sxs-lookup"><span data-stu-id="d7a68-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]<span data-ttu-id="d7a68-193"> 响应能力比数字检查更重要。</span><span class="sxs-lookup"><span data-stu-id="d7a68-193"> responsiveness is more important than number checking.</span></span> <span data-ttu-id="d7a68-194">我们还传递了一个表示数字检查例程的新委托。</span><span class="sxs-lookup"><span data-stu-id="d7a68-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="d7a68-195">此方法检查下一个奇数是否是质数。</span><span class="sxs-lookup"><span data-stu-id="d7a68-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="d7a68-196">如果它是质数，此方法直接更新`bigPrime`<xref:System.Windows.Controls.TextBlock>以反映其发现。</span><span class="sxs-lookup"><span data-stu-id="d7a68-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="d7a68-197">可以如此操作的原因是，该计算发生在用于创建组件的相同线程中。</span><span class="sxs-lookup"><span data-stu-id="d7a68-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="d7a68-198">如果选择使用单独的线程进行计算，我们需要使用更复杂的同步机制，并执行中的更新[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="d7a68-199">我们将在下一步中演示这种情况。</span><span class="sxs-lookup"><span data-stu-id="d7a68-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="d7a68-200">此示例的完整源代码，请参阅[长时间运行计算示例的单线程应用程序](http://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="d7a68-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="d7a68-201">使用后台线程处理阻塞操作</span><span class="sxs-lookup"><span data-stu-id="d7a68-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="d7a68-202">在图形应用程序中处理阻塞操作可能很困难。</span><span class="sxs-lookup"><span data-stu-id="d7a68-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="d7a68-203">我们不希望从事件处理程序调用阻塞方法，因为应用程序可能看上去冻结。</span><span class="sxs-lookup"><span data-stu-id="d7a68-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="d7a68-204">我们可以使用一个单独的线程来处理这些操作，但操作完成后，我们必须与同步[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程因为我们不能直接修改[!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)]从我们的工作线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread.</span></span> <span data-ttu-id="d7a68-205">我们可以使用<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>要插入到的委托<xref:System.Windows.Threading.Dispatcher>的[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="d7a68-206">最终，这些委托将执行有权修改[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]元素。</span><span class="sxs-lookup"><span data-stu-id="d7a68-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="d7a68-207">在本例中，我们模拟了一个检索天气预报的远程过程调用。</span><span class="sxs-lookup"><span data-stu-id="d7a68-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="d7a68-208">我们使用单独的工作线程来执行此调用，并我们计划中的更新方法<xref:System.Windows.Threading.Dispatcher>的[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程在完成后。</span><span class="sxs-lookup"><span data-stu-id="d7a68-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 <span data-ttu-id="d7a68-209">![天气 UI 屏幕快照](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span><span class="sxs-lookup"><span data-stu-id="d7a68-209">![Weather UI screen shot](../../../../docs/framework/wpf/advanced/media/threadingweatheruiscreenshot.PNG "ThreadingWeatherUIScreenShot")</span></span>  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="d7a68-210">以下是一些需要注意的详细信息。</span><span class="sxs-lookup"><span data-stu-id="d7a68-210">The following are some of the details to be noted.</span></span>  
  
-   <span data-ttu-id="d7a68-211">创建按钮处理程序</span><span class="sxs-lookup"><span data-stu-id="d7a68-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="d7a68-212">单击按钮时，会显示时钟绘图并开始对其进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="d7a68-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="d7a68-213">禁用该按钮。</span><span class="sxs-lookup"><span data-stu-id="d7a68-213">We disable the button.</span></span> <span data-ttu-id="d7a68-214">我们调用`FetchWeatherFromServer`新线程，然后我们方法返回，允许<xref:System.Windows.Threading.Dispatcher>处理事件时我们将等待收集天气预报。</span><span class="sxs-lookup"><span data-stu-id="d7a68-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
-   <span data-ttu-id="d7a68-215">获取天气</span><span class="sxs-lookup"><span data-stu-id="d7a68-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="d7a68-216">为简便起见，本例中没有任何网络代码。</span><span class="sxs-lookup"><span data-stu-id="d7a68-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="d7a68-217">通过使新线程进入休眠状态四秒钟，模拟网络访问的延迟。</span><span class="sxs-lookup"><span data-stu-id="d7a68-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="d7a68-218">在此时间，原始[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程时仍运行并对事件作出响应。</span><span class="sxs-lookup"><span data-stu-id="d7a68-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="d7a68-219">为了对此进行演示，我们让动画保持运行状态，最小化和最大化按钮也继续工作。</span><span class="sxs-lookup"><span data-stu-id="d7a68-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="d7a68-220">当完成时延迟，并且我们已随机选择我们天气预报时，这是时间来报告回[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="d7a68-221">我们执行此操作通过计划调用`UpdateUserInterface`中[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程使用此线程的<xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="d7a68-222">将描述天气的字符串传递给此计划方法调用。</span><span class="sxs-lookup"><span data-stu-id="d7a68-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
-   <span data-ttu-id="d7a68-223">更新[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="d7a68-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="d7a68-224">当<xref:System.Windows.Threading.Dispatcher>中[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程有时间时，它会执行的计划的调用`UpdateUserInterface`。</span><span class="sxs-lookup"><span data-stu-id="d7a68-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="d7a68-225">此方法停止时钟动画，并选择一张映像用于描述天气。</span><span class="sxs-lookup"><span data-stu-id="d7a68-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="d7a68-226">它将显示此映像，并还原“获取预报”按钮。</span><span class="sxs-lookup"><span data-stu-id="d7a68-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="d7a68-227">多窗口、多线程</span><span class="sxs-lookup"><span data-stu-id="d7a68-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="d7a68-228">某些[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]应用程序需要多个顶级窗口。</span><span class="sxs-lookup"><span data-stu-id="d7a68-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="d7a68-229">它是完全可以接受一个线程 /<xref:System.Windows.Threading.Dispatcher>组合来管理多个时段，但有时多个线程执行的更好的作业。</span><span class="sxs-lookup"><span data-stu-id="d7a68-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="d7a68-230">尤其当这些窗口中的某一个将有可能要独占线程时，更是如此。</span><span class="sxs-lookup"><span data-stu-id="d7a68-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]<span data-ttu-id="d7a68-231"> 资源管理器以这种方式工作。</span><span class="sxs-lookup"><span data-stu-id="d7a68-231"> Explorer works in this fashion.</span></span> <span data-ttu-id="d7a68-232">每个新资源管理器窗口都属于原始进程，但它是在独立线程的控件下创建的。</span><span class="sxs-lookup"><span data-stu-id="d7a68-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="d7a68-233">通过使用[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame>控件，我们可以显示网页。</span><span class="sxs-lookup"><span data-stu-id="d7a68-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="d7a68-234">我们可以轻松地创建一个简单[!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)]替换。</span><span class="sxs-lookup"><span data-stu-id="d7a68-234">We can easily create a simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute.</span></span> <span data-ttu-id="d7a68-235">让我们从一个重要功能开始：打开新资源管理器窗口的能力。</span><span class="sxs-lookup"><span data-stu-id="d7a68-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="d7a68-236">当用户单击“新建窗口”按钮时，我们将在单独的线程中启动窗口的副本。</span><span class="sxs-lookup"><span data-stu-id="d7a68-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="d7a68-237">这样一来，在其中一个窗口中的长时间运行或阻塞操作将不会锁定其他窗口。</span><span class="sxs-lookup"><span data-stu-id="d7a68-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="d7a68-238">在实际情况下，Web 浏览器模型自身拥有复杂的线程模型。</span><span class="sxs-lookup"><span data-stu-id="d7a68-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="d7a68-239">由于大多数读者都熟悉它，所以我们选择它。</span><span class="sxs-lookup"><span data-stu-id="d7a68-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="d7a68-240">以下示例显示了代码。</span><span class="sxs-lookup"><span data-stu-id="d7a68-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="d7a68-241">此代码中的以下线程段对我们来说是最有趣的：</span><span class="sxs-lookup"><span data-stu-id="d7a68-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="d7a68-242">当单击“新建窗口”按钮时，将调用该方法。</span><span class="sxs-lookup"><span data-stu-id="d7a68-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="d7a68-243">它创建了一个新线程，并以异步方式启动。</span><span class="sxs-lookup"><span data-stu-id="d7a68-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="d7a68-244">此方法是新线程的起点。</span><span class="sxs-lookup"><span data-stu-id="d7a68-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="d7a68-245">我们在此线程的控件下创建了一个新窗口。</span><span class="sxs-lookup"><span data-stu-id="d7a68-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="d7a68-246">自动创建一个新<xref:System.Windows.Threading.Dispatcher>来管理新线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-246"> automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="d7a68-247">我们所要做，以使该窗口功能是启动<xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="d7a68-248">技术详细信息和疑难点</span><span class="sxs-lookup"><span data-stu-id="d7a68-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="d7a68-249">使用线程处理编写组件</span><span class="sxs-lookup"><span data-stu-id="d7a68-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="d7a68-250">[!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)]开发人员指南描述如何组件可以公开向其客户端的异步行为的模式 (请参阅[基于事件的异步模式概述](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md))。</span><span class="sxs-lookup"><span data-stu-id="d7a68-250">The [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="d7a68-251">例如，假设我们想要打包`FetchWeatherFromServer`方法划分为可重用、 非图形的组件。</span><span class="sxs-lookup"><span data-stu-id="d7a68-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="d7a68-252">采用标准[!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)]模式，这看起来应如下所示。</span><span class="sxs-lookup"><span data-stu-id="d7a68-252">Following the standard [!INCLUDE[TLA#tla_netframewk](../../../../includes/tlasharptla-netframewk-md.md)] pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 <span data-ttu-id="d7a68-253">`GetWeatherAsync` 将使用上述的技术之一（如创建后台线程）来以异步方式工作，而非阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="d7a68-254">此模式的最重要的部分之一调用*MethodName* `Completed`方法调用在同一线程*MethodName* `Async`方法的开头。</span><span class="sxs-lookup"><span data-stu-id="d7a68-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="d7a68-255">你可以使用执行这类情况的操作[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]非常轻松，通过将存储<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>-但然后非图形组件无法只能用在[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]应用程序，不在[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]或[!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]程序。</span><span class="sxs-lookup"><span data-stu-id="d7a68-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs.</span></span>  
  
 <span data-ttu-id="d7a68-256"><xref:System.Windows.Threading.DispatcherSynchronizationContext>类满足这一需要 — 它看作的简化版本<xref:System.Windows.Threading.Dispatcher>适用于其他[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]以及框架。</span><span class="sxs-lookup"><span data-stu-id="d7a68-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="d7a68-257">嵌套泵</span><span class="sxs-lookup"><span data-stu-id="d7a68-257">Nested Pumping</span></span>  
 <span data-ttu-id="d7a68-258">有时不能完全锁定[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="d7a68-259">让我们考虑<xref:System.Windows.MessageBox.Show%2A>方法<xref:System.Windows.MessageBox>类。</span><span class="sxs-lookup"><span data-stu-id="d7a68-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="d7a68-260"><xref:System.Windows.MessageBox.Show%2A>没有返回直到用户单击确定按钮。</span><span class="sxs-lookup"><span data-stu-id="d7a68-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="d7a68-261">但是，它却会创建一个窗口，该窗口为了获得交互性而必须具有消息循环。</span><span class="sxs-lookup"><span data-stu-id="d7a68-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="d7a68-262">在等待用户单击“确定”时，原始应用程序窗口将不会响应用户的输入。</span><span class="sxs-lookup"><span data-stu-id="d7a68-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="d7a68-263">但是，它将继续处理绘制消息。</span><span class="sxs-lookup"><span data-stu-id="d7a68-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="d7a68-264">当被覆盖和被显示时，原始窗口将重绘其本身。</span><span class="sxs-lookup"><span data-stu-id="d7a68-264">The original window redraws itself when covered and revealed.</span></span>  
  
 <span data-ttu-id="d7a68-265">![具有“确定”按钮的消息框](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span><span class="sxs-lookup"><span data-stu-id="d7a68-265">![MessageBox with an "OK" button](../../../../docs/framework/wpf/advanced/media/threadingnestedpumping.png "ThreadingNestedPumping")</span></span>  
  
 <span data-ttu-id="d7a68-266">一些线程必须负责消息框窗口。</span><span class="sxs-lookup"><span data-stu-id="d7a68-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="d7a68-267"> 可以为消息框窗口创建新线程，但此线程无法在原始窗口中绘制禁用的元素（请回忆之前所讨论的互相排斥）。</span><span class="sxs-lookup"><span data-stu-id="d7a68-267"> could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="d7a68-268">相反，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]使用嵌套的消息处理系统。</span><span class="sxs-lookup"><span data-stu-id="d7a68-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="d7a68-269"><xref:System.Windows.Threading.Dispatcher>类包括一个称为特殊方法<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>，它用于存储应用程序的当前执行点然后开始新的消息循环。</span><span class="sxs-lookup"><span data-stu-id="d7a68-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="d7a68-270">嵌套的消息循环完成时，将在原始后恢复执行<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="d7a68-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="d7a68-271">在这种情况下，<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>维护对的调用的程序上下文<xref:System.Windows.MessageBox>。<xref:System.Windows.MessageBox.Show%2A>，并开始新的消息循环，以重新绘制背景窗口并处理输入消息框窗口。</span><span class="sxs-lookup"><span data-stu-id="d7a68-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="d7a68-272">当用户单击确定，并清除弹出窗口中时，嵌套的循环退出，控件将在调用后恢复<xref:System.Windows.MessageBox.Show%2A>。</span><span class="sxs-lookup"><span data-stu-id="d7a68-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="d7a68-273">过时的路由事件</span><span class="sxs-lookup"><span data-stu-id="d7a68-273">Stale Routed Events</span></span>  
 <span data-ttu-id="d7a68-274">中的路由的事件系统[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]引发事件时通知整个树。</span><span class="sxs-lookup"><span data-stu-id="d7a68-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="d7a68-275">椭圆，通过按下鼠标左键时`handler2`执行。</span><span class="sxs-lookup"><span data-stu-id="d7a68-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="d7a68-276">后`handler2`完成，该事件传递到<xref:System.Windows.Controls.Canvas>对象，后者使用`handler1`以对其进行处理。</span><span class="sxs-lookup"><span data-stu-id="d7a68-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="d7a68-277">仅当发生这种情况`handler2`不显式标记事件对象为已处理。</span><span class="sxs-lookup"><span data-stu-id="d7a68-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="d7a68-278">可能的`handler2`需要大量的时间来处理此事件。</span><span class="sxs-lookup"><span data-stu-id="d7a68-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="d7a68-279">`handler2`可能使用<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>开始小时数不返回嵌套的消息循环。</span><span class="sxs-lookup"><span data-stu-id="d7a68-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="d7a68-280">如果`handler2`不事件为已处理此消息循环时完成的标记，则即使非常陈旧，树向上传递的事件。</span><span class="sxs-lookup"><span data-stu-id="d7a68-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="d7a68-281">重新进入和锁定</span><span class="sxs-lookup"><span data-stu-id="d7a68-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="d7a68-282">锁定机制[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]完全相同的行为不可能想象一个; 某个用户可能希望完全停止操作，请求锁定时的线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-282">The locking mechanism of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="d7a68-283">实际上，该线程将继续接收和处理高优先级的消息。</span><span class="sxs-lookup"><span data-stu-id="d7a68-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="d7a68-284">这样有助于防止死锁，并使接口最低限度地响应，但这样做有可能引入细微 bug。</span><span class="sxs-lookup"><span data-stu-id="d7a68-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="d7a68-285">大多数情况下无需知道任何有关此操作，但在极少数情况下 (通常涉及[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]窗口消息或 COM STA 组件)，这可能需要了解。</span><span class="sxs-lookup"><span data-stu-id="d7a68-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="d7a68-286">大多数接口不构建与记住的线程安全性，因为开发人员在假设的[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]多个线程从不访问。</span><span class="sxs-lookup"><span data-stu-id="d7a68-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="d7a68-287">在此情况下，单线程，可能会意外情况下，使环境更改导致这些错误效果<xref:System.Windows.Threading.DispatcherObject>互相排斥机制应该解决。</span><span class="sxs-lookup"><span data-stu-id="d7a68-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="d7a68-288">请看下面的伪代码：</span><span class="sxs-lookup"><span data-stu-id="d7a68-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="d7a68-289">![线程处理重入示意图](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="d7a68-289">![Threading reentrancy diagram](../../../../docs/framework/wpf/advanced/media/threadingreentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="d7a68-290">大多数情况下，正确的操作，但有中的时间[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]其中此类意外的重新进入确实会导致问题。</span><span class="sxs-lookup"><span data-stu-id="d7a68-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="d7a68-291">因此，在某些关键时刻，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]调用<xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>，其更改为使用该线程的锁指令[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]非重入锁，而不是常规[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]锁。</span><span class="sxs-lookup"><span data-stu-id="d7a68-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.</span></span>  
  
 <span data-ttu-id="d7a68-292">那么，为什么未[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]团队选择此行为？</span><span class="sxs-lookup"><span data-stu-id="d7a68-292">So why did the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?</span></span> <span data-ttu-id="d7a68-293">它与 COM STA 对象和完成线程有关。</span><span class="sxs-lookup"><span data-stu-id="d7a68-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="d7a68-294">当一个对象进行垃圾回收，其`Finalize`方法不在专用终结器线程上运行[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="d7a68-295">其中存在问题，因为 COM STA 对象上创建[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程可以仅释放上[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程。</span><span class="sxs-lookup"><span data-stu-id="d7a68-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="d7a68-296">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]的等效<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>(在这种情况下使用 Win32 的`SendMessage`)。</span><span class="sxs-lookup"><span data-stu-id="d7a68-296">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="d7a68-297">但是，如果[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]线程处于忙碌状态、 终结器线程将停止，无法释放 COM STA 对象，这种结构造成严重的内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="d7a68-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="d7a68-298">因此[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]团队进行严格的调用来使锁的工作方式一样。</span><span class="sxs-lookup"><span data-stu-id="d7a68-298">So the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="d7a68-299">有关任务[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]是为了避免意外的重新进入不重新引入内存泄漏，这正是我们避免阻塞无处不在可重入性。</span><span class="sxs-lookup"><span data-stu-id="d7a68-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d7a68-300">另请参阅</span><span class="sxs-lookup"><span data-stu-id="d7a68-300">See Also</span></span>  
 [<span data-ttu-id="d7a68-301">具有长时间运行计算的单线程应用程序示例</span><span class="sxs-lookup"><span data-stu-id="d7a68-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](http://go.microsoft.com/fwlink/?LinkID=160038)
