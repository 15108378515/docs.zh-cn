---
title: "默认 XAML 架构上下文和 WPF XAML 架构上下文"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 04e06a15-09b3-4210-9bdf-9a64c2eccb83
caps.latest.revision: "7"
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.openlocfilehash: ccb89b67b222c11695131a1aa8423b89df1c9a70
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/18/2017
---
# <a name="default-xaml-schema-context-and-wpf-xaml-schema-context"></a><span data-ttu-id="91a9b-102">默认 XAML 架构上下文和 WPF XAML 架构上下文</span><span class="sxs-lookup"><span data-stu-id="91a9b-102">Default XAML Schema Context and WPF XAML Schema Context</span></span>
<span data-ttu-id="91a9b-103">XAML 架构上下文是限定 XAML 生产环境中使用的特定 XAML 词汇如何与编写行为，包括如何类型映射解决时，程序集的加载方式、 如何某些读取器和编写器的对象进行交互的概念实体解释设置。</span><span class="sxs-lookup"><span data-stu-id="91a9b-103">A XAML schema context is a conceptual entity that qualifies how a XAML production that uses a particular XAML vocabulary interacts with the object writing behavior, including how type mapping resolves, how assemblies are loaded, how certain reader and writer settings are interpreted.</span></span> <span data-ttu-id="91a9b-104">本主题介绍.NET Framework XAML 服务和基于 CLR 类型系统的关联的默认 XAML 架构上下文的功能。</span><span class="sxs-lookup"><span data-stu-id="91a9b-104">This topic describes the features of the .NET Framework XAML Services and the associated default XAML schema context, which is based on the CLR type system.</span></span> <span data-ttu-id="91a9b-105">本主题还介绍适用于 WPF XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="91a9b-105">This topic also describes the XAML schema context that is used for WPF.</span></span>  
  
## <a name="default-xaml-schema-context"></a><span data-ttu-id="91a9b-106">默认 XAML 架构上下文</span><span class="sxs-lookup"><span data-stu-id="91a9b-106">Default XAML Schema Context</span></span>  
 <span data-ttu-id="91a9b-107">.NET framework XAML 服务同时实施，并使用默认 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="91a9b-107">.NET Framework XAML Services both implements and uses a default XAML schema context.</span></span> <span data-ttu-id="91a9b-108">默认 XAML 架构上下文行为并不总是完全可见的 API 中<xref:System.Xaml.XamlSchemaContext>类。</span><span class="sxs-lookup"><span data-stu-id="91a9b-108">The default XAML schema context behavior is not always fully visible in the API of the <xref:System.Xaml.XamlSchemaContext> class.</span></span> <span data-ttu-id="91a9b-109">但是，在许多情况下，默认 XAML 架构上下文影响行为将是通过公共 API 的 XAML 类型系统，如的成员可观测对象<xref:System.Xaml.XamlMember>或<xref:System.Xaml.XamlType>，或通过 XAML 读取器和 XAML 编写器使用上公开的 Api默认 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="91a9b-109">However, in many cases the behavior that the default XAML schema context influences is observable through common API of the XAML type system, such as members of <xref:System.Xaml.XamlMember> or <xref:System.Xaml.XamlType>, or through APIs exposed on XAML readers and XAML writers that are using the default XAML schema context.</span></span>  
  
 <span data-ttu-id="91a9b-110">你可以创建<xref:System.Xaml.XamlSchemaContext>通过调用封装的默认行为<xref:System.Xaml.XamlSchemaContext>构造函数。</span><span class="sxs-lookup"><span data-stu-id="91a9b-110">You can create a <xref:System.Xaml.XamlSchemaContext> that encapsulates the default behavior by calling the <xref:System.Xaml.XamlSchemaContext> constructor.</span></span> <span data-ttu-id="91a9b-111">这将显式创建的默认 XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="91a9b-111">This explicitly creates the default XAML schema context.</span></span> <span data-ttu-id="91a9b-112">如果 XAML 读取器或使用不显式采用的 Api 的 XAML 编写器初始化隐式创建的相同的默认 XAML 架构上下文<xref:System.Xaml.XamlSchemaContext>输入的参数。</span><span class="sxs-lookup"><span data-stu-id="91a9b-112">The same default XAML schema context is created implicitly, if you initialize a XAML reader or XAML writer using APIs that do not explicitly take a <xref:System.Xaml.XamlSchemaContext> input parameter.</span></span>  
  
 <span data-ttu-id="91a9b-113">默认 XAML 架构上下文依赖于 CLR 对其类型映射的行为的反射。</span><span class="sxs-lookup"><span data-stu-id="91a9b-113">The default XAML schema context relies on CLR reflection for its type mapping behavior.</span></span> <span data-ttu-id="91a9b-114">这包括检查定义 CLR <xref:System.Type>，和相关<xref:System.Reflection.PropertyInfo>或<xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="91a9b-114">This includes examining the defining CLR <xref:System.Type>, and related <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.MethodInfo>.</span></span> <span data-ttu-id="91a9b-115">此外，为了在 XAML 类型或使用 CLR 后备类型的 XAML 成员信息的具体信息填充使用 CLR 归属类型或成员。</span><span class="sxs-lookup"><span data-stu-id="91a9b-115">Also, CLR attribution on types or members is used in order to fill in the specifics for XAML type or XAML member information that uses the CLR backing type.</span></span> <span data-ttu-id="91a9b-116">默认 XAML 架构上下文不需要类型系统扩展技术，如`Invoker`模式，因为所需的信息是从 CLR 类型系统可用。</span><span class="sxs-lookup"><span data-stu-id="91a9b-116">The default XAML schema context does not require type system extension techniques such as the `Invoker` pattern, because the necessary information is available from the CLR type system.</span></span>  
  
 <span data-ttu-id="91a9b-117">对于程序集加载逻辑，默认 XAML 架构上下文依赖主要的 XAML 命名空间映射中提供任何程序集值。</span><span class="sxs-lookup"><span data-stu-id="91a9b-117">For assembly loading logic, the default XAML schema context relies mainly on any assembly values provided in XAML namespace mappings.</span></span> <span data-ttu-id="91a9b-118">此外，<xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A>可以提示加载，如加载内部类型的方案某程序集。</span><span class="sxs-lookup"><span data-stu-id="91a9b-118">Also, <xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A> can hint an assembly to load, for scenarios such as loading internal types.</span></span>  
  
## <a name="wpf-xaml-schema-context"></a><span data-ttu-id="91a9b-119">WPF XAML 架构上下文</span><span class="sxs-lookup"><span data-stu-id="91a9b-119">WPF XAML Schema Context</span></span>  
 <span data-ttu-id="91a9b-120">因为的 WPF 实现，提供有趣举例说明了可以通过实现的非默认 XAML 架构上下文中引入的功能的类型，本主题中描述的 WPF XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="91a9b-120">The WPF XAML schema context is described in this topic because the WPF implementation provides an interesting illustration of the kinds of features that can be introduced by implementing a non-default XAML schema context.</span></span> <span data-ttu-id="91a9b-121">此外，XAML 架构上下文概念中未讨论很大程度 WPF 文档，此迭代 WPF XAML;XAML 架构上下文便会启用的行为可能仅集成并讨论了默认 XAML 架构上下文的工作原理完全可以理解。</span><span class="sxs-lookup"><span data-stu-id="91a9b-121">Also, the XAML schema context concept is not discussed very much in the WPF documentation that addresses WPF XAML; the behavior that the XAML schema context enables might only be fully understandable if integrated with a discussion of how the default XAML schema context works.</span></span> <span data-ttu-id="91a9b-122">WPF XAML 架构上下文实现以下行为。</span><span class="sxs-lookup"><span data-stu-id="91a9b-122">The WPF XAML schema context implements the following behavior.</span></span>  
  
 <span data-ttu-id="91a9b-123">**查找重写：** WPF xaml 具有几个内容模型其中有不是函数的 XAML 内容属性<xref:System.Windows.Markup.ContentPropertyAttribute>特性化。</span><span class="sxs-lookup"><span data-stu-id="91a9b-123">**Lookup overrides:** WPF has a few content  models for XAML where there are XAML content properties that function without being <xref:System.Windows.Markup.ContentPropertyAttribute> attributed.</span></span> <span data-ttu-id="91a9b-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A>替代 WPF 实现此行为。</span><span class="sxs-lookup"><span data-stu-id="91a9b-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A> overrides for WPF implement this behavior.</span></span>  
  
 <span data-ttu-id="91a9b-125">**WPF 表达式的延迟：** WPF 功能将值的延迟，直到运行时上下文可用的多个表达式类。</span><span class="sxs-lookup"><span data-stu-id="91a9b-125">**Deferral for WPF expressions:** WPF features several expression classes that defer a value until a runtime context is available.</span></span> <span data-ttu-id="91a9b-126">此外，模板扩展是依赖于延迟技术的运行时行为。</span><span class="sxs-lookup"><span data-stu-id="91a9b-126">Also, template expansion is a runtime behavior that relies on deferral techniques.</span></span>  
  
 <span data-ttu-id="91a9b-127">**类型系统查找优化：** WPF 都具有一个广泛 XAML 词汇和对象模型，包括到按原义数百个 WPF 定义类继承的基类成员定义。</span><span class="sxs-lookup"><span data-stu-id="91a9b-127">**Type system lookup optimizations:** WPF has an extensive XAML vocabulary and object model, including base class member definitions that inherit to literally hundreds of WPF-defined classes.</span></span> <span data-ttu-id="91a9b-128">此外，WPF 本身是分布在多个程序集。</span><span class="sxs-lookup"><span data-stu-id="91a9b-128">Also, WPF itself is spread across several assemblies.</span></span> <span data-ttu-id="91a9b-129">WPF 优化使用查找表和其他技术其类型查找。</span><span class="sxs-lookup"><span data-stu-id="91a9b-129">WPF optimizes its type lookup using lookup tables and other techniques.</span></span> <span data-ttu-id="91a9b-130">此基础上的默认 XAML 架构上下文和其基于 CLR 的类型查找提供了性能改进。</span><span class="sxs-lookup"><span data-stu-id="91a9b-130">This provides performance improvements over the default XAML schema context and its CLR-based type lookup.</span></span> <span data-ttu-id="91a9b-131">在其中查找表中不存在类型的情况下，该行为使用类似于默认 XAML 架构上下文的 XAML 架构上下文技术。</span><span class="sxs-lookup"><span data-stu-id="91a9b-131">In cases where types do not exist in a lookup table, the behavior uses XAML schema context techniques that are similar to the default XAML schema context.</span></span>  
  
 <span data-ttu-id="91a9b-132">**XamlType 和 XamlMember 扩展：** WPF 通过扩展，与依赖项属性的属性概念和事件概念与路由事件。</span><span class="sxs-lookup"><span data-stu-id="91a9b-132">**XamlType and XamlMember extension:** WPF extends property concepts with dependency properties, and event concepts with routed events.</span></span> <span data-ttu-id="91a9b-133">若要为针对 XAML 处理操作的这些概念进行了更好的可视性，WPF 扩展<xref:System.Xaml.XamlType>和<xref:System.Xaml.XamlMember>，并添加报告依赖项属性和路由事件特征的内部属性。</span><span class="sxs-lookup"><span data-stu-id="91a9b-133">To give these concepts greater visibility for XAML processing operations, WPF extends <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>, and adds internal properties that report dependency property and routed event characteristics.</span></span>  
  
### <a name="accessing-the-wpf-xaml-schema-context"></a><span data-ttu-id="91a9b-134">访问 WPF XAML 架构上下文</span><span class="sxs-lookup"><span data-stu-id="91a9b-134">Accessing the WPF XAML Schema Context</span></span>  
 <span data-ttu-id="91a9b-135">如果你使用的基于 WPF 的 XAML 技术<xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType>或<xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>，WPF XAML 架构上下文已在使用这些 XAML 读取器和 XAML 编写器实现。</span><span class="sxs-lookup"><span data-stu-id="91a9b-135">If you are using XAML techniques that are based on the WPF <xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType> or <xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>, the WPF XAML schema context is already in use on those XAML reader and XAML writer implementations.</span></span>  
  
 <span data-ttu-id="91a9b-136">如果使用其他 XAML 读取器或未初始化的 XAML 编写器实现与 WPF XAML 架构上下文，你可能无法获得一个有效的 WPF XAML 架构上下文从<xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="91a9b-136">If you are using other XAML reader or XAML writer implementations that do not initialize with the WPF XAML schema context, you may be able to get a working WPF XAML schema context from <xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="91a9b-137">然后可以使用此值，作为使用其他 api 的初始化<xref:System.Xaml.XamlSchemaContext>。</span><span class="sxs-lookup"><span data-stu-id="91a9b-137">You can then use this value as initialization for other API that use a <xref:System.Xaml.XamlSchemaContext>.</span></span> <span data-ttu-id="91a9b-138">例如，可以调用<xref:System.Xaml.XamlXmlReader.%23ctor%2A>的初始化，然后传递 WPF XAML 架构上下文。</span><span class="sxs-lookup"><span data-stu-id="91a9b-138">For example, you could call <xref:System.Xaml.XamlXmlReader.%23ctor%2A> for initialization and pass the WPF XAML schema context.</span></span> <span data-ttu-id="91a9b-139">或者，可以使用 WPF XAML 架构上下文的 XAML 类型系统操作。</span><span class="sxs-lookup"><span data-stu-id="91a9b-139">Or you could use the WPF XAML schema context for XAML type system operations.</span></span> <span data-ttu-id="91a9b-140">这可能包括构造初始化<xref:System.Xaml.XamlType>或<xref:System.Xaml.XamlMember>，或调用<xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="91a9b-140">This might include construction initialization of a <xref:System.Xaml.XamlType> or <xref:System.Xaml.XamlMember>, or calling <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="91a9b-141">请注意，是否从纯的 XAML 节点流角度访问 WPF XAML 的某些方面，一些 WPF framework 功能可能不具有已按照尚未。</span><span class="sxs-lookup"><span data-stu-id="91a9b-141">Note that if you access certain aspects of WPF XAML from a pure XAML node stream perspectives, some of the WPF framework capabilities may not have acted yet.</span></span> <span data-ttu-id="91a9b-142">例如，控件的 WPF 模板尚未应用。</span><span class="sxs-lookup"><span data-stu-id="91a9b-142">For example, WPF templates for controls are not yet applied.</span></span> <span data-ttu-id="91a9b-143">因此如果你访问一个属性，在运行时可能已填充整个可视化树，你可能只能看到引用模板的属性值。</span><span class="sxs-lookup"><span data-stu-id="91a9b-143">Thus if you access a property that at run time might be populated with a full visual tree, you might only see a property value that references a template.</span></span> <span data-ttu-id="91a9b-144">提供的 WPF 标记扩展的服务上下文可能也不会准确如果提供非运行时的情况下，从和尝试写入对象图时，可能会导致异常。</span><span class="sxs-lookup"><span data-stu-id="91a9b-144">The service context provided for WPF markup extensions might also not be accurate if provided from a non-runtime situation, and can result in exceptions when attempting to write an object graph.</span></span>  
  
## <a name="xaml-and-assembly-loading"></a><span data-ttu-id="91a9b-145">XAML 和程序集加载</span><span class="sxs-lookup"><span data-stu-id="91a9b-145">XAML and Assembly Loading</span></span>  
 <span data-ttu-id="91a9b-146">程序集加载的 XAML 和.NET Framework XAML 服务集成的 CLR 定义概念<xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="91a9b-146">Assembly loading for XAML and .NET Framework XAML Services integrates with the CLR-defined concept of <xref:System.AppDomain>.</span></span> <span data-ttu-id="91a9b-147">XAML 架构上下文解释如何加载程序集或类型查找在运行的时或设计时，基于使用<xref:System.AppDomain>和其他因素。</span><span class="sxs-lookup"><span data-stu-id="91a9b-147">A XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the use of <xref:System.AppDomain> and other factors.</span></span> <span data-ttu-id="91a9b-148">逻辑会略有不同，具体取决于 XAML 是 XAML 读取器的宽松 XAML，是 XAML 编译成由 DLL `XamlBuildTask`，或由 WPF 的生成 BAML `PresentationBuildTask`。</span><span class="sxs-lookup"><span data-stu-id="91a9b-148">The logic is slightly different depending on whether the XAML is loose XAML for a XAML reader, is XAML compiled into a DLL by `XamlBuildTask`, or is BAML generated by WPF's `PresentationBuildTask`.</span></span>  
  
 <span data-ttu-id="91a9b-149">与 WPF 应用程序模型，这反过来使用集成，WPF XAML 架构上下文<xref:System.AppDomain>以及其他因素的 WPF 实现详细信息。</span><span class="sxs-lookup"><span data-stu-id="91a9b-149">The XAML schema context for WPF integrates with the WPF application model, which in turn uses <xref:System.AppDomain> as well as other factors that are WPF implementation details.</span></span>  
  
#### <a name="xaml-reader-input-loose-xaml"></a><span data-ttu-id="91a9b-150">XAML 读取器输入 (宽松型 XAML)</span><span class="sxs-lookup"><span data-stu-id="91a9b-150">XAML reader input (loose XAML)</span></span>  
  
1.  <span data-ttu-id="91a9b-151">XAML 架构上下文循环访问<xref:System.AppDomain>应用程序，查找匹配的名称，所有方面的已加载程序集的最近从最开始加载程序集。</span><span class="sxs-lookup"><span data-stu-id="91a9b-151">The XAML schema context iterates through the <xref:System.AppDomain> of the application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="91a9b-152">如果找到匹配项，则该程序集用于解析。</span><span class="sxs-lookup"><span data-stu-id="91a9b-152">If a match is found, that assembly is used for resolution.</span></span>  
  
2.  <span data-ttu-id="91a9b-153">否则，以下方法之一将基于 CLR <xref:System.Reflection.Assembly> API 用于加载程序集：</span><span class="sxs-lookup"><span data-stu-id="91a9b-153">Otherwise, one of the following techniques based on CLR <xref:System.Reflection.Assembly> API are used to load an assembly:</span></span>  
  
    -   <span data-ttu-id="91a9b-154">如果映射中限定的名称，调用<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>的限定名称。</span><span class="sxs-lookup"><span data-stu-id="91a9b-154">If the name is qualified in the mapping, call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>  
  
    -   <span data-ttu-id="91a9b-155">如果前面的步骤失败，使用短名称 （和公钥标记如果存在） 调用<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="91a9b-155">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
    -   <span data-ttu-id="91a9b-156">如果映射中非限定名称，则调用<xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="91a9b-156">If the name is unqualified in the mapping, call <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>.</span></span>  
  
#### <a name="xamlbuildtask"></a><span data-ttu-id="91a9b-157">XamlBuildTask</span><span class="sxs-lookup"><span data-stu-id="91a9b-157">XamlBuildTask</span></span>  
 <span data-ttu-id="91a9b-158">`XamlBuildTask`适用于[!INCLUDE[vsindigo](../../../includes/vsindigo-md.md)]和[!INCLUDE[TLA#tla_workflow](../../../includes/tlasharptla-workflow-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="91a9b-158">`XamlBuildTask` is used for [!INCLUDE[vsindigo](../../../includes/vsindigo-md.md)] and [!INCLUDE[TLA#tla_workflow](../../../includes/tlasharptla-workflow-md.md)].</span></span>  
  
 <span data-ttu-id="91a9b-159">请注意，程序集引用了通过`XamlBuildTask`始终是完全限定。</span><span class="sxs-lookup"><span data-stu-id="91a9b-159">Note that assembly references through `XamlBuildTask` are always fully qualified.</span></span>  
  
1.  <span data-ttu-id="91a9b-160">调用<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>的限定名称。</span><span class="sxs-lookup"><span data-stu-id="91a9b-160">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>  
  
2.  <span data-ttu-id="91a9b-161">如果前面的步骤失败，使用短名称 （和公钥标记如果存在） 调用<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="91a9b-161">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
#### <a name="baml-presentationbuildtask"></a><span data-ttu-id="91a9b-162">BAML (PresentationBuildTask)</span><span class="sxs-lookup"><span data-stu-id="91a9b-162">BAML (PresentationBuildTask)</span></span>  
 <span data-ttu-id="91a9b-163">有两个方面的 BAML 的程序集加载： 加载包含作为组件，BAML 的初始程序集和加载引用的 BAML 生产任何类型的类型支持程序集。</span><span class="sxs-lookup"><span data-stu-id="91a9b-163">There are two aspects to assembly-loading for BAML: loading the initial assembly that contains the BAML as a component, and loading the type-backing assemblies for any types referenced by the BAML production.</span></span>  
  
##### <a name="assembly-load-for-initial-markup"></a><span data-ttu-id="91a9b-164">初始标记的程序集加载：</span><span class="sxs-lookup"><span data-stu-id="91a9b-164">Assembly load for initial markup:</span></span>  
 <span data-ttu-id="91a9b-165">要加载的标记的程序集的引用始终是不合格的。</span><span class="sxs-lookup"><span data-stu-id="91a9b-165">The reference to the assembly to load the markup from is always unqualified.</span></span>  
  
1.  <span data-ttu-id="91a9b-166">WPF XAML 架构上下文循环访问<xref:System.AppDomain>WPF 应用程序，查找匹配的名称，所有方面的已加载程序集的最近从最开始加载程序集。</span><span class="sxs-lookup"><span data-stu-id="91a9b-166">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="91a9b-167">如果找到匹配项，则该程序集用于解析。</span><span class="sxs-lookup"><span data-stu-id="91a9b-167">If a match is found, that assembly is used for resolution.</span></span>  
  
2.  <span data-ttu-id="91a9b-168">如果前面的步骤失败，使用短名称 （和公钥标记如果存在） 调用<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="91a9b-168">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
##### <a name="assembly-references-by-baml-types"></a><span data-ttu-id="91a9b-169">由 BAML 类型的程序集引用：</span><span class="sxs-lookup"><span data-stu-id="91a9b-169">Assembly references by BAML types:</span></span>  
 <span data-ttu-id="91a9b-170">BAML 生产中使用的类型的程序集引用始终是完全限定，作为生成任务的输出。</span><span class="sxs-lookup"><span data-stu-id="91a9b-170">Assembly references for types used in the BAML production are always fully qualified, as an output of the build task.</span></span>  
  
1.  <span data-ttu-id="91a9b-171">WPF XAML 架构上下文循环访问<xref:System.AppDomain>WPF 应用程序，查找匹配的名称，所有方面的已加载程序集的最近从最开始加载程序集。</span><span class="sxs-lookup"><span data-stu-id="91a9b-171">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="91a9b-172">如果找到匹配项，则该程序集用于解析。</span><span class="sxs-lookup"><span data-stu-id="91a9b-172">If a match is found, that assembly is used for resolution.</span></span>  
  
2.  <span data-ttu-id="91a9b-173">否则，以下方法之一用于加载程序集：</span><span class="sxs-lookup"><span data-stu-id="91a9b-173">Otherwise, one of the following techniques is used to load an assembly:</span></span>  
  
    -   <span data-ttu-id="91a9b-174">调用<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>的限定名称。</span><span class="sxs-lookup"><span data-stu-id="91a9b-174">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>  
  
    -   <span data-ttu-id="91a9b-175">如果一个短名称 + 公钥令牌的组合匹配 BAML 从加载的程序集中，使用该程序集。</span><span class="sxs-lookup"><span data-stu-id="91a9b-175">If a short name + public key token combination match the assembly that the BAML was loaded from, use that assembly.</span></span>  
  
    -   <span data-ttu-id="91a9b-176">使用短名称 + 公钥令牌来调用<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="91a9b-176">Use short name + public key token to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="91a9b-177">另请参阅</span><span class="sxs-lookup"><span data-stu-id="91a9b-177">See Also</span></span>  
 [<span data-ttu-id="91a9b-178">了解 XAML 节点流结构和概念</span><span class="sxs-lookup"><span data-stu-id="91a9b-178">Understanding XAML Node Stream Structures and Concepts</span></span>](../../../docs/framework/xaml-services/understanding-xaml-node-stream-structures-and-concepts.md)
