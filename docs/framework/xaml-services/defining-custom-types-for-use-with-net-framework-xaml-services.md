---
title: 定义与 .NET Framework XAML 服务一起使用的自定义类型
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 9edc7baa1a540a71997cf5b1ed010ad5c7960d17
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/04/2018
ms.locfileid: "33566491"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="ce97c-102">定义与 .NET Framework XAML 服务一起使用的自定义类型</span><span class="sxs-lookup"><span data-stu-id="ce97c-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="ce97c-103">当你定义了业务对象的自定义类型或者不在特定框架具有依赖关系的类型时，有一些你可以遵循 xaml 某些最佳实践。</span><span class="sxs-lookup"><span data-stu-id="ce97c-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="ce97c-104">如果您遵循这些做法，.NET Framework XAML 服务和其 XAML 读取器和 XAML 编写器可以发现你的类型的 XAML 特征，并为其提供适当的表示形式，在 XAML 节点流中使用的 XAML 类型系统。</span><span class="sxs-lookup"><span data-stu-id="ce97c-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="ce97c-105">本主题介绍类型定义，成员定义和 CLR 特性化的类型或成员的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="ce97c-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="ce97c-106">构造函数模式和 XAML 的类型定义</span><span class="sxs-lookup"><span data-stu-id="ce97c-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="ce97c-107">要作为对象元素在 XAML 中实例化，自定义类必须满足以下要求：</span><span class="sxs-lookup"><span data-stu-id="ce97c-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="ce97c-108">自定义类必须是公共的并且必须公开默认 （无参数） 公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="ce97c-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="ce97c-109">（有关结构注释，请参阅下节内容。）</span><span class="sxs-lookup"><span data-stu-id="ce97c-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="ce97c-110">自定义的类必须是嵌套的类。</span><span class="sxs-lookup"><span data-stu-id="ce97c-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="ce97c-111">额外的完整名称路径中的"点"使类命名空间除法不明确的并且会干扰其他 XAML 功能，例如附加属性。</span><span class="sxs-lookup"><span data-stu-id="ce97c-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="ce97c-112">作为对象元素，可实例化一个对象，如果所创建的对象可以填充属性元素形式将该对象作为其基础类型的任何属性。</span><span class="sxs-lookup"><span data-stu-id="ce97c-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="ce97c-113">如果启用了值转换器，你仍可以为不满足这些条件的类型中提供对象值。</span><span class="sxs-lookup"><span data-stu-id="ce97c-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="ce97c-114">有关详细信息，请参阅[类型转换器和 XAML 的标记扩展](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="ce97c-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="ce97c-115">结构</span><span class="sxs-lookup"><span data-stu-id="ce97c-115">Structures</span></span>  
 <span data-ttu-id="ce97c-116">结构始终是能够在 XAML 中，通过 CLR 定义构造的。</span><span class="sxs-lookup"><span data-stu-id="ce97c-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="ce97c-117">这是因为 CLR 编译器隐式创建一个结构的默认构造函数。</span><span class="sxs-lookup"><span data-stu-id="ce97c-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="ce97c-118">此构造函数初始化为其默认值的所有属性值。</span><span class="sxs-lookup"><span data-stu-id="ce97c-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="ce97c-119">在某些情况下，一个结构的默认构造行为是不需要的。</span><span class="sxs-lookup"><span data-stu-id="ce97c-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="ce97c-120">这可能是因为结构旨在在概念上作为联合填充值和函数。</span><span class="sxs-lookup"><span data-stu-id="ce97c-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="ce97c-121">作为一个联合，包含的值可能有相互排斥的解释，并因此，其属性都是不可设置。</span><span class="sxs-lookup"><span data-stu-id="ce97c-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="ce97c-122">这种结构中的 WPF 词汇的一个示例是<xref:System.Windows.GridLength>。</span><span class="sxs-lookup"><span data-stu-id="ce97c-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="ce97c-123">此类结构应实现的类型转换器，以便值可以在属性表单中，表示通过创建不同的解释或模式的结构值的字符串约定。</span><span class="sxs-lookup"><span data-stu-id="ce97c-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="ce97c-124">结构还应通过非默认构造函数对代码构造公开类似的行为。</span><span class="sxs-lookup"><span data-stu-id="ce97c-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="ce97c-125">接口</span><span class="sxs-lookup"><span data-stu-id="ce97c-125">Interfaces</span></span>  
 <span data-ttu-id="ce97c-126">接口可以用作基础类型的成员。</span><span class="sxs-lookup"><span data-stu-id="ce97c-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="ce97c-127">XAML 类型系统检查可赋值的列表，并且期望作为值提供的对象可以分配给的接口。</span><span class="sxs-lookup"><span data-stu-id="ce97c-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="ce97c-128">没有如何接口必须表示为 XAML 类型，只要相关可赋值的类型支持的 XAML 构造要求的概念。</span><span class="sxs-lookup"><span data-stu-id="ce97c-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="ce97c-129">工厂方法</span><span class="sxs-lookup"><span data-stu-id="ce97c-129">Factory Methods</span></span>  
 <span data-ttu-id="ce97c-130">工厂方法是 XAML 2009 功能。</span><span class="sxs-lookup"><span data-stu-id="ce97c-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="ce97c-131">他们修改对象必须具有默认构造函数的 XAML 原则。</span><span class="sxs-lookup"><span data-stu-id="ce97c-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="ce97c-132">在本主题不介绍工厂方法。</span><span class="sxs-lookup"><span data-stu-id="ce97c-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="ce97c-133">请参阅[X:factorymethod 指令](../../../docs/framework/xaml-services/x-factorymethod-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="ce97c-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="ce97c-134">枚举</span><span class="sxs-lookup"><span data-stu-id="ce97c-134">Enumerations</span></span>  
 <span data-ttu-id="ce97c-135">枚举具有 XAML 本机类型转换行为。</span><span class="sxs-lookup"><span data-stu-id="ce97c-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="ce97c-136">在 XAML 中指定的枚举常量名基础的枚举类型中，针对解析，并返回到 XAML 对象编写器的枚举值。</span><span class="sxs-lookup"><span data-stu-id="ce97c-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="ce97c-137">XAML 支持使用枚举标志样式用法<xref:System.FlagsAttribute>应用。</span><span class="sxs-lookup"><span data-stu-id="ce97c-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="ce97c-138">有关详细信息，请参阅[在详细信息的 XAML 语法](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="ce97c-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="ce97c-139">([在详细信息的 XAML 语法](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)专为 WPF 受众，但并不特定于特定实现框架的 xaml 与大部分该主题中的信息。)</span><span class="sxs-lookup"><span data-stu-id="ce97c-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="ce97c-140">成员定义</span><span class="sxs-lookup"><span data-stu-id="ce97c-140">Member Definitions</span></span>  
 <span data-ttu-id="ce97c-141">类型可以定义用于 XAML 的成员。</span><span class="sxs-lookup"><span data-stu-id="ce97c-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="ce97c-142">它是可能的类型的定义是 XAML 可用，即使该特定的类型不是 XAML 可用的成员。</span><span class="sxs-lookup"><span data-stu-id="ce97c-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="ce97c-143">这是因为 CLR 继承。</span><span class="sxs-lookup"><span data-stu-id="ce97c-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="ce97c-144">只要某种类型的继承成员支持 XAML 用法作为类型，并且该成员为其基础类型支持 XAML 用法，或具有可用的本机 XAML 语法，则该成员是 XAML 可用。</span><span class="sxs-lookup"><span data-stu-id="ce97c-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="ce97c-145">属性</span><span class="sxs-lookup"><span data-stu-id="ce97c-145">Properties</span></span>  
 <span data-ttu-id="ce97c-146">如果定义属性定义为使用典型的 CLR 的公共 CLR 属性`get`和`set`访问器模式和语言应建立关键词，XAML 类型系统可以提供相应的信息的成员作为属性进行报告<xref:System.Xaml.XamlMember>属性，如<xref:System.Xaml.XamlMember.IsReadPublic%2A>和<xref:System.Xaml.XamlMember.IsWritePublic%2A>。</span><span class="sxs-lookup"><span data-stu-id="ce97c-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="ce97c-147">特定属性可以通过应用启用文本语法<xref:System.ComponentModel.TypeConverterAttribute>。</span><span class="sxs-lookup"><span data-stu-id="ce97c-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="ce97c-148">有关详细信息，请参阅[类型转换器和 XAML 的标记扩展](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="ce97c-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="ce97c-149">在没有文本语法或本机 XAML 转换和没有进一步间接寻址，如标记扩展用法，属性的类型 (<xref:System.Xaml.XamlMember.TargetType%2A>在 XAML 类型系统) 必须能够通过将 t 到 XAML 对象编写器返回的实例arget 作为 CLR 类型的类型。</span><span class="sxs-lookup"><span data-stu-id="ce97c-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="ce97c-150">如果使用 XAML 2009 [X:reference 标记扩展](../../../docs/framework/xaml-services/x-reference-markup-extension.md)可以用于提供值，如果不满足前面的注意事项; 但是，这是多个类型定义问题比使用情况问题。</span><span class="sxs-lookup"><span data-stu-id="ce97c-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="ce97c-151">事件</span><span class="sxs-lookup"><span data-stu-id="ce97c-151">Events</span></span>  
 <span data-ttu-id="ce97c-152">如果为公共的 CLR 事件定义事件，XAML 类型系统可以将事件报告为成员，同时<xref:System.Xaml.XamlMember.IsEvent%2A>作为`true`。</span><span class="sxs-lookup"><span data-stu-id="ce97c-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="ce97c-153">连接事件处理程序不是.NET Framework XAML 服务功能; 的作用域内此功能由特定框架和实现。</span><span class="sxs-lookup"><span data-stu-id="ce97c-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="ce97c-154">方法</span><span class="sxs-lookup"><span data-stu-id="ce97c-154">Methods</span></span>  
 <span data-ttu-id="ce97c-155">方法的内联代码不是默认的 XAML 功能。</span><span class="sxs-lookup"><span data-stu-id="ce97c-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="ce97c-156">在大多数情况下你不要直接引用方法成员从 XAML，并在 XAML 中的方法的角色是仅提供了特定 XAML 模式提供支持。</span><span class="sxs-lookup"><span data-stu-id="ce97c-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="ce97c-157">[X:factorymethod 指令](../../../docs/framework/xaml-services/x-factorymethod-directive.md)出现异常。</span><span class="sxs-lookup"><span data-stu-id="ce97c-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="ce97c-158">字段</span><span class="sxs-lookup"><span data-stu-id="ce97c-158">Fields</span></span>  
 <span data-ttu-id="ce97c-159">CLR 设计准则禁止非静态字段。</span><span class="sxs-lookup"><span data-stu-id="ce97c-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="ce97c-160">对于静态字段，你可以访问静态字段值只能通过[X:static 标记扩展](../../../docs/framework/xaml-services/x-static-markup-extension.md); 在这种情况下你未执行任何特殊操作中要公开的字段的 CLR 定义[X:static](../../../docs/framework/xaml-services/x-static-markup-extension.md)用法。</span><span class="sxs-lookup"><span data-stu-id="ce97c-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="ce97c-161">可附加成员</span><span class="sxs-lookup"><span data-stu-id="ce97c-161">Attachable Members</span></span>  
 <span data-ttu-id="ce97c-162">可附加的成员上定义的类型访问器方法模式通过公开给 XAML。</span><span class="sxs-lookup"><span data-stu-id="ce97c-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="ce97c-163">定义类型本身不必要 XAML 能够用作对象。</span><span class="sxs-lookup"><span data-stu-id="ce97c-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="ce97c-164">事实上，一种常见模式是以声明其角色是一个服务类拥有的可附加成员并实现相关的行为，但不提供如 UI 表示方式的任何其他功能。</span><span class="sxs-lookup"><span data-stu-id="ce97c-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="ce97c-165">有关以下各节，将占位符*PropertyName*表示可附加成员的名称。</span><span class="sxs-lookup"><span data-stu-id="ce97c-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="ce97c-166">该名称必须是有效中[XamlName 语法](../../../docs/framework/xaml-services/xamlname-grammar.md)。</span><span class="sxs-lookup"><span data-stu-id="ce97c-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="ce97c-167">请务必谨慎的这些模式和类型的其他方法之间的名称冲突。</span><span class="sxs-lookup"><span data-stu-id="ce97c-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="ce97c-168">如果存在匹配的模式之一的成员，它可以被视为可附加成员用法路径由 XAML 处理器即使这并不是您的意图。</span><span class="sxs-lookup"><span data-stu-id="ce97c-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="ce97c-169">GetPropertyName 访问器</span><span class="sxs-lookup"><span data-stu-id="ce97c-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="ce97c-170">`Get` PropertyName 访问器的签名必须是：</span><span class="sxs-lookup"><span data-stu-id="ce97c-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="ce97c-171">`public static object Get` PropertyName `(object` `target` `)`</span><span class="sxs-lookup"><span data-stu-id="ce97c-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="ce97c-172">`target` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="ce97c-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="ce97c-173">你可以使用此作用域可附加成员; 的使用情况你预期使用范围之外的用法将引发无效强制转换异常，然后会显示 XAML 分析错误。</span><span class="sxs-lookup"><span data-stu-id="ce97c-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="ce97c-174">参数名称`target`不是一种要求，但名为`target`受到约定的大多数实施方案。</span><span class="sxs-lookup"><span data-stu-id="ce97c-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="ce97c-175">返回值在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="ce97c-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="ce97c-176">若要支持<xref:System.ComponentModel.TypeConverter>对于特性用法的可附加成员的已启用的文本语法应用<xref:System.ComponentModel.TypeConverterAttribute>到`Get` *PropertyName*访问器。</span><span class="sxs-lookup"><span data-stu-id="ce97c-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="ce97c-177">将应用于`get`而不是`set`可能看起来直观; 但是，此约定可支持这一概念的只读可附加成员进行序列化，这是设计器的方案中十分有用。</span><span class="sxs-lookup"><span data-stu-id="ce97c-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="ce97c-178">SetPropertyName 访问器</span><span class="sxs-lookup"><span data-stu-id="ce97c-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="ce97c-179">集的签名*PropertyName*访问器必须是：</span><span class="sxs-lookup"><span data-stu-id="ce97c-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="ce97c-180">`public static void Set` PropertyName `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="ce97c-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="ce97c-181">`target`上一节中所述，可以在实现中，具有相同的逻辑和后果更具体的类型为指定对象。</span><span class="sxs-lookup"><span data-stu-id="ce97c-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="ce97c-182">`value` 对象在实现中可以指定为更具体的类型。</span><span class="sxs-lookup"><span data-stu-id="ce97c-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="ce97c-183">请记住，此方法的值是来自 XAML 用法中，通常采用特性形式的输入。</span><span class="sxs-lookup"><span data-stu-id="ce97c-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="ce97c-184">在特性形式必须有值转换器支持文本语法，并且特性上`Get` *PropertyName*访问器。</span><span class="sxs-lookup"><span data-stu-id="ce97c-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="ce97c-185">可附加成员存储</span><span class="sxs-lookup"><span data-stu-id="ce97c-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="ce97c-186">访问器方法通常是不足够，以提供一种可附加成员值放在对象图，或检索值超出对象图和序列化这些正确。</span><span class="sxs-lookup"><span data-stu-id="ce97c-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="ce97c-187">若要提供此功能，`target`以前的访问器签名中的对象必须能够存储值。</span><span class="sxs-lookup"><span data-stu-id="ce97c-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="ce97c-188">存储机制应与成员是可附加到目标的可附加成员不在成员列表中的可附加成员原则一致。</span><span class="sxs-lookup"><span data-stu-id="ce97c-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="ce97c-189">.NET framework XAML 服务提供实现的一种技术，可附加成员存储通过 Api<xref:System.Xaml.IAttachedPropertyStore>和<xref:System.Xaml.AttachablePropertyServices>。</span><span class="sxs-lookup"><span data-stu-id="ce97c-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="ce97c-190"><xref:System.Xaml.IAttachedPropertyStore> XAML 编写器用于发现的存储实现，并应在为的类型中实现`target`访问器。</span><span class="sxs-lookup"><span data-stu-id="ce97c-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="ce97c-191">静态<xref:System.Xaml.AttachablePropertyServices>Api 访问器中，主体中使用和的可附加成员是指其<xref:System.Xaml.AttachableMemberIdentifier>。</span><span class="sxs-lookup"><span data-stu-id="ce97c-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="ce97c-192">与 XAML 相关 CLR 特性</span><span class="sxs-lookup"><span data-stu-id="ce97c-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="ce97c-193">正确的归类型、 成员和程序集是重要到报表的.NET Framework XAML 服务 XAML 类型系统信息的顺序。</span><span class="sxs-lookup"><span data-stu-id="ce97c-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="ce97c-194">如果希望你的类型用于直接基于.NET Framework XAML 服务 XAML 读取器和 XAML 编写的 XAML 系统，或如果你定义或使用 XAML 利用框架基于这些 XAML 读取器和 XAML 编写器，这是相关。</span><span class="sxs-lookup"><span data-stu-id="ce97c-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="ce97c-195">有关相关的自定义类型的 XAML 支持的每个与 XAML 相关的属性的列表，请参阅[的自定义类型和库的 XAML-Related CLR 特性](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)。</span><span class="sxs-lookup"><span data-stu-id="ce97c-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="ce97c-196">用法</span><span class="sxs-lookup"><span data-stu-id="ce97c-196">Usage</span></span>  
 <span data-ttu-id="ce97c-197">使用自定义类型需要标记作者必须映射包含自定义类型的程序集和 CLR 命名空间的前缀。</span><span class="sxs-lookup"><span data-stu-id="ce97c-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="ce97c-198">本主题中不记录此过程。</span><span class="sxs-lookup"><span data-stu-id="ce97c-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="ce97c-199">访问级别</span><span class="sxs-lookup"><span data-stu-id="ce97c-199">Access Level</span></span>  
 <span data-ttu-id="ce97c-200">XAML 提供一种方法来加载和实例化类型具有`internal`访问级别。</span><span class="sxs-lookup"><span data-stu-id="ce97c-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="ce97c-201">提供此功能，以便用户代码可以定义自己的类型，然后实例化也是相同的用户代码作用域的一部分的标记从这些类。</span><span class="sxs-lookup"><span data-stu-id="ce97c-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="ce97c-202">WPF 的一个示例是只要用户代码定义<xref:System.Windows.Controls.UserControl>打算作为一种方法重构 UI 行为，但不是可能会隐式声明的支持类与任何可能的扩展机制的一部分`public`访问级别。</span><span class="sxs-lookup"><span data-stu-id="ce97c-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="ce97c-203">此类<xref:System.Windows.Controls.UserControl>可使用声明`internal`访问如果后备代码会编译成从中它引用了作为 XAML 类型的相同程序集。</span><span class="sxs-lookup"><span data-stu-id="ce97c-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="ce97c-204">为应用程序在完全信任下加载 XAML 并使用<xref:System.Xaml.XamlObjectWriter>，类加载`internal`访问级别始终处于启用状态。</span><span class="sxs-lookup"><span data-stu-id="ce97c-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="ce97c-205">对于在部分信任下加载 XAML 的应用，你可以通过使用控制的访问级别特征<xref:System.Xaml.Permissions.XamlAccessLevel>API。</span><span class="sxs-lookup"><span data-stu-id="ce97c-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="ce97c-206">此外，必须能够传播任何访问级别权限，并保留它们的最终的运行的时评估; 进行延期机制 （如 WPF 模板系统）这通过传递在内部处理<xref:System.Xaml.Permissions.XamlAccessLevel>信息。</span><span class="sxs-lookup"><span data-stu-id="ce97c-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="ce97c-207">WPF 实现</span><span class="sxs-lookup"><span data-stu-id="ce97c-207">WPF Implementation</span></span>  
 <span data-ttu-id="ce97c-208">WPF XAML 使用部分信任访问模型，其中如果 BAML 加载在部分信任下，访问仅限于<xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A>的程序集的 BAML 源。</span><span class="sxs-lookup"><span data-stu-id="ce97c-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="ce97c-209">对于延迟，WPF 使用<xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType>作为传递访问级别信息的机制。</span><span class="sxs-lookup"><span data-stu-id="ce97c-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="ce97c-210">在 WPF XAML 术语中，*内部类型*是由同一程序集，还包括引用的 XAML 定义的类型。</span><span class="sxs-lookup"><span data-stu-id="ce97c-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="ce97c-211">这样的类型可以映射通过 XAML 命名空间的有意省略了程序集 = 一部分的映射，例如， `xmlns:local="clr-namespace:WPFApplication1"`。</span><span class="sxs-lookup"><span data-stu-id="ce97c-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="ce97c-212">如果 BAML 引用的内部类型，并且该类型具有`internal`访问级别时，这将生成`GeneratedInternalTypeHelper`程序集的类。</span><span class="sxs-lookup"><span data-stu-id="ce97c-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="ce97c-213">如果你想要避免`GeneratedInternalTypeHelper`，则必须使用`public`访问级别时，或必须相关类分解为单独的程序集，并将该程序集依赖。</span><span class="sxs-lookup"><span data-stu-id="ce97c-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ce97c-214">请参阅</span><span class="sxs-lookup"><span data-stu-id="ce97c-214">See Also</span></span>  
 [<span data-ttu-id="ce97c-215">自定义类型和库的 XAML 相关 CLR 特性</span><span class="sxs-lookup"><span data-stu-id="ce97c-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 [<span data-ttu-id="ce97c-216">XAML 服务</span><span class="sxs-lookup"><span data-stu-id="ce97c-216">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)
