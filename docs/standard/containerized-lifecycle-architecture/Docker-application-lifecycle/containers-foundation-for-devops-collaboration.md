---
title: "DevOps 协作基础的容器"
description: "使用 Microsoft 平台和工具的 Docker 容器化应用程序生命周期"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.openlocfilehash: 24aad577fca0fd540d66f9e037b58f53583d8fbb
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2017
---
# <a name="containers-as-the-foundation-for-devops-collaboration"></a><span data-ttu-id="62ab6-104">DevOps 协作基础的容器</span><span class="sxs-lookup"><span data-stu-id="62ab6-104">Containers as the foundation for DevOps collaboration</span></span>

<span data-ttu-id="62ab6-105">由容器和 Docker 技术的性质，开发人员可以共享及其软件和依赖关系轻松地与 IT 运营和生产环境同时消除典型的"it works 我的计算机上"理由。</span><span class="sxs-lookup"><span data-stu-id="62ab6-105">By the very nature of the containers and Docker technology, developers can share their software and dependencies easily with IT operations and production environments while eliminating the typical "it works on my machine" excuse.</span></span> <span data-ttu-id="62ab6-106">容器解决不同的环境之间的应用程序冲突。</span><span class="sxs-lookup"><span data-stu-id="62ab6-106">Containers solve application conflicts between different environments.</span></span> <span data-ttu-id="62ab6-107">间接，容器和 Docker 使开发人员和 IT 运营部门更靠近在一起，使其更方便地有效地进行协作。</span><span class="sxs-lookup"><span data-stu-id="62ab6-107">Indirectly, containers and Docker bring developers and IT operations closer together, making it easier for them to collaborate effectively.</span></span> <span data-ttu-id="62ab6-108">采用容器工作流将许多客户提供他们已查找但以前必须实现通过更复杂的配置，对于版本和生成管道的 DevOps 连续性。</span><span class="sxs-lookup"><span data-stu-id="62ab6-108">Adopting the container workflow provides many customers with the DevOps continuity they've sought but previously had to implement via more complex configuration for release and build pipelines.</span></span> <span data-ttu-id="62ab6-109">容器简化在 DevOps 中生成或测试/部署管道。</span><span class="sxs-lookup"><span data-stu-id="62ab6-109">Containers simplify the build/test/deploy pipelines in DevOps.</span></span>

![](./media/image1.png)

<span data-ttu-id="62ab6-110">每个容器化 Docker 应用程序生命周期中的"角色"的图 2-1： 主工作负荷</span><span class="sxs-lookup"><span data-stu-id="62ab6-110">Figure 2-1: Main workloads per "personas" in the life cycle for containerized Docker applications</span></span>

<span data-ttu-id="62ab6-111">借助 Docker 容器，开发人员自己什么是在 （应用程序和服务和的框架和组件的依赖项） 的容器和容器和服务的行为方式为应用程序的服务的集合是由在一起。</span><span class="sxs-lookup"><span data-stu-id="62ab6-111">With Docker containers, developers own what's within the container (application and service, and dependencies to frameworks and components) and how the containers and services behave together as an application composed by a collection of services.</span></span> <span data-ttu-id="62ab6-112">Docker-compose.yml 文件，或那些可称为中定义多个容器的依存关系*部署清单*。</span><span class="sxs-lookup"><span data-stu-id="62ab6-112">The interdependencies of the multiple containers are defined in a docker-compose.yml file, or what could be called a *deployment manifest*.</span></span> <span data-ttu-id="62ab6-113">同时，IT 运营团队 （IT 专业人员和管理） 可以专注于生产环境; 的管理基础结构;可伸缩性;监视;并且，从根本上讲，确保，应用程序是否可以实现正确的最终用户，而无需知道各种容器的内容。</span><span class="sxs-lookup"><span data-stu-id="62ab6-113">Meanwhile, IT operations teams (IT professionals and management) can focus on the management of production environments; infrastructure; scalability; monitoring; and, ultimately, ensuring that the applications are delivering properly for the end users, without having to know the contents of the various containers.</span></span> <span data-ttu-id="62ab6-114">因此，名称"容器，"重新调用到实际传送容器的相似之处。</span><span class="sxs-lookup"><span data-stu-id="62ab6-114">Hence, the name "container," recalling the analogy to real-world shipping containers.</span></span> <span data-ttu-id="62ab6-115">因此，容器的内容的所有者需要不考虑自身与如何容器将被传送、 传输和传送的公司传输从起点到其目标的容器而无需知道或有关内容管理。</span><span class="sxs-lookup"><span data-stu-id="62ab6-115">Thus, the owners of a container's content need not concern themselves with how the container will be shipped, and the shipping company transports a container from its point of origin to its destination without knowing or caring about the contents.</span></span> <span data-ttu-id="62ab6-116">类似的方式，开发人员可以创建和拥有而无需自己考虑"传输"机制 Docker 容器中的内容。</span><span class="sxs-lookup"><span data-stu-id="62ab6-116">In a similar manner, developers can create and own the contents within a Docker container without the need to concern themselves with the "transport" mechanisms.</span></span>

<span data-ttu-id="62ab6-117">在图 2-1 的左侧支柱，开发人员编写和 Docker 容器中本地运行代码，通过使用用于 Windows 的 Docker 或 mac。</span><span class="sxs-lookup"><span data-stu-id="62ab6-117">In the pillar on the left side of Figure 2-1, developers write and run code locally in Docker containers by using Docker for Windows or Mac.</span></span> <span data-ttu-id="62ab6-118">它们通过使用指定的基的操作系统以及到 Docker 映像生成其代码的生成步骤运行 Dockerfile 定义的代码的运行环境。</span><span class="sxs-lookup"><span data-stu-id="62ab6-118">They define the operating environment for the code by using a Dockerfile that specifies the base operating system to run as well as the build steps for building their code into a Docker image.</span></span> <span data-ttu-id="62ab6-119">开发人员定义的一个或多个映像将交互使用前面提到*docker-compose.yml*文件部署清单。</span><span class="sxs-lookup"><span data-stu-id="62ab6-119">The developers define how the one or more images will interoperate using the aforementioned *docker-compose.yml* file deployment manifest.</span></span> <span data-ttu-id="62ab6-120">在完成其本地开发时, 它们推送其应用程序代码加上的 Docker 配置文件到他们选择 （即，Git 存储库） 的代码存储库。</span><span class="sxs-lookup"><span data-stu-id="62ab6-120">As they complete their local development, they push their application code plus the Docker configuration files to the code repository of their choice (that is, Git repository).</span></span>

<span data-ttu-id="62ab6-121">DevOps pillar 定义使用的代码存储库中提供的 Dockerfile 生成 – 连续集成 (CI) 管道。</span><span class="sxs-lookup"><span data-stu-id="62ab6-121">The DevOps pillar defines the build–Continuous Integration (CI) pipelines using the Dockerfile provided in the code repository.</span></span> <span data-ttu-id="62ab6-122">CI 系统从所选的 Docker 注册表中提取基本容器映像，并生成应用程序的自定义 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="62ab6-122">The CI system pulls the base container images from the selected Docker registry and builds the custom Docker images for the application.</span></span> <span data-ttu-id="62ab6-123">映像然后验证和推送到用于部署到多个环境 Docker 注册表。</span><span class="sxs-lookup"><span data-stu-id="62ab6-123">The images then are validated and pushed to the Docker registry used for the deployments to multiple environments.</span></span>

<span data-ttu-id="62ab6-124">在右侧支柱，团队管理的操作部署应用程序和在监视的环境和应用程序，以便它们可以提供反馈和有关如何应用程序可能由开发团队的见解时的生产环境中的基础结构改进。</span><span class="sxs-lookup"><span data-stu-id="62ab6-124">In the pillar on the right, operations teams manage deployed applications and infrastructure in production while monitoring the environment and applications so that they can provide feedback and insights to the development team about how the application might be improved.</span></span> <span data-ttu-id="62ab6-125">容器应用程序通常在使用容器 orchestrators 的生产环境中运行。</span><span class="sxs-lookup"><span data-stu-id="62ab6-125">Container apps are typically run in production using container orchestrators.</span></span>

<span data-ttu-id="62ab6-126">两个团队协作通过提供作为一个协定，从而大大提高应用程序生命周期中的两个团队的协作时分离问题的基础平台 （Docker 容器）。</span><span class="sxs-lookup"><span data-stu-id="62ab6-126">The two teams are collaborating through a foundational platform (Docker containers) that provides a separation of concerns as a contract, while greatly improving the two teams' collaboration in the application life cycle.</span></span> <span data-ttu-id="62ab6-127">开发人员拥有容器内容、 其运行环境和容器相互依赖关系，而运营团队采用清单以及生成的映像，并在其业务流程系统中运行它们。</span><span class="sxs-lookup"><span data-stu-id="62ab6-127">The developers own the container contents, its operating environment, and the container interdependencies, whereas the operations teams take the built images along with the manifest and runs them in their orchestration system.</span></span>

## <a name="introduction-to-a-generic-end-to-end-docker-application-life-cycle-workflow"></a><span data-ttu-id="62ab6-128">泛型端到端 Docker 应用程序生命周期工作流简介</span><span class="sxs-lookup"><span data-stu-id="62ab6-128">Introduction to a generic end-to-end Docker application life cycle workflow</span></span>

<span data-ttu-id="62ab6-129">图 2-2 提供更详细的工作流 Docker 应用程序生命周期，将此实例中重点放在特定的 DevOps 活动和资产。</span><span class="sxs-lookup"><span data-stu-id="62ab6-129">Figure 2-2 presents a more detailed workflow for a Docker application life cycle, focusing in this instance on specific DevOps activities and assets.</span></span>

![](./media/image2.png)

<span data-ttu-id="62ab6-130">Docker 容器化应用程序生命周期图 2-2： 高级工作流</span><span class="sxs-lookup"><span data-stu-id="62ab6-130">Figure 2-2: High-level workflow for the Docker containerized application life cycle</span></span>

<span data-ttu-id="62ab6-131">所有内容开头的开发，人员开始在内部循环工作流中编写代码。</span><span class="sxs-lookup"><span data-stu-id="62ab6-131">Everything begins with the developer, who starts writing code in the inner-loop workflow.</span></span> <span data-ttu-id="62ab6-132">内部循环阶段是开发人员在其中定义发生之前将代码推送到代码存储库 （例如，例如 Git 源代码管理系统） 的所有内容。</span><span class="sxs-lookup"><span data-stu-id="62ab6-132">The inner-loop stage is where developers define everything that happens before pushing code into the code repository (for example, a source control system such as Git).</span></span> <span data-ttu-id="62ab6-133">提交后，存储库中将触发持续集成 (CI) 和工作流的其余部分。</span><span class="sxs-lookup"><span data-stu-id="62ab6-133">After it is committed, the repository triggers Continuous Integration (CI) and the rest of the workflow.</span></span>

<span data-ttu-id="62ab6-134">内部循环基本上包含"与代码一样，""，""test"和"调试，"以及其他步骤直接之前运行本地运行应用程序的典型步骤。</span><span class="sxs-lookup"><span data-stu-id="62ab6-134">The inner loop basically consists of typical steps like "code," "run," "test," and "debug," plus additional steps directly before running the app locally.</span></span> <span data-ttu-id="62ab6-135">这是当开发人员运行并测试 Docker 容器形式的应用。</span><span class="sxs-lookup"><span data-stu-id="62ab6-135">This is when the developer runs and tests the app as a Docker container.</span></span> <span data-ttu-id="62ab6-136">内部循环工作流将在以下各节中所述。</span><span class="sxs-lookup"><span data-stu-id="62ab6-136">The inner-loop workflow will be explained in the sections that follow.</span></span>

<span data-ttu-id="62ab6-137">返回采用一个步骤，若要查看端到端工作流，DevOps 工作流不只是一种技术或工具集： 它是需要区域性演变观念。</span><span class="sxs-lookup"><span data-stu-id="62ab6-137">Taking a step back to look at the end-to end workflow, the DevOps workflow is more than a technology or a tool set: it's a mindset that requires cultural evolution.</span></span> <span data-ttu-id="62ab6-138">它是人员、 流程和相应的工具，以使您的应用程序生命周期更快且更可预测。</span><span class="sxs-lookup"><span data-stu-id="62ab6-138">It is people, processes, and the appropriate tools to make your application life cycle faster and more predictable.</span></span> <span data-ttu-id="62ab6-139">通常采用容器化工作流的企业重构其组织来表示人员和匹配的容器化工作流的过程。</span><span class="sxs-lookup"><span data-stu-id="62ab6-139">Enterprises that adopt a containerized workflow typically restructure their organizations to represent people and processes that match the containerized workflow.</span></span>

<span data-ttu-id="62ab6-140">DevOps 在其中完成练习可帮助团队更快地响应一起竞争压力通过自动化，这会导致提高可跟踪性和可重复的工作流以代替易出错的手动过程。</span><span class="sxs-lookup"><span data-stu-id="62ab6-140">Practicing DevOps can help teams respond faster together to competitive pressures by replacing error-prone manual processes with automation, which results in improved traceability and repeatable workflows.</span></span> <span data-ttu-id="62ab6-141">组织还可以更有效地管理环境并实现与本地和云资源的组合的成本节约以及紧密集成的工具。</span><span class="sxs-lookup"><span data-stu-id="62ab6-141">Organizations also can manage environments more efficiently and realize cost savings with a combination of on-premises and cloud resources as well as tightly integrated tooling.</span></span>

<span data-ttu-id="62ab6-142">在实现 Docker 应用程序工作 DevOps 流时，你将看到 Docker 的技术都位于你的开发框至生成测试 CI 阶段中，内部循环 （代码，请运行、 调试） 中工作的同时从工作流中，几乎每个阶段，当然，在生产环境和过渡环境和时向这些环境中部署你的容器。</span><span class="sxs-lookup"><span data-stu-id="62ab6-142">When implementing your DevOps workflow for Docker applications, you'll see that Docker's technologies are present in almost every stage of the workflow, from your development box while working in the inner loop (code, run, debug), to the build-test-CI phase, and, of course, at the production and staging environments and when deploying your containers to those environments.</span></span>

<span data-ttu-id="62ab6-143">改善质量做法有助于识别在开发周期早期，从而减少修复它们的成本的缺陷。</span><span class="sxs-lookup"><span data-stu-id="62ab6-143">Improvement of quality practices helps to identify defects early in the development cycle, which reduces the cost of fixing them.</span></span> <span data-ttu-id="62ab6-144">通过在映像中包括的环境和依赖关系和采用的跨多个环境中部署的相同映像的理念，你将提升提取使部署更可靠的特定于环境的配置的专业。</span><span class="sxs-lookup"><span data-stu-id="62ab6-144">By including the environment and dependencies in the image and adopting a philosophy of deploying the same image across multiple environments, you promote a discipline of extracting the environment-specific configurations making deployments more reliable.</span></span>

<span data-ttu-id="62ab6-145">获取通过有效检测 （监视和诊断） 的丰富数据深入性能问题和用户行为，以指导将来的优先级和投资。</span><span class="sxs-lookup"><span data-stu-id="62ab6-145">Rich data obtained through effective instrumentation (monitoring and diagnostics) provides insight into performance issues and user behavior to guide future priorities and investments.</span></span>

<span data-ttu-id="62ab6-146">DevOps 应视为一种部署模式，而非目的。</span><span class="sxs-lookup"><span data-stu-id="62ab6-146">DevOps should be considered a journey, not a destination.</span></span> <span data-ttu-id="62ab6-147">它应以增量方式实现通过相应地指定了作用域项目从中演示成功、 学习和发展。</span><span class="sxs-lookup"><span data-stu-id="62ab6-147">It should be implemented incrementally through appropriately scoped projects from which you can demonstrate success, learn, and evolve.</span></span>

## <a name="benefits-of-devops-for-containerized-applications"></a><span data-ttu-id="62ab6-148">DevOps 的容器化应用程序的优点</span><span class="sxs-lookup"><span data-stu-id="62ab6-148">Benefits of DevOps for containerized applications</span></span>

<span data-ttu-id="62ab6-149">下面是一些提供稳定的 DevOps 工作流的最重要的好处：</span><span class="sxs-lookup"><span data-stu-id="62ab6-149">Here are some of the most important benefits provided by a solid DevOps workflow:</span></span>

-   <span data-ttu-id="62ab6-150">提供更高质量软件更快且更好的符合性</span><span class="sxs-lookup"><span data-stu-id="62ab6-150">Deliver better-quality software, faster and with better compliance</span></span>

-   <span data-ttu-id="62ab6-151">更早版本和更划算一些驱动器的持续改进和调整</span><span class="sxs-lookup"><span data-stu-id="62ab6-151">Drive continuous improvement and adjustments earlier and more economically</span></span>

-   <span data-ttu-id="62ab6-152">提高透明度和利益干系人参与建立和运行软件之间的协作</span><span class="sxs-lookup"><span data-stu-id="62ab6-152">Increase transparency and collaboration among stakeholders involved in delivering and operating software</span></span>

-   <span data-ttu-id="62ab6-153">控制成本，并更有效地利用设置的资源，同时可尽量减少安全风险</span><span class="sxs-lookup"><span data-stu-id="62ab6-153">Control costs and utilize provisioned resources more effectively while minimizing security risks</span></span>

-   <span data-ttu-id="62ab6-154">即插很好地与你现有的 DevOps 投资，包括在开放源代码中的投资的很多</span><span class="sxs-lookup"><span data-stu-id="62ab6-154">Plug and play well with many of your existing DevOps investments, including investments in open source</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="62ab6-155">[以前](index.md) [下一步] (.../Microsoft-platform-tools-containerized-apps/index.md)</span><span class="sxs-lookup"><span data-stu-id="62ab6-155">[Previous] (index.md) [Next] (../Microsoft-platform-tools-containerized-apps/index.md)</span></span>
