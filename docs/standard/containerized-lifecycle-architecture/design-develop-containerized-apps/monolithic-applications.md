---
title: "整体应用程序"
description: "使用 Microsoft 平台和工具的容器化 Docker 应用程序的生命周期"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 95561aaa8ffccb8eae3fe276192c6648c0819685
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/23/2017
---
# <a name="monolithic-applications"></a><span data-ttu-id="d4dce-104">整体应用程序</span><span class="sxs-lookup"><span data-stu-id="d4dce-104">Monolithic applications</span></span>

<span data-ttu-id="d4dce-105">在此方案中，是生成单个和整体 web 应用程序或服务，并将其部署为一个容器。</span><span class="sxs-lookup"><span data-stu-id="d4dce-105">In this scenario, you are building a single and monolithic web application or service and deploying it as a container.</span></span> <span data-ttu-id="d4dce-106">在应用程序，该结构可能不是整体;它可能包含多个库、 组件或甚至层 （应用程序层、 域层、 数据访问层等）。</span><span class="sxs-lookup"><span data-stu-id="d4dce-106">Within the application, the structure might not be monolithic; it might comprise several libraries, components, or even layers (application layer, domain layer, data access layer, etc.).</span></span> <span data-ttu-id="d4dce-107">从外部看，它是单个容器中的，如单个进程、 单个 web 应用程序或单个服务。</span><span class="sxs-lookup"><span data-stu-id="d4dce-107">Externally, it is a single container, like a single process, single web application, or single service.</span></span>

<span data-ttu-id="d4dce-108">若要管理此模型，你可以部署单个容器来表示应用程序。</span><span class="sxs-lookup"><span data-stu-id="d4dce-108">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="d4dce-109">若要缩放它，只需添加对负载平衡器在前面的几个更多副本。</span><span class="sxs-lookup"><span data-stu-id="d4dce-109">To scale it, just add a few more copies with a load balancer in front.</span></span> <span data-ttu-id="d4dce-110">为了简单起见来自于管理单个部署中的单个容器或虚拟机 (VM)。</span><span class="sxs-lookup"><span data-stu-id="d4dce-110">The simplicity comes from managing a single deployment in a single container or virtual machine (VM).</span></span>

<span data-ttu-id="d4dce-111">以下主体做一件事，并会在一个进程中的容器的整体模式有冲突。</span><span class="sxs-lookup"><span data-stu-id="d4dce-111">Following the principal that a container does one thing only, and does it in one process, the monolithic pattern is in conflict.</span></span> <span data-ttu-id="d4dce-112">图 4-1 中所示，你可以包括多个组件/库或每个容器中的内部层。</span><span class="sxs-lookup"><span data-stu-id="d4dce-112">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 4-1.</span></span>

![](./media/image1.png)

<span data-ttu-id="d4dce-113">图 4-1： 的整体应用程序体系结构示例</span><span class="sxs-lookup"><span data-stu-id="d4dce-113">Figure 4-1: An example of monolithic application architecture</span></span>

<span data-ttu-id="d4dce-114">如果或当应用程序扩展，需要进行调整时，将提供此方法的缺点。</span><span class="sxs-lookup"><span data-stu-id="d4dce-114">The downside to this approach comes if or when the application grows, requiring it to scale.</span></span> <span data-ttu-id="d4dce-115">如果整个应用程序缩放，它不是真正的问题。</span><span class="sxs-lookup"><span data-stu-id="d4dce-115">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="d4dce-116">但是，在大多数情况下，应用程序的几个部分是压点需要缩放，而不太使用了其他组件。</span><span class="sxs-lookup"><span data-stu-id="d4dce-116">However, in most cases, a few parts of the application are the choke points that require scaling, whereas other components are used less.</span></span>

<span data-ttu-id="d4dce-117">使用典型电子商务示例，你可能需要是缩放产品信息组件。</span><span class="sxs-lookup"><span data-stu-id="d4dce-117">Using the typical e-commerce example, what you likely need is to scale the product information component.</span></span> <span data-ttu-id="d4dce-118">许多多个客户浏览产品不是购买必需的许可证。</span><span class="sxs-lookup"><span data-stu-id="d4dce-118">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="d4dce-119">更多的客户使用他们的购物篮不是使用付款管道。</span><span class="sxs-lookup"><span data-stu-id="d4dce-119">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="d4dce-120">更少的客户添加注释，或查看其购买历史记录。</span><span class="sxs-lookup"><span data-stu-id="d4dce-120">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="d4dce-121">并且你可能有只有少量的员工组，在单个区域中，需要管理内容和市场营销活动。</span><span class="sxs-lookup"><span data-stu-id="d4dce-121">And you likely have only a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="d4dce-122">通过缩放单一式设计，所有的代码被部署了多次。</span><span class="sxs-lookup"><span data-stu-id="d4dce-122">By scaling the monolithic design, all of the code is deployed multiple times.</span></span>

<span data-ttu-id="d4dce-123">除了"小数位数的所有内容"的问题，对单个组件的更改需要完成重新测试整个应用程序以及完成重新部署的所有实例。</span><span class="sxs-lookup"><span data-stu-id="d4dce-123">In addition to the "scale-everything" problem, changes to a single component require complete retesting of the entire application as well as a complete redeployment of all the instances.</span></span>

<span data-ttu-id="d4dce-124">整体方法很常见，并且许多组织正在开发使用此体系结构的方法。</span><span class="sxs-lookup"><span data-stu-id="d4dce-124">The monolithic approach is common, and many organizations are developing with this architectural method.</span></span> <span data-ttu-id="d4dce-125">许多不会有什么享受足够结果，而其他人会遇到限制。</span><span class="sxs-lookup"><span data-stu-id="d4dce-125">Many enjoy good enough results, whereas others encounter limits.</span></span> <span data-ttu-id="d4dce-126">许多设计其应用程序在此模型中，因为工具和基础结构已生成 SOAs，太困难，它们看不到需要-直到应用程序增长。</span><span class="sxs-lookup"><span data-stu-id="d4dce-126">Many designed their applications in this model because the tools and infrastructure were too difficult to build SOAs, and they didn't see the need—until the app grew.</span></span>

<span data-ttu-id="d4dce-127">从基础结构的角度看，每个服务器可以运行在同一主机内的很多应用程序和在图 4-2 中所示在你的资源使用情况中具有的效率到可接受的比率。</span><span class="sxs-lookup"><span data-stu-id="d4dce-127">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="d4dce-128">图 4-2: 运行多个应用程序/容器主机</span><span class="sxs-lookup"><span data-stu-id="d4dce-128">Figure 4-2: A host running multiple apps/containers</span></span>

<span data-ttu-id="d4dce-129">你可以通过使用每个实例的专用的 Vm 部署在 Azure 中的单一应用程序。</span><span class="sxs-lookup"><span data-stu-id="d4dce-129">You can deploy monolithic applications in Azure by using dedicated VMs for each instance.</span></span> <span data-ttu-id="d4dce-130">使用[Azure VM 缩放集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)，你可以轻松地扩展 Vm。</span><span class="sxs-lookup"><span data-stu-id="d4dce-130">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can scale the VMs easily.</span></span> <span data-ttu-id="d4dce-131">[Azure 应用程序服务](https://azure.microsoft.com/en-us/services/app-service/)可以运行的单一应用程序并轻松缩放而无需管理虚拟机的实例。</span><span class="sxs-lookup"><span data-stu-id="d4dce-131">[Azure App Services](https://azure.microsoft.com/en-us/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="d4dce-132">自 2016，Azure 应用程序服务就可以运行单一实例的 Docker 容器，以及，从而简化部署。</span><span class="sxs-lookup"><span data-stu-id="d4dce-132">Since 2016, Azure App Services can run single instances of Docker containers, as well, simplifying the deployment.</span></span> <span data-ttu-id="d4dce-133">并使用 Docker，可以部署一个单独的 VM 为 Docker 主机，并运行多个实例。</span><span class="sxs-lookup"><span data-stu-id="d4dce-133">And, using Docker, you can deploy a single VM as a Docker host and run multiple instances.</span></span> <span data-ttu-id="d4dce-134">使用 Azure 平衡器，在图 4-3 所示，你可以管理缩放。</span><span class="sxs-lookup"><span data-stu-id="d4dce-134">Using the Azure balancer, as illustrated in the Figure 4-3, you can manage scaling.</span></span>

![](./media/image3.png)

<span data-ttu-id="d4dce-135">图 4-3： 多个主机扩展单个的 Docker 应用程序的应用/容器</span><span class="sxs-lookup"><span data-stu-id="d4dce-135">Figure 4-3: Multiple hosts scaling-out a single Docker application apps/containers</span></span>

<span data-ttu-id="d4dce-136">你可以管理部署到各种主机通过传统部署技术。</span><span class="sxs-lookup"><span data-stu-id="d4dce-136">You can manage the deployment to the various hosts via traditional deployment techniques.</span></span> <span data-ttu-id="d4dce-137">你可以使用类似的命令来管理 Docker 主机`docker run`手动，通过如连续传送 (CD) 管道，我们介绍更高版本中此图书的自动化。</span><span class="sxs-lookup"><span data-stu-id="d4dce-137">You can manage Docker hosts by using commands like `docker run` manually, through automation such as Continuous Delivery (CD) pipelines, which we explain later in this e-book.</span></span>

## <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="d4dce-138">部署为容器的整体应用程序</span><span class="sxs-lookup"><span data-stu-id="d4dce-138">Monolithic application deployed as a container</span></span>

<span data-ttu-id="d4dce-139">没有为使用容器来管理整体部署的好处。</span><span class="sxs-lookup"><span data-stu-id="d4dce-139">There are benefits to using containers to manage monolithic deployments.</span></span> <span data-ttu-id="d4dce-140">缩放的容器实例是得更快比更容易地部署其他虚拟机。</span><span class="sxs-lookup"><span data-stu-id="d4dce-140">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="d4dce-141">虽然 VM 缩放集是一项强大功能来扩展 Vm，但这需要来承载你的 Docker 容器，它们需要时间来设置。</span><span class="sxs-lookup"><span data-stu-id="d4dce-141">Although VM Scale Sets are a great feature to scale VMs, which are required to host your Docker containers, they take time to set up.</span></span> <span data-ttu-id="d4dce-142">在部署为应用程序实例，该应用程序的配置管理 VM 的一部分。</span><span class="sxs-lookup"><span data-stu-id="d4dce-142">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="d4dce-143">部署更新，因为 Docker 映像是得相当快和高效的网络。</span><span class="sxs-lookup"><span data-stu-id="d4dce-143">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="d4dce-144">可以在相同的主机 Vn 1 实例，消除增加的成本导致更多虚拟机上设置 Vn 实例。</span><span class="sxs-lookup"><span data-stu-id="d4dce-144">The Vn instances can be set up on the same hosts as your Vn-1 instances, eliminating added costs resulting from additional VMs.</span></span> <span data-ttu-id="d4dce-145">Docker 映像通常情况下会以秒为单位，从而加快首次推出。</span><span class="sxs-lookup"><span data-stu-id="d4dce-145">Docker images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="d4dce-146">关闭的 Docker 实例非常简单，只需调用`docker stop`命令，通常少于一秒内完成。</span><span class="sxs-lookup"><span data-stu-id="d4dce-146">Tearing down a Docker instance is as easy as invoking the `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="d4dce-147">容器是本质上是不可变的设计使然，由于从不需要担心损坏 Vm，因为更新脚本忘记某些特定配置或磁盘上剩余的文件的帐户。</span><span class="sxs-lookup"><span data-stu-id="d4dce-147">Because containers are inherently immutable, by design, you never need to worry about corrupted VMs because an update script forgot to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="d4dce-148">尽管整体应用可以受益于 Docker，我们触摸上仅的好处的提示。</span><span class="sxs-lookup"><span data-stu-id="d4dce-148">Although monolithic apps can benefit from Docker, we're touching on only the tips of the benefits.</span></span> <span data-ttu-id="d4dce-149">使用管理各种实例和每个容器实例的生命周期的容器 orchestrators 部署来自管理容器的更大好处。</span><span class="sxs-lookup"><span data-stu-id="d4dce-149">The larger benefits of managing containers comes from deploying with container orchestrators that manage the various instances and life cycle of each container instance.</span></span> <span data-ttu-id="d4dce-150">中断此整体应用程序分解可以缩放、 开发和部署单独的子系统是微服务的领域你入口点。</span><span class="sxs-lookup"><span data-stu-id="d4dce-150">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-docker-container-app-to-azure-app-service"></a><span data-ttu-id="d4dce-151">单个的 Docker 容器应用程序发布到 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="d4dce-151">Publishing a single Docker container app to Azure App Service</span></span>

<span data-ttu-id="d4dce-152">或者因为你想要收到部署到 Azure 的容器的快速验证，或者在应用程序只需单个容器应用程序，Azure 应用程序服务提供提供可缩放的单容器服务的好办法。</span><span class="sxs-lookup"><span data-stu-id="d4dce-152">Either because you want to get a quick validation of a container deployed to Azure or because the app is simply a single-container app, Azure App Services provides a great way to provide scalable single-container services.</span></span>

<span data-ttu-id="d4dce-153">使用 Azure App Service 是直观和您能够快速安装和快速运行，因为它提供了很好 Git 集成，以获取你的代码，生成它在 Microsoft Visual Studio 中，直接将其部署到 Azure。</span><span class="sxs-lookup"><span data-stu-id="d4dce-153">Using Azure App Service is intuitive and you can get up and running quickly because it provides great Git integration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure.</span></span> <span data-ttu-id="d4dce-154">但是，传统上 （使用任何 Docker)，如果需要其他功能，框架或在应用程序服务中不受支持的依赖关系你需要以等待它之前 Azure 团队更新在 App Service 中的这些依赖项，或者切换到等其他服务Service Fabric、 云服务或甚至纯 Vm，对其具有进一步控制且可以为你的应用程序中安装所需的组件或框架。</span><span class="sxs-lookup"><span data-stu-id="d4dce-154">But, traditionally (with no Docker), if you needed other capabilities, frameworks, or dependencies that aren't supported in App Services, you needed to wait for it until the Azure team updates those dependencies in App Service or switched to other services like Service Fabric, Cloud Services, or even plain VMs, for which you have further control and can install a required component or framework for your application.</span></span>

<span data-ttu-id="d4dce-155">现在，但 （宣布 Microsoft Connect 2016 在 2016 年 11 月） 和图 4‑4 中所示，使用 Visual Studio 2017 时，在 Azure App Service 中的容器支持使你能够包含任何所需的应用程序环境中。</span><span class="sxs-lookup"><span data-stu-id="d4dce-155">Now, however, (announced at Microsoft Connect 2016 in November 2016) and as shown in Figure 4‑4, when using Visual Studio 2017, container support in Azure App Service gives you the ability to include whatever you want in your app environment.</span></span> <span data-ttu-id="d4dce-156">如果因为容器中运行，可添加到你的应用，依赖关系，将获得你 Dockerfile 或 Docker 映像中包括这些依赖关系的功能。</span><span class="sxs-lookup"><span data-stu-id="d4dce-156">If you added a dependency to your app, because you are running it in a container, you get the capability of including those dependencies in your Dockerfile or Docker image.</span></span>

![](./media/image4.png)

<span data-ttu-id="d4dce-157">图 4-4： 发布到 Azure App Service 从 Visual Studio 应用程序/容器的容器</span><span class="sxs-lookup"><span data-stu-id="d4dce-157">Figure 4-4: Publishing a container to Azure App Service from Visual Studio apps/containers</span></span>

<span data-ttu-id="d4dce-158">图 4-4 还显示发布流推送通过容器注册表中，可以是 Azure 容器注册表 （注册表附近你在 Azure 中的部署和保护的 Azure Active Directory 组和帐户） 或任何其他 Docker 注册表映像如 Docker Hub 或在本地注册表。</span><span class="sxs-lookup"><span data-stu-id="d4dce-158">Figure 4-4 also shows that the publish flow pushes an image through a Container Registry, which can be the Azure Container Registry (a registry near to your deployments in Azure and secured by Azure Active Directory groups and accounts) or any other Docker Registry like Docker Hub or on-premises registries.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="d4dce-159">[以前](常用的容器-设计-principles.md) [下一步] (state-and-data-in-docker-applications.md)</span><span class="sxs-lookup"><span data-stu-id="d4dce-159">[Previous] (common-container-design-principles.md) [Next] (state-and-data-in-docker-applications.md)</span></span>
