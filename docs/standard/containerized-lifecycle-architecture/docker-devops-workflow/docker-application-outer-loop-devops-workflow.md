---
title: "Docker 应用程序的外部循环 DevOps 工作流中的步骤"
description: "使用 Microsoft 平台和工具的容器化 Docker 应用程序的生命周期"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: fe51fc4b5026d17f0f9b93e7fd0dedde93ef4a3c
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/23/2017
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="baf2f-104">Docker 应用程序的外部循环 DevOps 工作流中的步骤</span><span class="sxs-lookup"><span data-stu-id="baf2f-104">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="baf2f-105">图 5-1 显示构成 DevOps 外部循环工作流的步骤的端到端描述。</span><span class="sxs-lookup"><span data-stu-id="baf2f-105">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![](./media/image1.png)

<span data-ttu-id="baf2f-106">使用 Microsoft tools Docker 应用程序的图 5-1: DevOps 外部循环工作流</span><span class="sxs-lookup"><span data-stu-id="baf2f-106">Figure 5-1: DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="baf2f-107">现在，让我们检查每个步骤中更多详细信息。</span><span class="sxs-lookup"><span data-stu-id="baf2f-107">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="baf2f-108">步骤 1： 内部循环开发工作流</span><span class="sxs-lookup"><span data-stu-id="baf2f-108">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="baf2f-109">第 4 章中的详细阐述此步骤，但简单概述一下，下面是其中外部循环开始时，开发人员将推送到源控件管理系统 （如 Git) 的代码启动 CI 管道操作的时刻。</span><span class="sxs-lookup"><span data-stu-id="baf2f-109">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-visual-studio-team-services-and-git"></a><span data-ttu-id="baf2f-110">步骤 2： 源代码管理集成和使用 Visual Studio Team Services 和 Git 管理</span><span class="sxs-lookup"><span data-stu-id="baf2f-110">Step 2: Source-Code Control integration and management with Visual Studio Team Services and Git</span></span>

<span data-ttu-id="baf2f-111">在此步骤中，你需要的版本控制系统，以收集来自不同的开发人员团队中的所有代码合并的版本。</span><span class="sxs-lookup"><span data-stu-id="baf2f-111">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="baf2f-112">即使源代码管理 (SCC) 和源代码管理可能看似秒性质周期的对大多数开发人员，在 DevOps 现实生活中创建 Docker 应用程序时，务必强调你必须提交与应用程序的 Docker 映像直接对全局 Docker 注册表 （如 Azure 容器注册表或 Docker Hub） 从开发人员的计算机。</span><span class="sxs-lookup"><span data-stu-id="baf2f-112">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it is critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="baf2f-113">相反，必须在全局生成或基于你的源代码存储库 （如 Git) 的 CI 管道仅在集成的源代码上创建发布和部署到生产环境的 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="baf2f-113">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that is being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="baf2f-114">他们自己的计算机中测试时，应仅由开发人员使用开发人员本身也由生成的本地映像。</span><span class="sxs-lookup"><span data-stu-id="baf2f-114">The local images generated by the developers themselves should be used just by the developers when testing within their own machines.</span></span> <span data-ttu-id="baf2f-115">这是非常关键能够 DevOps 管道 SCC 代码中激活的原因。</span><span class="sxs-lookup"><span data-stu-id="baf2f-115">This is why it is critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="baf2f-116">Visual Studio Team Services 和 Team Foundation Server 支持 Git 和 Team Foundation 版本控制。</span><span class="sxs-lookup"><span data-stu-id="baf2f-116">Visual Studio Team Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="baf2f-117">你可以选择它们，并使用它以端到端的 Microsoft 体验。</span><span class="sxs-lookup"><span data-stu-id="baf2f-117">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="baf2f-118">但是，还可以管理外部存储库 （如 GitHub、 本地 Git 存储库，或子版本号） 中的代码和仍将能够连接到它并获取 DevOps CI 管道作为起始点的代码。</span><span class="sxs-lookup"><span data-stu-id="baf2f-118">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-visual-studio-team-services-and-docker"></a><span data-ttu-id="baf2f-119">步骤 3： 生成、 CI 使用，请将集成，并测试使用 Visual Studio Team Services 和 Docker</span><span class="sxs-lookup"><span data-stu-id="baf2f-119">Step 3: Build, CI, Integrate, and Test with Visual Studio Team Services and Docker</span></span>

<span data-ttu-id="baf2f-120">CI 已成为一种标准现代软件测试和传递。</span><span class="sxs-lookup"><span data-stu-id="baf2f-120">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="baf2f-121">Docker 解决方案维护明显的开发和操作团队之间的问题。</span><span class="sxs-lookup"><span data-stu-id="baf2f-121">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="baf2f-122">Docker 映像的不可变性可确保内容具有开发、 测试 CI 使用，请通过和在生产中运行之间的可重复部署。</span><span class="sxs-lookup"><span data-stu-id="baf2f-122">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="baf2f-123">开发人员便携式计算机跨部署 docker 引擎并测试基础结构使容器可移植的环境。</span><span class="sxs-lookup"><span data-stu-id="baf2f-123">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="baf2f-124">此时，提交的正确代码中具有的版本控制系统后，你需要*生成服务*选取代码并运行全局生成和测试。</span><span class="sxs-lookup"><span data-stu-id="baf2f-124">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="baf2f-125">此步骤 （CI 使用，请生成，测试） 的内部工作流是关于你的生成服务器 (Visual Studio Team Services)，Docker 引擎和 Docker 注册表包含 （Git 等），你的代码存储库的 CI 管道构造。</span><span class="sxs-lookup"><span data-stu-id="baf2f-125">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Visual Studio Team Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="baf2f-126">你可以使用 Visual Studio Team Services 作为基础用于构建你的应用程序和设置 CI 管道，并且用于发布生成"项目"到"项目存储库，"下一步中说明。</span><span class="sxs-lookup"><span data-stu-id="baf2f-126">You can use Visual Studio Team Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="baf2f-127">对于部署，"最后一个项目"中使用 Docker 时要部署与你的应用程序或服务的 Docker 映像中嵌入它们。</span><span class="sxs-lookup"><span data-stu-id="baf2f-127">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="baf2f-128">这些映像都推送或发布到*Docker 注册表*（如你可以在 Azure 容器注册表中或一个公共如 Docker Hub 注册表，通常用于正式基映像的专用存储库）。</span><span class="sxs-lookup"><span data-stu-id="baf2f-128">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="baf2f-129">此处是一个基本概念： CI 管道都将启动的关闭通过 Git 等源代码管理存储库的提交。</span><span class="sxs-lookup"><span data-stu-id="baf2f-129">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="baf2f-130">提交将导致 Visual Studio Team Services 运行 Docker 容器中的生成作业，并在该作业成功完成，将 Docker 映像推送到 Docker 注册表中，在图 5-2 中所示。</span><span class="sxs-lookup"><span data-stu-id="baf2f-130">The commit will cause Visual Studio Team Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="baf2f-131">图 5-2： 所涉及的步骤在 CI 中</span><span class="sxs-lookup"><span data-stu-id="baf2f-131">Figure 5-2: The steps involved in CI</span></span>

<span data-ttu-id="baf2f-132">以下是使用 Docker 和 Visual Studio Team Services 的基本 CI 工作流步骤：</span><span class="sxs-lookup"><span data-stu-id="baf2f-132">Here are the basic CI workflow steps with Docker and Visual Studio Team Services:</span></span>

1.  <span data-ttu-id="baf2f-133">开发人员将提交推送到 SCC 存储库 （Git/Visual Studio Team Services、 GitHub 等）。</span><span class="sxs-lookup"><span data-stu-id="baf2f-133">The developer pushes a commit to an SCC repository (Git/Visual Studio Team Services, GitHub, etc.).</span></span>

2.  <span data-ttu-id="baf2f-134">如果你使用 Visual Studio Team Services 或 Git，CI 是内置的中,，这意味着很像在 Visual Studio Team Services 选中复选框一样简单。</span><span class="sxs-lookup"><span data-stu-id="baf2f-134">If you're using Visual Studio Team Services or Git, CI is built in, which means that it is as simple as selecting a check box in Visual Studio Team Services.</span></span> <span data-ttu-id="baf2f-135">如果你使用的外部 （例如 GitHub)、 SCC *webhook*将通知的更新的 Visual Studio Team Services 或推送到 Git/GitHub。</span><span class="sxs-lookup"><span data-stu-id="baf2f-135">If you're using an external SCC (like GitHub), a *webhook* will notify Visual Studio Team Services of the update or push to Git/GitHub.</span></span>

3.  <span data-ttu-id="baf2f-136">Visual Studio Team Services 中提取 SCC 存储库，包括 DockerFile 描述图像，以及应用程序和测试代码。</span><span class="sxs-lookup"><span data-stu-id="baf2f-136">Visual Studio Team Services pulls the SCC repository, including the DockerFile describing the image as well as the application and test code.</span></span>

4.  <span data-ttu-id="baf2f-137">Visual Studio Team Services 生成的 Docker 映像，并使用生成号对其进行标记。</span><span class="sxs-lookup"><span data-stu-id="baf2f-137">Visual Studio Team Services builds a Docker image and labels it with a build number.</span></span>

5.  <span data-ttu-id="baf2f-138">Visual Studio Team Services 实例化中预配 Docker 主机的 Docker 容器，并且运行的相应测试。</span><span class="sxs-lookup"><span data-stu-id="baf2f-138">Visual Studio Team Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6.  <span data-ttu-id="baf2f-139">如果测试成功，映像第一次重新标记为有意义的名称，以便你知道它是"blessed 的 build"(如"/ 1.0.0"或任何其他标签)，，然后推送到你的 Docker 注册表 （Docker Hub、 Azure 容器注册表、 DTR 等）</span><span class="sxs-lookup"><span data-stu-id="baf2f-139">If the tests are successful, the image is first relabeled to a meaningful name so that you know it is a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-visual-studio-team-services-and-the-docker-extension-for-visual-studio-team-services"></a><span data-ttu-id="baf2f-140">对 Visual Studio Team Services 实施 CI 管道使用 Visual Studio Team Services 和 Docker 扩展</span><span class="sxs-lookup"><span data-stu-id="baf2f-140">Implementing the CI pipeline with Visual Studio Team Services and the Docker extension for Visual Studio Team Services</span></span>

<span data-ttu-id="baf2f-141">[Visual Studio Team Services Docker 扩展](https://aka.ms/vstsdockerextension)向 CI 管道与其可以生成 Docker 图像、 Docker 图像推送到经过身份验证的 Docker 注册表、 运行 Docker 映像，或运行提供的其他操作添加任务Docker CLI。</span><span class="sxs-lookup"><span data-stu-id="baf2f-141">The [Visual Studio Team Services Docker extension](https://aka.ms/vstsdockerextension) adds a task to your CI pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="baf2f-142">它还添加了可用于生成、 推送和运行 multicontainer Docker 应用程序，或运行提供的 Docker Compose CLI 其他操作，在图 5-3 中所示的 Docker Compose 任务。</span><span class="sxs-lookup"><span data-stu-id="baf2f-142">It also adds a Docker Compose task that you can use to build, push, and run multicontainer Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![](./media/image3.png)

<span data-ttu-id="baf2f-143">图 5-3： 在 Visual Studio Team Services Docker CI 管道</span><span class="sxs-lookup"><span data-stu-id="baf2f-143">Figure 5-3: The Docker CI pipeline in Visual Studio Team Services</span></span>

<span data-ttu-id="baf2f-144">Docker 扩展可将服务终结点，用于 Docker 主机和容器或映像注册表。</span><span class="sxs-lookup"><span data-stu-id="baf2f-144">The Docker extension can use service endpoints for Docker hosts and for container or image registries.</span></span> <span data-ttu-id="baf2f-145">任务默认为使用本地 Docker 主机，如果可用 （这当前需要自定义 Visual Studio Team Services 代理）;否则，它们需要你提供 Docker 主机的连接。</span><span class="sxs-lookup"><span data-stu-id="baf2f-145">The tasks default to using a local Docker host if available (this currently requires a custom Visual Studio Team Services agent); otherwise, they require that you provide a Docker host connection.</span></span> <span data-ttu-id="baf2f-146">依赖于向 Docker 注册表，如推送一个映像，正在进行身份验证的操作要求你在注册表连接提供的 Docker。</span><span class="sxs-lookup"><span data-stu-id="baf2f-146">Actions that depend on being authenticated with a Docker registry, such as pushing an image, require that you provide a Docker registry connection.</span></span>

<span data-ttu-id="baf2f-147">Visual Studio Team Services Docker 扩展 Visual Studio Team Services 帐户中安装以下组件：</span><span class="sxs-lookup"><span data-stu-id="baf2f-147">The Visual Studio Team Services Docker extension installs the following components in your Visual Studio Team Services account:</span></span>

-   <span data-ttu-id="baf2f-148">用于连接到 Docker 注册表的服务终结点</span><span class="sxs-lookup"><span data-stu-id="baf2f-148">A service endpoint for connecting to a Docker registry</span></span>

-   <span data-ttu-id="baf2f-149">用于连接到 Docker 容器主机的服务终结点</span><span class="sxs-lookup"><span data-stu-id="baf2f-149">A service endpoint for connecting to a Docker Container Host</span></span>

-   <span data-ttu-id="baf2f-150">Docker 执行以下任务：</span><span class="sxs-lookup"><span data-stu-id="baf2f-150">A Docker task to do the following:</span></span>

-   <span data-ttu-id="baf2f-151">生成的映像</span><span class="sxs-lookup"><span data-stu-id="baf2f-151">Build an image</span></span>

-   <span data-ttu-id="baf2f-152">将图像或存储库推送到注册表</span><span class="sxs-lookup"><span data-stu-id="baf2f-152">Push an image or a repository to a registry</span></span>

-   <span data-ttu-id="baf2f-153">在容器中运行映像</span><span class="sxs-lookup"><span data-stu-id="baf2f-153">Run an image in a container</span></span>

-   <span data-ttu-id="baf2f-154">运行 Docker 命令</span><span class="sxs-lookup"><span data-stu-id="baf2f-154">Run a Docker command</span></span>

-   <span data-ttu-id="baf2f-155">Docker Compose 任务以运行 Docker Compose 命令</span><span class="sxs-lookup"><span data-stu-id="baf2f-155">A Docker Compose task to run a Docker Compose command</span></span>

<span data-ttu-id="baf2f-156">Visual Studio Team Services 这些任务中，生成 Linux Docker 主机/虚拟机在 Azure 中设置和你首选的 Docker 注册表 （Azure 容器注册表、 Docker Hub、 私有 Docker DTR 或任何其他 Docker 注册表） 你可以将组合在 Docker CI 管道非常一致的方式。</span><span class="sxs-lookup"><span data-stu-id="baf2f-156">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="baf2f-157">***要求：***</span><span class="sxs-lookup"><span data-stu-id="baf2f-157">***Requirements:***</span></span>

-   <span data-ttu-id="baf2f-158">Visual Studio Team Services，或对于本地安装，Team Foundation Server 2015 Update 3 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="baf2f-158">Visual Studio Team Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

-   <span data-ttu-id="baf2f-159">一种 Visual Studio Team Services 代理，它具有的 Docker 二进制文件。</span><span class="sxs-lookup"><span data-stu-id="baf2f-159">A Visual Studio Team Services agent that has the Docker binaries.</span></span>

<span data-ttu-id="baf2f-160">创建以下方法之一的简单办法是使用 Docker 运行基于 Visual Studio Team Services 代理 Docker 映像的容器。</span><span class="sxs-lookup"><span data-stu-id="baf2f-160">An easy way to create one of these is to use Docker to run a container based on the Visual Studio Team Services agent Docker image.</span></span>

<span data-ttu-id="baf2f-161">**详细信息** 用于读取有关将 Visual Studio Team Services Docker CI 的详细信息管道，若要查看演练，请访问以下站点：</span><span class="sxs-lookup"><span data-stu-id="baf2f-161">**More info** To read more about assembling a Visual Studio Team Services Docker CI pipeline and to view walkthroughs, visit the following sites:</span></span>

<span data-ttu-id="baf2f-162">Docker 容器形式运行 Visual Studio Team Services 代理： [https://hub.docker.com/r/ \ microsoft/vsts 代理 /](https://hub.docker.com/r/microsoft/vsts-agent/)</span><span class="sxs-lookup"><span data-stu-id="baf2f-162">Running a Visual Studio Team Services agent as a Docker container: [https://hub.docker.com/r/\ microsoft/vsts-agent/](https://hub.docker.com/r/microsoft/vsts-agent/)</span></span>

<span data-ttu-id="baf2f-163">VSTS Docker 扩展： <https://aka.ms/vstsdockerextension></span><span class="sxs-lookup"><span data-stu-id="baf2f-163">VSTS Docker extension: <https://aka.ms/vstsdockerextension></span></span>

<span data-ttu-id="baf2f-164">构建利用 Visual Studio Team Services 的.NET 核心 Linux Docker 映像： <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span><span class="sxs-lookup"><span data-stu-id="baf2f-164">Building .NET Core Linux Docker images with Visual Studio Team Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span></span>

<span data-ttu-id="baf2f-165">在生成的基于 Linux 的 Visual Studio 团队服务构建 Docker 支持机： <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span><span class="sxs-lookup"><span data-stu-id="baf2f-165">Building a Linux-based Visual Studio Team Service build machine with Docker support: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span></span>

### <a name="integrate-test-and-validate-multicontainer-docker-applications"></a><span data-ttu-id="baf2f-166">集成、 测试和验证 multicontainer Docker 应用程序</span><span class="sxs-lookup"><span data-stu-id="baf2f-166">Integrate, test, and validate multicontainer Docker applications</span></span>

<span data-ttu-id="baf2f-167">通常情况下，大多数 Docker 应用程序由多个容器，而不是单个容器组成。</span><span class="sxs-lookup"><span data-stu-id="baf2f-167">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="baf2f-168">一个很好示例是一个面向微服务的应用程序，您将对其具有每个微服务构成的一个容器。</span><span class="sxs-lookup"><span data-stu-id="baf2f-168">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="baf2f-169">但是，即使没有严格遵循了微服务方法模式，则很可能你 Docker 的应用程序将组成多个容器或服务。</span><span class="sxs-lookup"><span data-stu-id="baf2f-169">But, even without strictly following the microservices approach patterns, it is very probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="baf2f-170">因此，在生成 CI 管道中的应用程序容器之后, 你还需要部署、 集成和测试应用程序作为一个整体与其所有容器集成 Docker 主机中或甚至到你的容器都对该测试群集分发。</span><span class="sxs-lookup"><span data-stu-id="baf2f-170">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="baf2f-171">如果你使用的一台主机，则可以使用 Docker 命令，例如 docker-撰写可以生成和部署相关的容器，以测试和验证中的单个 VM 的 Docker 环境。</span><span class="sxs-lookup"><span data-stu-id="baf2f-171">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="baf2f-172">但是，如果你正在使用如 DC/OS、 Kubernetes，或 Docker Swarm 的 orchestrator 群集，则需要部署你通过不同的机制或 orchestrator，具体取决于你所选群集/计划程序的容器。</span><span class="sxs-lookup"><span data-stu-id="baf2f-172">But, if you are working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="baf2f-173">以下是几种类型的测试，你可以针对 Docker 容器运行：</span><span class="sxs-lookup"><span data-stu-id="baf2f-173">Following are several types of tests that you can run against Docker containers:</span></span>

-   <span data-ttu-id="baf2f-174">Docker 容器的单元测试</span><span class="sxs-lookup"><span data-stu-id="baf2f-174">Unit tests for Docker containers</span></span>

-   <span data-ttu-id="baf2f-175">测试又彼此相关的应用程序或微服务的组</span><span class="sxs-lookup"><span data-stu-id="baf2f-175">Testing groups of interrelated applications or microservices</span></span>

-   <span data-ttu-id="baf2f-176">在生产环境和"加那利"版本中测试</span><span class="sxs-lookup"><span data-stu-id="baf2f-176">Test in production and "canary" releases</span></span>

<span data-ttu-id="baf2f-177">重要的一点是，当运行时集成和功能测试，你必须运行从容器外部这些测试。</span><span class="sxs-lookup"><span data-stu-id="baf2f-177">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="baf2f-178">测试必须不定义和在部署时，容器内运行，因为容器基于应为那些你将部署到生产环境完全一样的静态图像。</span><span class="sxs-lookup"><span data-stu-id="baf2f-178">Tests must not be defined and run within the containers that you are deploying, because the containers are based on static images that should be exactly like those that you will be deploying into production.</span></span>

<span data-ttu-id="baf2f-179">测试更高级的方案，如测试多个群集 （群集、 过渡群集和生产群集测试） 时是非常可行选项是将映像发布到测试各种群集中的注册表。</span><span class="sxs-lookup"><span data-stu-id="baf2f-179">A very feasible option when testing more advanced scenarios like testing several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry to test in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="baf2f-180">将自定义应用程序的 Docker 映像推送到全局 Docker 注册表</span><span class="sxs-lookup"><span data-stu-id="baf2f-180">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="baf2f-181">测试和验证的 Docker 映像后，你将想要标记并将其发布到 Docker 注册表。</span><span class="sxs-lookup"><span data-stu-id="baf2f-181">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="baf2f-182">Docker 注册表在 Docker 应用程序生命周期中是一条关键，因为它是你在其中存储你自定义的测试 （也称为"blessed 映像"） 将其部署到 QA 和生产环境的中央位置。</span><span class="sxs-lookup"><span data-stu-id="baf2f-182">The Docker registry is a critical piece in the Docker application life cycle because it is the central place where you store your custom test (aka "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="baf2f-183">与如何在你的 SCC 存储库 （Git 等） 中存储的应用程序代码是你"资料来源"类似，Docker 注册表是你"资料来源"二进制应用程序或 bits 要部署到 QA 或生产环境。</span><span class="sxs-lookup"><span data-stu-id="baf2f-183">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="baf2f-184">通常情况下，你可能想要自定义映像的专用存储库在专用的存储库 Azure 容器注册表中或 Docker 受信任注册表，如本地注册表或公共云注册表项 （如限制访问权限Docker Hub)，尽管在此最后一个的情况下，如果你的代码不是开源，必须先信任供应商的安全。</span><span class="sxs-lookup"><span data-stu-id="baf2f-184">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="baf2f-185">无论哪种方式，依据你执行此操作的方法是十分相似并且最终基于 docker 推送命令，同时在图 5-4 中所示。</span><span class="sxs-lookup"><span data-stu-id="baf2f-185">Either way, the method by which you do this is pretty similar and ultimately based on the docker push command, as depicted in Figure 5-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="baf2f-186">图 5-4： 将自定义映像发布到 Docker 注册表</span><span class="sxs-lookup"><span data-stu-id="baf2f-186">Figure 5-4: Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="baf2f-187">不存在的 Docker 注册表，如 Azure 容器注册表、 Amazon Web Services 容器注册表、 Google 容器注册表、 Quay 注册表和等等的云供应商的多个产品。</span><span class="sxs-lookup"><span data-stu-id="baf2f-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="baf2f-188">使用 Visual Studio Team Services Docker 扩展，你可以在图 5-5 中所示推送服务映像由 docker-compose.yml 文件，使用多个标记，到经过身份验证的 Docker 注册表 （如 Azure 容器注册表中），定义一组。</span><span class="sxs-lookup"><span data-stu-id="baf2f-188">Using the Visual Studio Team Services Docker extension, you can push a set of service images defined by a docker-compose.yml file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![](./media/image5.png)

<span data-ttu-id="baf2f-189">图 5-5： 使用 Visual Studio Team Services 到发布到 Docker 注册表的自定义映像</span><span class="sxs-lookup"><span data-stu-id="baf2f-189">Figure 5-5: Using Visual Studio Team Services to publishing custom images to a Docker Registry</span></span>

<span data-ttu-id="baf2f-190">**详细信息** 以便阅读更多有关 Visual Studio Team Services Docker 扩展，请转到<https://aka.ms/vstsdockerextension>。</span><span class="sxs-lookup"><span data-stu-id="baf2f-190">**More info** To read more about the Docker extension for Visual Studio Team Services, go to <https://aka.ms/vstsdockerextension>.</span></span> <span data-ttu-id="baf2f-191">若要了解有关 Azure 容器注册表中的详细信息，请转到<https://aka.ms/azurecontainerregistry>。</span><span class="sxs-lookup"><span data-stu-id="baf2f-191">To learn more about Azure Container Registry, go to <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="baf2f-192">步骤 4: CD，部署</span><span class="sxs-lookup"><span data-stu-id="baf2f-192">Step 4: CD, Deploy</span></span>

<span data-ttu-id="baf2f-193">Docker 映像的不可变性可确保具有什么已开发、 测试通过 CI，并在生产中运行的可重复部署。</span><span class="sxs-lookup"><span data-stu-id="baf2f-193">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="baf2f-194">（专用或公用） 你 Docker 注册表中发布的应用程序 Docker 映像后，你可以将它们部署到可能具有多个环境 (生产、 QA、 过渡，等) 从使用 Visual Studio Team Services CD 管道管道任务或 Visual Studio Team Services Release Management。</span><span class="sxs-lookup"><span data-stu-id="baf2f-194">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Visual Studio Team Services pipeline tasks or Visual Studio Team Services Release Management.</span></span>

<span data-ttu-id="baf2f-195">但是，此时它依赖于要部署的 Docker 应用程序类型。</span><span class="sxs-lookup"><span data-stu-id="baf2f-195">However, at this point it depends on what kind of Docker application you are deploying.</span></span> <span data-ttu-id="baf2f-196">部署简单应用程序 （从组合和部署的角度来看） 如整体应用程序包含几个容器或服务及已部署到几个服务器或 Vm 是非常不同的部署更复杂的应用程序，如面向微服务的应用程序具有超大规模功能。</span><span class="sxs-lookup"><span data-stu-id="baf2f-196">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is very different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="baf2f-197">下列部分中解释了这两个方案。</span><span class="sxs-lookup"><span data-stu-id="baf2f-197">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="baf2f-198">部署组成 Docker 应用程序到多个 Docker 环境</span><span class="sxs-lookup"><span data-stu-id="baf2f-198">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="baf2f-199">让我们应当首先查看不太复杂方案： 将部署到单个环境或多个环境中的简单 Docker 主机 （Vm 或服务器） (QA、 过渡和生产)。</span><span class="sxs-lookup"><span data-stu-id="baf2f-199">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="baf2f-200">在此方案中，内部 CD 管道可以使用 docker-撰写 （从你的 Visual Studio Team Services 部署任务） 部署的 Docker 应用程序使用其相关的一组的容器或服务，如图 5-6 中所示。</span><span class="sxs-lookup"><span data-stu-id="baf2f-200">In this scenario, internally your CD pipeline can use docker-compose (from your Visual Studio Team Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![](./media/image6.png)

<span data-ttu-id="baf2f-201">图 5-6： 将应用程序容器部署到简单 Docker 主机环境注册表</span><span class="sxs-lookup"><span data-stu-id="baf2f-201">Figure 5-6: Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="baf2f-202">图 5-7 突出显示了如何连接生成 CI 到 QA/测试环境，通过 Visual Studio Team Services 通过单击添加任务对话框中的 Docker Compose。</span><span class="sxs-lookup"><span data-stu-id="baf2f-202">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Visual Studio Team Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="baf2f-203">但是，在部署到过渡环境或生产环境，你通常将处理多个环境版本管理功能 (如 QA、 过渡和生产)。</span><span class="sxs-lookup"><span data-stu-id="baf2f-203">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="baf2f-204">如果你正在将部署到单个 Docker 主机，它使用 Visual Studio Team Services"Docker Compose"任务 (这调用 docker-撰写实质上的命令)。</span><span class="sxs-lookup"><span data-stu-id="baf2f-204">If you're deploying to single Docker hosts, it is using the Visual Studio Team Services "Docker Compose" task (which is invoking the docker-compose up command under the hood).</span></span> <span data-ttu-id="baf2f-205">如果你正在将部署到 Azure 容器服务，它使用 Docker 部署任务，如上一节中所述。</span><span class="sxs-lookup"><span data-stu-id="baf2f-205">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![](./media/image7.png)

<span data-ttu-id="baf2f-206">图 5-7： 在 Visual Studio Team Services 管道中添加 Docker Compose 任务</span><span class="sxs-lookup"><span data-stu-id="baf2f-206">Figure 5-7: Adding a Docker Compose task in a Visual Studio Team Services pipeline</span></span>

<span data-ttu-id="baf2f-207">当你在 Visual Studio Team Services 中创建发布时，它将使用输入项目的一组。</span><span class="sxs-lookup"><span data-stu-id="baf2f-207">When you create a release in Visual Studio Team Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="baf2f-208">这些重载可以跨多个环境的整个生存期内版本不可变。</span><span class="sxs-lookup"><span data-stu-id="baf2f-208">These are intended to be immutable throughout the lifetime of the release across multiple environments.</span></span> <span data-ttu-id="baf2f-209">在引入容器时，输入的项目标识部署的注册表中的映像。</span><span class="sxs-lookup"><span data-stu-id="baf2f-209">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="baf2f-210">具体取决于这些标识过程，它们不保证都保持不变，则整个版本，最明显的情况下，正在从 docker-compose 文件引用"myimage:latest"时的持续时间。</span><span class="sxs-lookup"><span data-stu-id="baf2f-210">Depending on how these are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference "myimage:latest" from a docker-compose file.</span></span>

<span data-ttu-id="baf2f-211">用于 Visual Studio Team Services 的 Docker 扩展使您生成包含特定的注册表的映像的生成项目的功能摘要，可保证能唯一标识相同的二进制映像。</span><span class="sxs-lookup"><span data-stu-id="baf2f-211">The Docker extension for Visual Studio Team Services gives you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="baf2f-212">这些是你确实要用作输入的发行版。</span><span class="sxs-lookup"><span data-stu-id="baf2f-212">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-visual-studio-team-services-release-management"></a><span data-ttu-id="baf2f-213">使用 Visual Studio Team Services Release Management 管理发布到 Docker 环境</span><span class="sxs-lookup"><span data-stu-id="baf2f-213">Managing releases to Docker environments by using Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="baf2f-214">通过 Visual Studio Team Services 扩展中，你可以生成新映像、 将其发布到 Docker 注册表、 运行 Linux 或 Windows 主机上并使用如 docker 命令的撰写将多个容器部署为整个应用程序，通过该视觉对象Studio 团队服务版本管理功能，适用于多个环境，如图 5-8 所示。</span><span class="sxs-lookup"><span data-stu-id="baf2f-214">Through the Visual Studio Team Services extensions, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as docker-compose to deploy multiple containers as an entire application, all through the Visual Studio Team Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![](./media/image8.png)

<span data-ttu-id="baf2f-215">图 5-8： 配置 Visual Studio Team Services Docker Compose 任务从 Visual Studio Team Services Release Management</span><span class="sxs-lookup"><span data-stu-id="baf2f-215">Figure 5-8: Configuring Visual Studio Team Services Docker Compose tasks from Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="baf2f-216">但是，请记住，显示在图 5-6 中和实现图 5-8 的方案是相当基本的 （它部署到简单 Docker 主机和虚拟机，并且会有单个容器或每个图像的实例），可能仅应该用于开发或测试 scenarios。</span><span class="sxs-lookup"><span data-stu-id="baf2f-216">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is pretty basic (it is deploying to simple Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="baf2f-217">在大多数企业生产方案中，你将想要高可用性 (HA)，并且轻松管理负载平衡跨多个节点、 服务器和虚拟机，以及"智能故障转移"因此，如果服务器或节点的可伸缩性失败，其服务和容器将移到另一个主机服务器或 VM。</span><span class="sxs-lookup"><span data-stu-id="baf2f-217">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so that if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="baf2f-218">在这种情况下，你需要更高级的技术，如容器群集、 orchestrators 和计划程序。</span><span class="sxs-lookup"><span data-stu-id="baf2f-218">In that case, you need more advanced technologies like container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="baf2f-219">因此，将部署到这些群集的方法是精确地通过在下一部分中所述的高级方案。</span><span class="sxs-lookup"><span data-stu-id="baf2f-219">Thus, the way to deploy to those clusters is precisely through the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-complex-docker-applications-to-docker-clusters-dcos-kubernetes-and-docker-swarm"></a><span data-ttu-id="baf2f-220">部署到 Docker 群集 （DC/OS、 Kubernetes，和 Docker Swarm） 的复杂 Docker 应用程序</span><span class="sxs-lookup"><span data-stu-id="baf2f-220">Deploying complex Docker applications to Docker clusters (DC/OS, Kubernetes, and Docker Swarm)</span></span>

<span data-ttu-id="baf2f-221">性质的分布式应用程序需要，还将分散的计算资源。</span><span class="sxs-lookup"><span data-stu-id="baf2f-221">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="baf2f-222">若要进行生产缩放功能，你需要具有群集提供高度可缩放性的功能和 HA 基于共用资源。</span><span class="sxs-lookup"><span data-stu-id="baf2f-222">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and HA based on pooled resources.</span></span>

<span data-ttu-id="baf2f-223">你无法容器手动部署到这些群集从 Docker Swarm 之类的 CLI 工具 (如使用[docker 服务创建](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) 或 web UI 如[Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html)为 DC/OS 群集，但你应仅用于测试 punctual 部署或管理目的，如向外缩放或监视的目的，请保留的。</span><span class="sxs-lookup"><span data-stu-id="baf2f-223">You could deploy containers manually to those clusters from a CLI tool such as Docker Swarm (like using [docker service create](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) or a web UI such as [Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) for DC/OS clusters, but you should reserve that only for punctual deployment testing or for management purposes like scaling-out or monitoring purposes.</span></span>

<span data-ttu-id="baf2f-224">从 CD 的角度来看，Visual Studio Team Services 具体而言，你可以运行和专门发出的部署任务从你的 Visual Studio Team Services Release Management 环境将部署到分布式群集，在你容器化应用程序容器服务，如图 5-9 中所示。</span><span class="sxs-lookup"><span data-stu-id="baf2f-224">From a CD point of view, and Visual Studio Team Services specifically, you can run specially made deployment tasks from your Visual Studio Team Services Release Management environments which will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![](./media/image9.png)

<span data-ttu-id="baf2f-225">图 5-9： 部署到容器服务的分布式应用程序</span><span class="sxs-lookup"><span data-stu-id="baf2f-225">Figure 5-9: Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="baf2f-226">最初，在部署到特定的群集或 orchestrators 时，你会传统上使用特定的部署脚本和每个每个 orchestrator （即，Mesosphere DC/OS 或 Kubernetes 具有不同的部署机制比 Docker 和 Docker 的机制Swarm) 而不是更简单且易于使用 docker-撰写基于 docker-compose.yml 定义文件的工具。</span><span class="sxs-lookup"><span data-stu-id="baf2f-226">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Mesosphere DC/OS or Kubernetes have different deployment mechanisms than Docker and Docker Swarm) instead of the simpler and easy-to-use docker-compose tool based on the docker-compose.yml definition file.</span></span> <span data-ttu-id="baf2f-227">但是，Microsoft Visual Studio Team Services Docker 部署任务，如图 5-10 示感谢你现在还可以向部署 DC/OS 只需使用你熟悉 docker-compose.yml 文件，因为 Microsoft 为您执行该"翻译"(从你docker-compose.yml 文件为所需的 DC/OS 其他格式）。</span><span class="sxs-lookup"><span data-stu-id="baf2f-227">However, thanks to the Microsoft Visual Studio Team Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to DC/OS by just using your familiar docker-compose.yml file because Microsoft performs that "translation" for you (from your docker-compose.yml file to other formats needed by DC/OS).</span></span>

![](./media/image10.png)

<span data-ttu-id="baf2f-228">图 5-10: Docker 部署任务添加到你的环境 RM</span><span class="sxs-lookup"><span data-stu-id="baf2f-228">Figure 5-10: Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="baf2f-229">图 5-11 演示如何编辑 Docker 部署任务和指定目标类型 （Azure 容器服务 DC/操作系统，在此情况下）、 Docker Compose 文件和 Docker 注册表连接 （如 Azure 容器注册表或 Docker Hub）。</span><span class="sxs-lookup"><span data-stu-id="baf2f-229">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="baf2f-230">这是该任务将在其中检索准备就绪，可以使用自定义 Docker 映像若要部署为 DC/OS 群集中的容器。</span><span class="sxs-lookup"><span data-stu-id="baf2f-230">This is where the task will retrieve your ready-to-use custom Docker images to be deployed as containers in the DC/OS cluster.</span></span>

![](./media/image11.png)

<span data-ttu-id="baf2f-231">图 5-11: Docker 部署任务定义部署 Azure 容器服务 DC/OS 到</span><span class="sxs-lookup"><span data-stu-id="baf2f-231">Figure 5-11: Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

<span data-ttu-id="baf2f-232">**详细信息** 以便阅读更多有关使用 Visual Studio Team Services 和 Docker CD 管道，请访问以下站点：</span><span class="sxs-lookup"><span data-stu-id="baf2f-232">**More info** To read more about the CD pipeline with Visual Studio Team Services and Docker, visit the following sites:</span></span>

<span data-ttu-id="baf2f-233">Docker 和 Azure 容器服务的 visual Studio Team Services 扩展： [https://aka.ms/ \ vstsdockerextension](https://aka.ms/vstsdockerextension)</span><span class="sxs-lookup"><span data-stu-id="baf2f-233">Visual Studio Team Services extension for Docker and Azure Container Service: [https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span></span>

<span data-ttu-id="baf2f-234">Azure 容器服务： <https://aka.ms/azurecontainerservice></span><span class="sxs-lookup"><span data-stu-id="baf2f-234">Azure Container Service: <https://aka.ms/azurecontainerservice></span></span>

<span data-ttu-id="baf2f-235">Mesosphere DC/OS: <https://mesosphere.com/product/></span><span class="sxs-lookup"><span data-stu-id="baf2f-235">Mesosphere DC/OS: <https://mesosphere.com/product/></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="baf2f-236">步骤 5： 运行和管理</span><span class="sxs-lookup"><span data-stu-id="baf2f-236">Step 5: Run and manage</span></span>

<span data-ttu-id="baf2f-237">因为运行和管理应用程序在企业生产级别是主要使用者中和自身，以及由于的操作类型，而在该级别 （IT 运营） 以及此区域的大范围的人员，我们具有专门用于整个下一步解释它的章节。</span><span class="sxs-lookup"><span data-stu-id="baf2f-237">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, we have devoted the entire next chapter to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="baf2f-238">步骤 6： 监视和诊断</span><span class="sxs-lookup"><span data-stu-id="baf2f-238">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="baf2f-239">本主题还介绍了在下一章中的 IT 运营执行生产系统; 中的任务的一部分但是，务必突出显示，以便不断改进应用程序在此步骤中获得的见解必须源回开发团队。</span><span class="sxs-lookup"><span data-stu-id="baf2f-239">This topic also is covered in the next chapter as part of the tasks that IT operations performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="baf2f-240">从该角度来看，它也是的一部分 DevOps，尽管通常执行的任务和操作 IT。</span><span class="sxs-lookup"><span data-stu-id="baf2f-240">From that point of view, it is also part of DevOps, although the tasks and operations are usually performed by IT.</span></span>

<span data-ttu-id="baf2f-241">仅当时监视和诊断中的 DevOps 领域的 100%被监视的进程和由开发团队针对测试或 beta 环境执行的分析。</span><span class="sxs-lookup"><span data-stu-id="baf2f-241">Only when monitoring and diagnostics are 100 percent within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="baf2f-242">通过执行负载测试或只需通过监视 beta 或 QA 环境，beta 测试人员要新版本，则是完成此操作。</span><span class="sxs-lookup"><span data-stu-id="baf2f-242">This is done either by performing load testing or simply by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="baf2f-243">[以前](index.md) [下一步] (.../run-manage-monitor-docker-environments/index.md)</span><span class="sxs-lookup"><span data-stu-id="baf2f-243">[Previous] (index.md) [Next] (../run-manage-monitor-docker-environments/index.md)</span></span>
