---
title: "垃圾回收的基本知识"
description: "垃圾回收的基本知识"
keywords: ".NET、.NET Core"
author: stevehoag
ms.author: shoag
ms.date: 08/16/2016
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: 9d5fce64-95a4-4609-8eee-b0ac70078cdb
translationtype: Human Translation
ms.sourcegitcommit: 90fe68f7f3c4b46502b5d3770b1a2d57c6af748a
ms.openlocfilehash: 02b0311559071147b38182076f60918b7351cc63
ms.lasthandoff: 03/02/2017


---

# <a name="fundamentals-of-garbage-collection"></a>垃圾回收的基本知识

在公共语言运行时 (CLR) 中，垃圾回收器用作自动内存管理器。 它提供如下优点：

* 使你可以在开发应用程序时不必释放内存。 

* 有效分配托管堆上的对象。 

* 回收不再使用的对象，清除它们的内存，并保留内存以用于将来分配。 托管对象会自动获取干净的内容来开始，因此，它们的构造函数不必对每个数据字段进行初始化。

* 通过确保对象不能使用另一个对象的内容来提供内存安全。


本主题介绍垃圾回收的核心概念。 它包含下列部分：

* [内存基础知识](#fundamentals-of-memory)

* [垃圾回收的条件](#conditions-for-a-garbage-collection)

* [托管堆](#the-managed-heap)

* [代数](#generations)

* [垃圾回收过程中发生的情况](#what-happens-during-a-garbage-collection)

* [操作非托管资源](#manipulating-unmanaged-resources)

## <a name="fundamentals-of-memory"></a>内存基础知识

下面的列表总结了重要的 CLR 内存概念。

* 每个进程都有其自己单独的虚拟地址空间。 同一台计算机上的所有进程共享相同的物理内存，如果有页文件，则也共享页文件。

* 默认情况下，32 位计算机上的每个进程都具有 2 GB 的用户模式虚拟地址空间。

* 作为一名应用程序开发人员，你只能使用虚拟地址空间，请勿直接操控物理内存。 垃圾回收器为你分配和释放托管堆上的虚拟内存。

* 虚拟内存有三种状态： 

    * 可用。 该内存块没有引用关系，可用于分配。

    * 保留。 内存块可供你使用，并且不能用于任何其他分配请求。 但是，在该内存块提交之前，你无法将数据存储到其中。 

    * 提交。 内存块已指派给物理存储。

* 可能会存在虚拟地址空间碎片。 就是说地址空间中存在一些被称为孔的可用块。 当请求虚拟内存分配时，虚拟内存管理器必须找到满足该分配请求的足够大的单个可用块。 即使你具有 2 GB 的可用空间，2 GB 的分配请求也有可能会不成功，除非所有这些空间必须位于单个的地址块中。

* 如果用完保留的虚拟地址空间或提交的物理空间，则可能会用尽内存。

即使在物理内存压力（即物理内存的需求）较低的情况下也会使用页文件。 首次出现物理内存压力较高的情况时，操作系统必须在物理内存中腾出空间来存储数据，并将物理内存中的部分数据备份到页文件中。 该数据只会在需要时进行分页，所以在物理内存压力非常低的情况下也可能会进行分页。

## <a name="conditions-for-a-garbage-collection"></a>垃圾回收的条件

当满足以下条件之一时将发生垃圾回收：

* 系统具有低的物理内存。

* 由托管堆上已分配的对象使用的内存超出了可接受的阈值。 随着进程的运行，此阈值会不断地进行调整。

* 调用了 [GC.Collect](xref:System.GC.Collect) 方法。 几乎在所有情况下，你都不必调用此方法，因为垃圾回收器会持续运行。 此方法主要用于特殊情况和测试。 

## <a name="the-managed-heap"></a>托管堆

在垃圾回收器由 CLR 初始化之后，它会分配一段内存用于存储和管理对象。 此内存称为托管堆（与操作系统中的本机堆相对）。 

每个托管进程都有一个托管堆。 进程中的所有线程都在同一堆上分配对象记忆。

> [!IMPORTANT]
> 垃圾回收器分配的段大小特定于实现，并且随时可能更改（包括定期更新）。 应用程序不应假设特定段的大小或依赖于此大小，也不应尝试配置段分配可用的内存量。 
 
堆上分配的对象越少，垃圾回收器必须执行的工作就越少。 分配对象时，请勿使用超出你需求的舍入值，例如在仅需要 15 个字节的情况下分配了 32 个字节的数组。 

当触发垃圾回收时，垃圾回收器将回收由死对象占用的内存。 回收进程会对活动对象进行压缩，以便将它们一起移动，并移除死空间，从而使堆更小一些。 这将确保一起分配的对象全都位于托管堆上，从而保留它们的局部性。

垃圾回收的侵入性（频率和持续时间）是由分配的数量和托管堆上保留的内存数量决定的。 

此堆可视为两个堆的累计：大对象堆和小对象堆。 

大对象堆包含其大小为 85,000 个字节和更多字节的对象。 大对象堆上的对象通常是数组。 非常大的实例对象是很少见的。 

## <a name="generations"></a>代数

堆按代进行组织，因此它可以处理长生存期的对象和短生存期的对象。 垃圾回收主要在回收通常只占用一小部分堆的短生存期对象时发生。 堆上的对象有三代： 

* **第 0 代。** 这是最年轻的代，其中包含短生存期对象。 短生存期对象的一个示例是临时变量。 垃圾回收最常发生在此代中。 

  新分配的对象构成新一代的对象并且为隐式的第 0 代回收，除非它们是大对象，在这种情况下，它们将进入第 2 代回收中的大对象堆。

  大多数对象通过第 0 代中的垃圾回收进行回收，不会保留到下一代。 

* **第 1 代。** 这一代包含短生存期对象并用作短生存期对象和长生存期对象之间的缓冲区。 

* **第 2 代。** 这一代包含长生存期对象。 长生存期对象的一个示例是服务器应用程序中的一个包含在进程期间处于活动状态的静态数据的对象。

当条件得到满足时，垃圾回收将在特定代上发生。 回收某个代意味着回收此代中的对象及其所有更年轻的代。 第 2 代垃圾回收也称为完整垃圾回收，因为它回收所有代上的所有对象（即，托管堆中的所有对象）。

### <a name="survival-and-promotions"></a>幸存和提升

垃圾回收中未回收的对象也称为幸存者，并会被提升到下一代。 在第 0 代垃圾回收中幸存的对象将被提升到第 1 代；在第 1 代垃圾回收中幸存的对象将被提升到第 2 代；而在第 2 代垃圾回收中幸存的对象将仍为第 2 代。

当垃圾回收器检测到某个代中的幸存率很高时，它会增加该代的分配阈值，因此下一次回收将会获取一个非常大的回收内存。 CLR 会在以下两个优先级别之前进行平衡：不允许应用程序的工作集获取太大内存以及不允许垃圾回收花费太多时间。

### <a name="ephemeral-generations-and-segments"></a>暂时代和暂时段

因为第 0 代和第 1 代中的对象的生存期较短，因此，这些代被称为暂时代。 

暂时代必须在称为暂时段的内存段中进行分配。 垃圾回收器获取的每个新段将成为新的暂时段，并包含在第 0 代垃圾回收中幸存的对象。 旧的暂时段将成为新的第 2 代段。 


暂时段可以包含第 2 代对象。 第 2 代对象可使用多个段（在内存允许的情况下进程所需的任意数量）。 

从暂时垃圾回收中释放的内存量限制为暂时段的大小。 释放的内存量与死对象占用的空间成比例。

## <a name="what-happens-during-a-garbage-collection"></a>垃圾回收过程中发生的情况

垃圾回收分为以下几个阶段： 

* 标记阶段，找到并创建所有活动对象的列表。

* 重定位阶段，用于更新对将要压缩的对象的引用。 

* 压缩阶段，用于回收由死对象占用的空间，并压缩幸存的对象。 压缩阶段将垃圾回收中幸存下来的对象移至段中时间较早的一端。 

因为第 2 代回收可以占用多个段，所以可以将已提升到第 2 代中的对象移动到时间较早的段中。 可以将第 1 代幸存者和第 2 代幸存者都移动到不同的段，因为它们已被提升到第 2 代。 

通常，由于复制大型对象会造成性能代偿，因此不会压缩大型对象堆。 但是，可使用 [GCSettings.LargeObjectHeapCompactionMode](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode) 属性按需压缩大型对象堆。 

垃圾回收器使用以下信息来确定对象是否为活动对象： 

* **堆栈根。** 由实时 (JIT) 编译器和堆栈查看器提供的堆栈变量。

* **垃圾回收句柄。** 指向托管对象且可由用户代码或公共语言运行时分配的句柄。

* **静态数据。** 应用程序域中可能引用其他对象的静态对象。 每个应用程序域都会跟踪其静态对象。

在垃圾回收启动之前，除了触发垃圾回收的线程以外的所有托管线程均会挂起。

下图演示了触发垃圾回收并导致其他线程挂起的线程。

![当线程触发垃圾回收时](./media/fundamentals/393001.png)

触发垃圾回收的线程

## <a name="manipulating-unmanaged-resources"></a>操作非托管资源

如果你的托管对象使用非托管对象的本机文件句柄来引用非托管对象，则必须显式释放非托管对象，因为垃圾回收器仅跟踪托管堆上的内存。

托管对象的用户可能不会释放由该对象使用的本机资源。 为了执行清理，可以使托管对象成为可终结的。 终结由不再使用对象时执行的清理操作组成。 当托管对象不活动时，它将执行在其终结器方法中指定的清理操作。

当发现某个可终结对象处于不活动状态时，则会将其终结器放入队列中，以便执行其清理操作，但要将该对象自身提升到下一代。 因此，你必须等待该代上发生下一次垃圾回收（并不一定是下一次垃圾回收），以确定对象是否已收回。

## <a name="see-also"></a>另请参阅

[.NET 中的垃圾回收](gc.md)




<!--HONumber=Nov16_HO3-->



