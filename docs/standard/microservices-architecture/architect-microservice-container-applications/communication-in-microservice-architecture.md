---
title: "在微服务体系结构的通信"
description: "为容器化的.NET 应用程序的.NET 微服务体系结构 |微服务体系结构体系结构中的通信"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 8d38095a151b7568619b17340d768eff684d3271
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/22/2017
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="08f3a-104">在微服务体系结构的通信</span><span class="sxs-lookup"><span data-stu-id="08f3a-104">Communication in a microservice architecture</span></span>

<span data-ttu-id="08f3a-105">在单个进程上运行的整体应用程序，在组件调用另一个使用语言级别方法或函数调用一样。</span><span class="sxs-lookup"><span data-stu-id="08f3a-105">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="08f3a-106">这些也可以紧密耦合，如果你要创建对象，与代码 (例如， `new ClassName()`)，或如果你使用的依赖关系注入通过引用抽象，而不是具体的对象实例可以在去耦方法中调用。</span><span class="sxs-lookup"><span data-stu-id="08f3a-106">These can be strongly coupled if you are creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you are using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="08f3a-107">两种方式的同一进程中运行的对象。</span><span class="sxs-lookup"><span data-stu-id="08f3a-107">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="08f3a-108">从到基于微服务的应用程序的整体应用程序版本更改时的最大挑战在于于更改的通信机制。</span><span class="sxs-lookup"><span data-stu-id="08f3a-108">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="08f3a-109">从过程中方法调用转换为对服务的 RPC 调用的直接转换将导致聊天式并且将不会执行中的不有效通信分布式环境。</span><span class="sxs-lookup"><span data-stu-id="08f3a-109">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that will not perform well in distributed environments.</span></span> <span data-ttu-id="08f3a-110">很好地为偶数称为 canon 已知的正确设计分布式的系统的挑战[的分布式计算 fallacies](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) ，它列出在开发人员通常提出从移动时的假设整体分布式设计。</span><span class="sxs-lookup"><span data-stu-id="08f3a-110">The challenges of designing distributed system properly are well enough known that there is even a canon known as the [The fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="08f3a-111">没有不一个解决方案中，但几个。</span><span class="sxs-lookup"><span data-stu-id="08f3a-111">There is not one solution, but several.</span></span> <span data-ttu-id="08f3a-112">一个解决方案涉及隔离尽可能多地业务微服务。</span><span class="sxs-lookup"><span data-stu-id="08f3a-112">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="08f3a-113">然后，你将使用内部微服务之间进行异步通信并替代细化通常会在进程内通信中使用较粗粒度的通信的对象之间的通信。</span><span class="sxs-lookup"><span data-stu-id="08f3a-113">You then use asynchronous communication between the internal microservices and replace fine-grained communication that is typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="08f3a-114">通过分组调用，并返回聚合结果的多个内部调用，客户端的数据时，可以执行此操作。</span><span class="sxs-lookup"><span data-stu-id="08f3a-114">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="08f3a-115">基于微服务的应用程序是在多个进程或服务，通常甚至跨多个服务器或主机上运行的分布式的系统。</span><span class="sxs-lookup"><span data-stu-id="08f3a-115">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="08f3a-116">每个服务实例通常是一个过程。</span><span class="sxs-lookup"><span data-stu-id="08f3a-116">Each service instance is typically a process.</span></span> <span data-ttu-id="08f3a-117">因此，使用进程间通信协议，如 HTTP、 AMQP 或如 TCP，具体取决于每个服务的性质的二进制协议服务必须进行交互。</span><span class="sxs-lookup"><span data-stu-id="08f3a-117">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="08f3a-118">Microservice 社区提升这一理念"[智能终结点和笨拙管道](http://simplicable.com/new/smart-endpoints-and-dumb-pipes)。"</span><span class="sxs-lookup"><span data-stu-id="08f3a-118">The microservice community promotes the philosophy of “[smart endpoints and dumb pipes](http://simplicable.com/new/smart-endpoints-and-dumb-pipes).”</span></span> <span data-ttu-id="08f3a-119">此广告语鼓励为分离尽可能之间微服务，并尽可能在单个 microservice 好地设计。</span><span class="sxs-lookup"><span data-stu-id="08f3a-119">This slogan encourages a design that is as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="08f3a-120">如前面所述，每个微服务将拥有其自己的数据和它自己域的逻辑。</span><span class="sxs-lookup"><span data-stu-id="08f3a-120">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="08f3a-121">但微服务组成的端到端应用程序通常只通过使用 REST 通信，而不是复杂的协议，如 WS-choreographed\*的灵活事件驱动的通信，而不是集中式业务流程 orchestrators。</span><span class="sxs-lookup"><span data-stu-id="08f3a-121">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="08f3a-122">两个常用的协议为 HTTP 请求/响应与资源 Api （查询其中的绝大部分） 时，并跨多个微服务轻型异步消息传送通信时更新。</span><span class="sxs-lookup"><span data-stu-id="08f3a-122">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="08f3a-123">下列部分中的更详细地对它们进行了解释。</span><span class="sxs-lookup"><span data-stu-id="08f3a-123">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="08f3a-124">通信类型</span><span class="sxs-lookup"><span data-stu-id="08f3a-124">Communication types</span></span>

<span data-ttu-id="08f3a-125">客户端和服务可以通过许多不同类型的通信，每个面向不同的方案和目标进行通信。</span><span class="sxs-lookup"><span data-stu-id="08f3a-125">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="08f3a-126">最初，这些类型的通信可以分为两个轴。</span><span class="sxs-lookup"><span data-stu-id="08f3a-126">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="08f3a-127">如果协议是同步还是异步定义的第一个轴：</span><span class="sxs-lookup"><span data-stu-id="08f3a-127">The first axis is defining if the protocol is synchronous or asynchronous:</span></span>

-   <span data-ttu-id="08f3a-128">同步的协议。</span><span class="sxs-lookup"><span data-stu-id="08f3a-128">Synchronous protocol.</span></span> <span data-ttu-id="08f3a-129">HTTP 是同步的协议。</span><span class="sxs-lookup"><span data-stu-id="08f3a-129">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="08f3a-130">客户端发送一个请求，并等待从服务响应。</span><span class="sxs-lookup"><span data-stu-id="08f3a-130">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="08f3a-131">这是独立于客户端代码执行可同步 （线程被阻止） 或异步 （线程不会被阻止，和响应将最终到达回调）。</span><span class="sxs-lookup"><span data-stu-id="08f3a-131">That is independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread is not blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="08f3a-132">重要的一点是，协议 (HTTP/HTTPS) 是同步的当它收到 HTTP 服务器响应时，客户端代码仅可以继续其任务。</span><span class="sxs-lookup"><span data-stu-id="08f3a-132">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

-   <span data-ttu-id="08f3a-133">异步协议。</span><span class="sxs-lookup"><span data-stu-id="08f3a-133">Asynchronous protocol.</span></span> <span data-ttu-id="08f3a-134">其他协议，如 AMQP （许多操作系统和云环境支持的协议） 使用异步消息。</span><span class="sxs-lookup"><span data-stu-id="08f3a-134">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="08f3a-135">客户端代码或消息发件人通常不会等待响应。</span><span class="sxs-lookup"><span data-stu-id="08f3a-135">The client code or message sender usually does not wait for a response.</span></span> <span data-ttu-id="08f3a-136">它只是将消息发送到 RabbitMQ 队列或任何其他消息代理时将发送形式的消息。</span><span class="sxs-lookup"><span data-stu-id="08f3a-136">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="08f3a-137">如果通信具有单一的接收方或多个接收方，第二个轴定义：</span><span class="sxs-lookup"><span data-stu-id="08f3a-137">The second axis is defining if the communication has a single receiver or multiple receivers:</span></span>

-   <span data-ttu-id="08f3a-138">一个接收方。</span><span class="sxs-lookup"><span data-stu-id="08f3a-138">Single receiver.</span></span> <span data-ttu-id="08f3a-139">每个请求必须由恰好一个接收方或服务来处理。</span><span class="sxs-lookup"><span data-stu-id="08f3a-139">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="08f3a-140">此通信的一个示例是[命令模式](https://en.wikipedia.org/wiki/Command_pattern)。</span><span class="sxs-lookup"><span data-stu-id="08f3a-140">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

-   <span data-ttu-id="08f3a-141">多个接收方。</span><span class="sxs-lookup"><span data-stu-id="08f3a-141">Multiple receivers.</span></span> <span data-ttu-id="08f3a-142">每个请求可以由零到多个接收方处理。</span><span class="sxs-lookup"><span data-stu-id="08f3a-142">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="08f3a-143">这种通信类型必须是异步的。</span><span class="sxs-lookup"><span data-stu-id="08f3a-143">This type of communication must be asynchronous.</span></span> <span data-ttu-id="08f3a-144">一个示例是[发布/订阅](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)机制在类似的模式下使用[事件驱动的体系结构](http://microservices.io/patterns/data/event-driven-architecture.html)。</span><span class="sxs-lookup"><span data-stu-id="08f3a-144">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](http://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="08f3a-145">这基于事件 bus 接口或消息代理时传播事件; 通过多个微服务之间的数据更新它通常通过 service bus 或类似的类似项目实现[Azure Service Bus](https://azure.microsoft.com/services/service-bus/)使用[主题和订阅](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)。</span><span class="sxs-lookup"><span data-stu-id="08f3a-145">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it is usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="08f3a-146">基于微服务构成的应用程序通常将使用这些通信样式的组合。</span><span class="sxs-lookup"><span data-stu-id="08f3a-146">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="08f3a-147">最常见的类型时调用常规的 Web API HTTP 服务，将使用类似 HTTP/HTTPS 同步协议的单个接收方通信。</span><span class="sxs-lookup"><span data-stu-id="08f3a-147">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="08f3a-148">微服务通常还使用微服务之间进行异步通信的消息传递协议。</span><span class="sxs-lookup"><span data-stu-id="08f3a-148">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="08f3a-149">这些轴不很有必要知道，以便清楚起见对可能出现的通信机制，但它们不是生成微服务时的重要问题。</span><span class="sxs-lookup"><span data-stu-id="08f3a-149">These axes are good to know so you have clarity on the possible communication mechanisms, but they are not the important concerns when building microservices.</span></span> <span data-ttu-id="08f3a-150">集成微服务时，所选协议的客户端线程执行即使的异步性质的异步性质是重要事项。</span><span class="sxs-lookup"><span data-stu-id="08f3a-150">The asynchronous nature of client thread execution not even the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="08f3a-151">什么*是*重要正在能够将集成你微服务以异步方式同时保持独立微服务，如下面的部分中所述。</span><span class="sxs-lookup"><span data-stu-id="08f3a-151">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="08f3a-152">异步微服务集成将强制使用微服务构成的自主性</span><span class="sxs-lookup"><span data-stu-id="08f3a-152">Asynchronous microservice integration enforces microservice’s autonomy</span></span>

<span data-ttu-id="08f3a-153">如前文所述，生成基于微服务的应用程序时，重要的一点是集成你微服务的方法。</span><span class="sxs-lookup"><span data-stu-id="08f3a-153">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="08f3a-154">理想情况下，你应尝试尽量减少内部微服务之间的通信。</span><span class="sxs-lookup"><span data-stu-id="08f3a-154">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="08f3a-155">较少之间的通信微服务，越好。</span><span class="sxs-lookup"><span data-stu-id="08f3a-155">The less communications between microservices, the better.</span></span> <span data-ttu-id="08f3a-156">但当然，在许多情况下你将需要以某种方式集成微服务。</span><span class="sxs-lookup"><span data-stu-id="08f3a-156">But of course, in many cases you will have to somehow integrate the microservices.</span></span> <span data-ttu-id="08f3a-157">当你需要执行此操作时，关键的规则是微服务之间的通信应为异步。</span><span class="sxs-lookup"><span data-stu-id="08f3a-157">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="08f3a-158">并不意味着你需要使用特定协议 （例如，异步消息传送与同步 HTTP）。</span><span class="sxs-lookup"><span data-stu-id="08f3a-158">That does not mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="08f3a-159">它只是微服务之间的通信应仅通过以异步方式将数据传播完成，但不是尝试依赖于其他内部微服务作为初始服务的 HTTP 请求/响应操作的一部分。</span><span class="sxs-lookup"><span data-stu-id="08f3a-159">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service’s HTTP request/response operation.</span></span>

<span data-ttu-id="08f3a-160">如果可能，永远不会依赖于多个微服务，即使对于查询之间的同步通信 （请求/响应）。</span><span class="sxs-lookup"><span data-stu-id="08f3a-160">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="08f3a-161">每个微服务的目标是为自治上并供客户端使用者，即使是端到端应用程序的一部分的其他服务都已关闭或不正常。</span><span class="sxs-lookup"><span data-stu-id="08f3a-161">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="08f3a-162">如果你认为中的需要进行其他微服务 （如执行 HTTP 请求的数据查询） 从一个 microservice 调用以便能够提供对客户端应用程序的响应，必须将不会某些弹性的体系结构微服务失败。</span><span class="sxs-lookup"><span data-stu-id="08f3a-162">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) in order to be able to provide a response to a client application, you have an architecture that will not be resilient when some microservices fail.</span></span>

<span data-ttu-id="08f3a-163">此外，不仅有 HTTP 依赖项之间微服务，如图 4-15 的第一部分中所示，使用 HTTP 请求/响应周期创建长时请求链，使你微服务不自治但其性能也是影响只要该链中的服务之一表现不佳。</span><span class="sxs-lookup"><span data-stu-id="08f3a-163">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain is not performing well.</span></span> 

<span data-ttu-id="08f3a-164">越添加微服务，例如查询请求之间的同步依赖关系，总体响应时间获取客户端应用程序的事情就越麻烦。</span><span class="sxs-lookup"><span data-stu-id="08f3a-164">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![](./media/image15.png)

<span data-ttu-id="08f3a-165">**图 4-15**。</span><span class="sxs-lookup"><span data-stu-id="08f3a-165">**Figure 4-15**.</span></span> <span data-ttu-id="08f3a-166">反模式和微服务之间的通信模式</span><span class="sxs-lookup"><span data-stu-id="08f3a-166">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="08f3a-167">如果你的 microservice 需要提升另一个微服务中的其他操作，如果可能，请不要执行该操作以同步方式和作为原始的微服务请求和答复操作的一部分。</span><span class="sxs-lookup"><span data-stu-id="08f3a-167">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="08f3a-168">而应以异步方式执行 （使用异步消息传送或集成事件、 队列，等等）。</span><span class="sxs-lookup"><span data-stu-id="08f3a-168">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="08f3a-169">但是，尽可能多地，不调用同步作为原始的同步请求和答复操作的一部分操作。</span><span class="sxs-lookup"><span data-stu-id="08f3a-169">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="08f3a-170">最后 （，这是其中大部分问题出现时生成微服务），如果初始 microservice 需要最初归其他微服务的数据时，不依赖于发出该数据的同步请求。</span><span class="sxs-lookup"><span data-stu-id="08f3a-170">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that is originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="08f3a-171">而是复制或传播到初始服务的数据库数据 （仅需要的属性），通过使用最终一致性 （通常通过使用集成事件，如在后面几节所述）。</span><span class="sxs-lookup"><span data-stu-id="08f3a-171">Instead, replicate or propagate that data (only the attributes you need) into the initial service’s database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="08f3a-172">如前文所述的部分中[标识每个微服务的域模型边界](#identifying-domain-model-boundaries-for-each-microservice)，复制跨多个微服务的某些数据不是设计错误 — 相反，当执行操作，您可以将数据转换到特定语言或其他域或绑定上下文的条款。</span><span class="sxs-lookup"><span data-stu-id="08f3a-172">As noted earlier in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice), duplicating some data across several microservices is not an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="08f3a-173">例如，在[eShopOnContainers](http://aka.ms/MicroservicesArchitecture)具有名为含有名为用户的实体都负责大部分用户的数据的 identity.api 微服务构成的应用程序。</span><span class="sxs-lookup"><span data-stu-id="08f3a-173">For instance, in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) application you have a microservice named identity.api that is in charge of most of the user’s data with an entity named User.</span></span> <span data-ttu-id="08f3a-174">但是，当你需要存储有关排序微服务内的用户数据，则将其存储作为名为 Buyer 不同实体。</span><span class="sxs-lookup"><span data-stu-id="08f3a-174">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="08f3a-175">买方实体共享相同的标识与原始用户实体，但它可能具有仅需要按排序域和而非整个用户配置文件的几个属性。</span><span class="sxs-lookup"><span data-stu-id="08f3a-175">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="08f3a-176">你可以使用任何协议进行通信和数据以异步方式在之间传播微服务以便具有最终一致性。</span><span class="sxs-lookup"><span data-stu-id="08f3a-176">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="08f3a-177">如前文所述，你可以使用集成事件，请使用事件总线或 broker 或你甚至可以通过轮询其他服务改为使用 HTTP 的消息。</span><span class="sxs-lookup"><span data-stu-id="08f3a-177">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="08f3a-178">并不重要。</span><span class="sxs-lookup"><span data-stu-id="08f3a-178">It does not matter.</span></span> <span data-ttu-id="08f3a-179">重要的规则是创建您微服务之间的同步依赖关系。</span><span class="sxs-lookup"><span data-stu-id="08f3a-179">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="08f3a-180">以下各节介绍你可以考虑使用基于微服务构成的应用程序中的多个通信样式。</span><span class="sxs-lookup"><span data-stu-id="08f3a-180">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="08f3a-181">通信样式</span><span class="sxs-lookup"><span data-stu-id="08f3a-181">Communication styles</span></span>

<span data-ttu-id="08f3a-182">有许多协议和你可以将用于通信，具体取决于你想要使用的通信类型的选项。</span><span class="sxs-lookup"><span data-stu-id="08f3a-182">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="08f3a-183">如果你使用的一种同步基于请求/响应的通信机制，协议，如 HTTP 和 REST 的方法是最常见的尤其是如果您要发布你的 Docker 主机或 microservice 群集外部服务。</span><span class="sxs-lookup"><span data-stu-id="08f3a-183">If you are using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you are publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="08f3a-184">如果内部 （在你的 Docker 主机或微服务群集） 的服务之间通信可能还想要使用二进制格式 （如 Service Fabric 远程处理或 WCF 中使用 TCP 和二进制格式） 的通信机制。</span><span class="sxs-lookup"><span data-stu-id="08f3a-184">If you are communicating between services internally (within your Docker host or microservices cluster) you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="08f3a-185">或者，你可以使用基于消息的异步通信机制，例如 AMQP。</span><span class="sxs-lookup"><span data-stu-id="08f3a-185">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="08f3a-186">也有多个消息格式，如 JSON 或 XML 或甚至是二进制格式，可能会更有效。</span><span class="sxs-lookup"><span data-stu-id="08f3a-186">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="08f3a-187">如果你选择的二进制格式不是一种标准，它可能并不是一个好办法公开发布你的服务使用该格式。</span><span class="sxs-lookup"><span data-stu-id="08f3a-187">If your chosen binary format is not a standard, it is probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="08f3a-188">你微服务之间进行内部通信都可以使用非标准的格式。</span><span class="sxs-lookup"><span data-stu-id="08f3a-188">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="08f3a-189">（Docker orchestrators 或 Azure Service Fabric） 的你的 Docker 主机或 microservice 群集内或专有的客户端应用程序与微服务通信的微服务之间进行通信时，你可能需要这样做。</span><span class="sxs-lookup"><span data-stu-id="08f3a-189">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="08f3a-190">使用 HTTP 和 REST 请求/响应通信</span><span class="sxs-lookup"><span data-stu-id="08f3a-190">Request/response communication with HTTP and REST</span></span> 

<span data-ttu-id="08f3a-191">当客户端使用请求/响应通信时，它将请求发送到服务，然后服务处理请求并发送回的响应。</span><span class="sxs-lookup"><span data-stu-id="08f3a-191">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="08f3a-192">请求/响应通信尤其适合对于实时 UI （实时用户接口） 从客户端应用程序查询数据。</span><span class="sxs-lookup"><span data-stu-id="08f3a-192">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="08f3a-193">因此，在微服务体系结构中你将可能使用此通信机制对于大多数查询，在图 4-16 中所示。</span><span class="sxs-lookup"><span data-stu-id="08f3a-193">Therefore, in a microservice architecture you will probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![](./media/image16.png)

<span data-ttu-id="08f3a-194">**图 4-16**。</span><span class="sxs-lookup"><span data-stu-id="08f3a-194">**Figure 4-16**.</span></span> <span data-ttu-id="08f3a-195">使用 HTTP 请求/响应通信 （同步或异步）</span><span class="sxs-lookup"><span data-stu-id="08f3a-195">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="08f3a-196">当客户端使用请求/响应通信时，它假设，响应将到达在短时间，通常少于一秒或几秒钟后最多。</span><span class="sxs-lookup"><span data-stu-id="08f3a-196">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="08f3a-197">对于响应延迟，你需要实施基于异步通信[消息传递模式](https://docs.microsoft.com/azure/architecture/patterns/category/messaging)和[消息传送技术](https://en.wikipedia.org/wiki/Message-oriented_middleware)，这是我们在下一部分中介绍的不同方法。</span><span class="sxs-lookup"><span data-stu-id="08f3a-197">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="08f3a-198">请求/响应通信的常用体系结构样式是[REST](https://en.wikipedia.org/wiki/Representational_state_transfer)。</span><span class="sxs-lookup"><span data-stu-id="08f3a-198">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="08f3a-199">此方法为基础，并且紧密耦合的[HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)协议，使用 HTTP 谓词，如 GET、 POST 和 PUT。</span><span class="sxs-lookup"><span data-stu-id="08f3a-199">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="08f3a-200">创建服务时，其余部分将是最常用的体系结构的通信方法。</span><span class="sxs-lookup"><span data-stu-id="08f3a-200">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="08f3a-201">当你开发 ASP.NET 核心 Web API 服务时，你可以实现 REST 服务。</span><span class="sxs-lookup"><span data-stu-id="08f3a-201">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="08f3a-202">使用 HTTP REST 服务作为你的接口定义语言时，没有其他值。</span><span class="sxs-lookup"><span data-stu-id="08f3a-202">There is additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="08f3a-203">例如，如果你使用[Swagger 元数据](http://swagger.io/)来描述服务 API，你可以使用生成可以直接发现和使用你的服务的客户端存根的工具。</span><span class="sxs-lookup"><span data-stu-id="08f3a-203">For instance, if you use [Swagger metadata](http://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="08f3a-204">其他资源</span><span class="sxs-lookup"><span data-stu-id="08f3a-204">Additional resources</span></span>

-   <span data-ttu-id="08f3a-205">**Martin Fowler。Richardson 成熟度模型。**</span><span class="sxs-lookup"><span data-stu-id="08f3a-205">**Martin Fowler. Richardson Maturity Model.**</span></span> <span data-ttu-id="08f3a-206">REST 模型的说明。</span><span class="sxs-lookup"><span data-stu-id="08f3a-206">A description of the REST model.</span></span>
    [<span data-ttu-id="08f3a-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span><span class="sxs-lookup"><span data-stu-id="08f3a-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span></span>](http://martinfowler.com/articles/richardsonMaturityModel.html)

-   <span data-ttu-id="08f3a-208">**Swagger。**</span><span class="sxs-lookup"><span data-stu-id="08f3a-208">**Swagger.**</span></span> <span data-ttu-id="08f3a-209">官方网站。</span><span class="sxs-lookup"><span data-stu-id="08f3a-209">The official site.</span></span>
    [<span data-ttu-id="08f3a-210">*http://swagger.io/*</span><span class="sxs-lookup"><span data-stu-id="08f3a-210">*http://swagger.io/*</span></span>](http://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="08f3a-211">推送和基于 HTTP 的实时通信</span><span class="sxs-lookup"><span data-stu-id="08f3a-211">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="08f3a-212">（通常用于比 REST 的不同目的） 的另一种可能是与更高级别的框架的实时和一对多通信，如[ASP.NET SignalR](https://www.asp.net/signalr)和协议，例如[Websocket](https://en.wikipedia.org/wiki/WebSocket)。</span><span class="sxs-lookup"><span data-stu-id="08f3a-212">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="08f3a-213">如图 4-17 所示，实时 HTTP 通信意味着你可以将内容推送到连接的客户端，当数据变为可用，而不必等待客户端请求新数据的服务器的服务器代码。</span><span class="sxs-lookup"><span data-stu-id="08f3a-213">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![](./media/image17.png)

<span data-ttu-id="08f3a-214">**图 4-17**。</span><span class="sxs-lookup"><span data-stu-id="08f3a-214">**Figure 4-17**.</span></span> <span data-ttu-id="08f3a-215">一对一实时的异步消息通信</span><span class="sxs-lookup"><span data-stu-id="08f3a-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="08f3a-216">由于实时是通信，客户端应用程序几乎立刻显示所做的更改。</span><span class="sxs-lookup"><span data-stu-id="08f3a-216">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="08f3a-217">这通常由如 WebSockets，使用多个 Websocket 连接 （每个客户端一个） 协议进行处理。</span><span class="sxs-lookup"><span data-stu-id="08f3a-217">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="08f3a-218">一个典型示例是当服务同时通信中的许多客户端 web 应用到体育游戏的分数的更改时。</span><span class="sxs-lookup"><span data-stu-id="08f3a-218">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="08f3a-219">[以前](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [下一步] (异步-消息-基于-communication.md)</span><span class="sxs-lookup"><span data-stu-id="08f3a-219">[Previous] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Next] (asynchronous-message-based-communication.md)</span></span>
