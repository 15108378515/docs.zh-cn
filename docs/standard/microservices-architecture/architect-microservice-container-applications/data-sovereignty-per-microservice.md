---
title: "每个微服务构成的数据自主性"
description: "为容器化的.NET 应用程序的.NET 微服务体系结构 |每个微服务构成的数据自主性"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: c51daae04215cfa6f5b5b8d2158a8ed1a8949652
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/22/2017
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="a4c2f-104">每个微服务构成的数据自主性</span><span class="sxs-lookup"><span data-stu-id="a4c2f-104">Data sovereignty per microservice</span></span>

<span data-ttu-id="a4c2f-105">微服务体系结构的重要规则是每个微服务必须拥有其域数据和逻辑。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-105">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="a4c2f-106">就像一个完整的应用程序拥有其逻辑和数据，因此必须每个微服务拥有其逻辑和下自治生命周期，与每个微服务的部署独立于数据。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-106">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="a4c2f-107">这意味着域的概念模型将子系统或微服务之间有所不同。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-107">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="a4c2f-108">请考虑企业应用程序，其中客户关系管理 (CRM) 应用程序，事务购买子系统和客户支持子系统上的唯一客户实体属性和数据，每个调用，且每个使用不同界限的上下文 (BC)。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-108">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="a4c2f-109">此原则是在类似[域驱动设计 (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)，其中每个[绑定上下文](https://martinfowler.com/bliki/BoundedContext.html)或自治子系统或服务必须拥有其域模型 （数据加上逻辑和行为）。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-109">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="a4c2f-110">每个 DDD 绑定上下文对应于一个业务微服务 （一个或多个服务）。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-110">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="a4c2f-111">（我们在上展开此点有关下一节中的绑定上下文模式。）</span><span class="sxs-lookup"><span data-stu-id="a4c2f-111">(We expand on this point about the Bounded Context pattern in the next section.)</span></span>

<span data-ttu-id="a4c2f-112">另一方面，在许多应用程序中使用传统 （整体数据） 方法是具有单个集中式的数据库或只需少量的数据库。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-112">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="a4c2f-113">这通常是适用于整个应用程序和所有其内部子系统，规范化的 SQL 数据库，在图 4-7 中所示。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-113">This is often a normalized SQL database that is used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![](./media/image7.png)

<span data-ttu-id="a4c2f-114">**图 4-7**。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-114">**Figure 4-7**.</span></span> <span data-ttu-id="a4c2f-115">数据自主性比较： 整体数据库而不是微服务</span><span class="sxs-lookup"><span data-stu-id="a4c2f-115">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="a4c2f-116">集中式的 database 方法最初看起来更简单，并且看起来以确保以一致的所有内容的其他子系统中的实体的重复使用。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-116">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="a4c2f-117">但事实是你最终会得到极大的表提供许多其他子系统，并且在大多数情况下包括属性和不需要的列。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-117">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that are not needed in most cases.</span></span> <span data-ttu-id="a4c2f-118">这就像尝试使用相同的物理映射用于旅游短跟踪，花费的持续一天的汽车行程，和了解地理位置。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-118">it is like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="a4c2f-119">具有通常一个关系数据库的整体应用程序有两个重要的好处： [ACID 事务](https://en.wikipedia.org/wiki/ACID)和 SQL 语言，这两个跨所有表和与你的应用程序相关的数据。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-119">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="a4c2f-120">此方法提供了一种方法轻松地编写合并来自多个表的数据的查询。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-120">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="a4c2f-121">但是，数据访问变得更复杂，你将移动到微服务体系结构时。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-121">However, data access becomes much more complex when you move to a microservices architecture.</span></span> <span data-ttu-id="a4c2f-122">但即使 ACID 事务可以或应在 microservice 或绑定上下文中使用，并将数据拥有的每个微服务专用于该 microservice 只能通过其微服务 API 访问。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-122">But even when ACID transactions can or should be used within a microservice or Bounded Context, the data owned by each microservice is private to that microservice and can only be accessed via its microservice API.</span></span> <span data-ttu-id="a4c2f-123">封装数据可确保微服务松散耦合，可以独立于另一个变化。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-123">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="a4c2f-124">如果多个服务访问相同的数据，架构更新将需要协调的更新到所有服务。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-124">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="a4c2f-125">这将会破坏微服务生命周期自治。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-125">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="a4c2f-126">但分布式的数据结构意味着您无法跨微服务进行单个 ACID 事务。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-126">But distributed data structures mean that you cannot make a single ACID transaction across microservices.</span></span> <span data-ttu-id="a4c2f-127">这反过来意味着当业务流程跨多个微服务时，必须使用最终一致性。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-127">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="a4c2f-128">这是很难实现都比简单的 SQL 联接;同样，许多其他关系数据库功能将不可用跨多个微服务。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-128">This is much harder to implement than simple SQL joins; similarly, many other relational database features are not available across multiple microservices.</span></span>

<span data-ttu-id="a4c2f-129">将更进一步，不同的微服务通常使用不同*类型*的数据库。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-129">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="a4c2f-130">现代应用程序存储和处理不同类型的数据，以及关系数据库并不总是最佳选择。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-130">Modern applications store and process diverse kinds of data, and a relational database is not always the best choice.</span></span> <span data-ttu-id="a4c2f-131">对于某些用例，如 Azure DocumentDB 或 MongoDB 的 NoSQL 数据库可能会更方便的数据模型并提供更好的性能和可伸缩性，比 SQL 数据库类似于 SQL Server 或 Azure SQL 数据库。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-131">For some use cases, a NoSQL database such as Azure DocumentDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="a4c2f-132">在其他情况下，关系数据库仍是最佳的方法。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-132">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="a4c2f-133">因此，基于微服务的应用程序通常将混合使用 SQL 和 NoSQL 数据库，这有时称为[polyglot 持久性](http://martinfowler.com/bliki/PolyglotPersistence.html)方法。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-133">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](http://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="a4c2f-134">数据存储的分区、 polyglot 持续性持久体系结构带来诸多好处。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-134">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="a4c2f-135">其中包括松散耦合的服务和更好性能、 可伸缩性、 成本和可管理性。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-135">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="a4c2f-136">但是，它还会带来一些分布式的数据管理难题，因为我们将介绍在"[标识域模型边界](#identifying-domain-model-boundaries-for-each-microservice)"这一章中更高版本。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-136">However, it can introduce some distributed data management challenges, as we will explain in “[Identifying domain-model boundaries](#identifying-domain-model-boundaries-for-each-microservice)” later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="a4c2f-137">微服务和绑定上下文模式之间的关系</span><span class="sxs-lookup"><span data-stu-id="a4c2f-137">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="a4c2f-138">微服务构成的概念派生自[绑定上下文 (BC) 模式](http://martinfowler.com/bliki/BoundedContext.html)中[域驱动设计 (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-138">The concept of microservice derives from the [Bounded Context (BC) pattern](http://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="a4c2f-139">DDD 通过将它们分割成多个 BCs 和有关其边界显式处理大的模型。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-139">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="a4c2f-140">每个业务连续性必须具有其自己的模型和数据库;同样，每个微服务拥有其相关的数据。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-140">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="a4c2f-141">此外，每个业务连续性通常都具有其自己[无处不在语言](http://martinfowler.com/bliki/UbiquitousLanguage.html)有助于软件开发人员和域专业人员之间的通信。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-141">In addition, each BC usually has its own [ubiquitous language](http://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="a4c2f-142">无处不在的语言中的这些术语 （主要域实体） 可以在不同的绑定上下文中具有不同的名称，即使不同域实体共享相同的标识 (即，用于从存储读取实体的唯一 ID)。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-142">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that is used to read the entity from storage).</span></span> <span data-ttu-id="a4c2f-143">例如，在用户配置文件绑定上下文中，用户域实体可能共享标识与排序的绑定上下文中的购买域实体。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-143">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="a4c2f-144">Microservice 因此类似界定的上下文，但它还指定它是一分布式的服务。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-144">A microservice is therefore like a Bounded Context, but it also specifies that it is a distributed service.</span></span> <span data-ttu-id="a4c2f-145">创建作为单独的进程的每个绑定的上下文，并且它必须使用前文所述，像 HTTP/HTTPS，Websocket，这样的分布式的协议或[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-145">It is built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="a4c2f-146">绑定上下文模式，但是，未指定绑定上下文是否是分布式的服务或它是否只是一种逻辑的边界，（例如泛型的子系统） 在整体部署应用程序。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-146">The Bounded Context pattern, however, does not specify whether the Bounded Context is a distributed service or if it is simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="a4c2f-147">请务必突出显示，定义每个绑定上下文的服务是启动的好时机。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-147">It is important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="a4c2f-148">但不是需要约束你设计到它。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-148">But you do not have to constrain your design to it.</span></span> <span data-ttu-id="a4c2f-149">有时必须设计绑定上下文或业务微服务组成的多个物理服务。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-149">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="a4c2f-150">但从根本上讲，这两种模式-绑定上下文和 microservice-密切相关。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-150">But ultimately, both patterns—Bounded Context and microservice—are closely related.</span></span>

<span data-ttu-id="a4c2f-151">通过获取分布式微服务的窗体中的实际边界的情况下，DDD 受益于微服务状态。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-151">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="a4c2f-152">但是，例如不共享之间微服务模型的想法是您还需要的绑定上下文中。</span><span class="sxs-lookup"><span data-stu-id="a4c2f-152">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="a4c2f-153">其他资源</span><span class="sxs-lookup"><span data-stu-id="a4c2f-153">Additional resources</span></span>

-   <span data-ttu-id="a4c2f-154">**Chris Richardson。模式： 数据库每个服务**
    [*http://microservices.io/patterns/data/database-per-service.html*](http://microservices.io/patterns/data/database-per-service.html)</span><span class="sxs-lookup"><span data-stu-id="a4c2f-154">**Chris Richardson. Pattern: Database per service**
[*http://microservices.io/patterns/data/database-per-service.html*](http://microservices.io/patterns/data/database-per-service.html)</span></span>

-   <span data-ttu-id="a4c2f-155">**Martin Fowler。BoundedContext**
    [*http://martinfowler.com/bliki/BoundedContext.html*](http://martinfowler.com/bliki/BoundedContext.html)</span><span class="sxs-lookup"><span data-stu-id="a4c2f-155">**Martin Fowler. BoundedContext**
[*http://martinfowler.com/bliki/BoundedContext.html*](http://martinfowler.com/bliki/BoundedContext.html)</span></span>

-   <span data-ttu-id="a4c2f-156">**Martin Fowler。PolyglotPersistence**
    [*http://martinfowler.com/bliki/PolyglotPersistence.html*](http://martinfowler.com/bliki/PolyglotPersistence.html)</span><span class="sxs-lookup"><span data-stu-id="a4c2f-156">**Martin Fowler. PolyglotPersistence**
[*http://martinfowler.com/bliki/PolyglotPersistence.html*](http://martinfowler.com/bliki/PolyglotPersistence.html)</span></span>

-   <span data-ttu-id="a4c2f-157">**Alberto Brandolini。战略的域驱动的设计与上下文映射**
    [*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span><span class="sxs-lookup"><span data-stu-id="a4c2f-157">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping**
[*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="a4c2f-158">[以前](微服务-architecture.md) [下一步] (逻辑-而不是-物理-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="a4c2f-158">[Previous] (microservices-architecture.md) [Next] (logical-versus-physical-architecture.md)</span></span>
