---
title: 客户端到微服务直接通信与 API 网关模式
description: 适用于容器化 .NET 应用程序的 .NET 微服务体系结构 | 客户端到微服务直接通信与 API 网关模式
keywords: Docker, 微服务, ASP.NET, 容器, API 网关
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: fa3f4bb97cf942ee7698b1efa1dcd09b3f2ca571
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/18/2018
---
# <a name="direct-client-to-microservice-communication-versus-the-api-gateway-pattern"></a><span data-ttu-id="73e7b-104">客户端到微服务直接通信与 API 网关模式</span><span class="sxs-lookup"><span data-stu-id="73e7b-104">Direct client-to-microservice communication versus the API Gateway pattern</span></span>

<span data-ttu-id="73e7b-105">在微服务体系结构中，每个微服务都会公开（通常）一组精细终结点。</span><span class="sxs-lookup"><span data-stu-id="73e7b-105">In a microservices architecture, each microservice exposes a set of (typically) fine‑grained endpoints.</span></span> <span data-ttu-id="73e7b-106">这种情况可能会影响客户端到微服务通信，如本节所述。</span><span class="sxs-lookup"><span data-stu-id="73e7b-106">This fact can impact the client‑to‑microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="73e7b-107">客户端到微服务直接通信</span><span class="sxs-lookup"><span data-stu-id="73e7b-107">Direct client-to-microservice communication</span></span>

<span data-ttu-id="73e7b-108">使用客户端到微服务直接通信体系结构是一种可行方法。</span><span class="sxs-lookup"><span data-stu-id="73e7b-108">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="73e7b-109">在此方法中，客户端应用可以直接向某些微服务发出请求，如图 4-12 所示。</span><span class="sxs-lookup"><span data-stu-id="73e7b-109">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![](./media/image12.png)

<span data-ttu-id="73e7b-110">图 4-12。</span><span class="sxs-lookup"><span data-stu-id="73e7b-110">**Figure 4-12**.</span></span> <span data-ttu-id="73e7b-111">使用客户端到微服务直接通信体系结构</span><span class="sxs-lookup"><span data-stu-id="73e7b-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="73e7b-112">在此方法中，</span><span class="sxs-lookup"><span data-stu-id="73e7b-112">In this approach.</span></span> <span data-ttu-id="73e7b-113">每个微服务都有一个公共终结点，有时每个微服务会有不同的 TCP 端口。</span><span class="sxs-lookup"><span data-stu-id="73e7b-113">each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="73e7b-114">特定服务的 URL 示例可能是 Azure 中的以下 URL：</span><span class="sxs-lookup"><span data-stu-id="73e7b-114">An example of a URL for a particular service could be the following URL in Azure:</span></span>

<http://eshoponcontainers.westus.cloudapp.azure.com:88/>

<span data-ttu-id="73e7b-115">在基于群集的生产环境中，该 URL 将映射到群集中使用的负载均衡器，该负载均衡器随后在微服务中分布请求。</span><span class="sxs-lookup"><span data-stu-id="73e7b-115">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="73e7b-116">在生产环境中，可以在微服务和 Internet 之间使用 [Azure 应用程序网关](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction)等应用程序传送控制器 (ADC)。</span><span class="sxs-lookup"><span data-stu-id="73e7b-116">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="73e7b-117">该控制器将充当透明层，不仅执行负载均衡，还可通过提供 SSL 终端来保护服务。</span><span class="sxs-lookup"><span data-stu-id="73e7b-117">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="73e7b-118">这通过卸载 CPU 密集型 SSL 终端和其他到 Azure 应用程序网关的路由任务来提高主机负载。</span><span class="sxs-lookup"><span data-stu-id="73e7b-118">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="73e7b-119">在任何情况下，从逻辑应用程序体系结构的角度看，负载均衡器和 ADC 都是透明的。</span><span class="sxs-lookup"><span data-stu-id="73e7b-119">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="73e7b-120">客户端到微服务直接通信体系结构已能满足基于微服务的小型应用程序的需求，尤其是在客户端应用为服务器端 Web 应用程序（如 ASP.NET MVC 应用）的情况下。</span><span class="sxs-lookup"><span data-stu-id="73e7b-120">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="73e7b-121">但是，若要生成基于微服务的大型复杂应用程序（例如处理大量微服务类型），尤其是客户端应用是远程移动应用或 SPA Web 应用程序时，该方法将面临一些问题。</span><span class="sxs-lookup"><span data-stu-id="73e7b-121">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="73e7b-122">开发基于微服务的大型应用程序时，请考虑以下问题：</span><span class="sxs-lookup"><span data-stu-id="73e7b-122">Consider the following questions when developing a large application based on microservices:</span></span>

-   <span data-ttu-id="73e7b-123">客户端应用如何最大限度地减少对后端发出的请求数并减少与多个微服务的聊天通信？</span><span class="sxs-lookup"><span data-stu-id="73e7b-123">*How can client apps minimize the number of requests to the backend and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="73e7b-124">与多个微服务交互构建单个 UI 屏幕可增加 Internet 中的往返次数。</span><span class="sxs-lookup"><span data-stu-id="73e7b-124">Interacting with multiple microservices to build a single UI screen increases the number of roundtrips across the Internet.</span></span> <span data-ttu-id="73e7b-125">这会增加 UI 端的延迟时间和复杂性。</span><span class="sxs-lookup"><span data-stu-id="73e7b-125">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="73e7b-126">理想情况下，响应会在服务端高效聚合。 这便减少了延迟时间，因为可以并行返回多条数据，并且某些 UI 可在准备就绪后立即显示。</span><span class="sxs-lookup"><span data-stu-id="73e7b-126">Ideally, responses should be efficiently aggregated in the server side—this reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it is ready.</span></span>

-   <span data-ttu-id="73e7b-127">如何处理诸如授权、数据转换和动态请求调度之类的整合问题？</span><span class="sxs-lookup"><span data-stu-id="73e7b-127">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="73e7b-128">在每个微服务上实现安全和授权等安全性和整合问题需要进行大量的开发工作。</span><span class="sxs-lookup"><span data-stu-id="73e7b-128">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="73e7b-129">其中一种可行方法是在 Docker 主机或内部群集中提供这些服务，以限制从外部直接访问它们，并在集中位置（如 API 网关）实现这些整合问题。</span><span class="sxs-lookup"><span data-stu-id="73e7b-129">A possible approach is to have those services within the Docker host or internal cluster, in order to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

-   <span data-ttu-id="73e7b-130">客户端应用如何与使用非 Internet 友好协议的服务进行通信？</span><span class="sxs-lookup"><span data-stu-id="73e7b-130">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="73e7b-131">通常，客户端应用不支持服务端使用的协议（如 AMQP 或二进制协议）。</span><span class="sxs-lookup"><span data-stu-id="73e7b-131">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="73e7b-132">因此，必须通过 HTTP/HTTPS 等协议执行请求并随后将请求转换为其他协议。</span><span class="sxs-lookup"><span data-stu-id="73e7b-132">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="73e7b-133">在此情况下，中间人方法可提供帮助。</span><span class="sxs-lookup"><span data-stu-id="73e7b-133">A *man-in-the-middle* approach can help in this situation.</span></span>

-   <span data-ttu-id="73e7b-134">如何塑造一个专为移动应用设计的外观？</span><span class="sxs-lookup"><span data-stu-id="73e7b-134">*How can you shape a façade especially made for mobile apps?*</span></span>

<span data-ttu-id="73e7b-135">多个微服务的 API 设计可能无法满足不同客户端应用程序的需求。</span><span class="sxs-lookup"><span data-stu-id="73e7b-135">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="73e7b-136">例如，移动应用的需求可能不同于 Web 应用的需求。</span><span class="sxs-lookup"><span data-stu-id="73e7b-136">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="73e7b-137">移动应用可能需要进一步优化，以便数据响应能更有效。</span><span class="sxs-lookup"><span data-stu-id="73e7b-137">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="73e7b-138">若要实现这一点，可以聚合多个微服务的数据并返回单组数据，有时还需从响应中删除移动应用不需要的所有数据。</span><span class="sxs-lookup"><span data-stu-id="73e7b-138">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that is not needed by the mobile app.</span></span> <span data-ttu-id="73e7b-139">当然，也可以压缩该数据。</span><span class="sxs-lookup"><span data-stu-id="73e7b-139">And, of course, you might compress that data.</span></span> <span data-ttu-id="73e7b-140">同样，在此方案中，使用移动应用和微服务之间的外观或 API 会非常便捷。</span><span class="sxs-lookup"><span data-stu-id="73e7b-140">Again, a façade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="using-an-api-gateway"></a><span data-ttu-id="73e7b-141">使用 API 网关</span><span class="sxs-lookup"><span data-stu-id="73e7b-141">Using an API Gateway</span></span>

<span data-ttu-id="73e7b-142">使用多个客户端应用来设计和生成基于微服务的大型复杂应用程序时，[API 网关](https://microservices.io/patterns/apigateway.html) 是非常不错的方法。</span><span class="sxs-lookup"><span data-stu-id="73e7b-142">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="73e7b-143">这一服务可为某些微服务组提供单一入口点。</span><span class="sxs-lookup"><span data-stu-id="73e7b-143">This is a service that provides a single entry point for certain groups of microservices.</span></span> <span data-ttu-id="73e7b-144">这类似于面向对象设计的[外观模式](https://en.wikipedia.org/wiki/Facade_pattern)，但在此情况下，它是分布式系统的一部分。</span><span class="sxs-lookup"><span data-stu-id="73e7b-144">It is similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object‑oriented design, but in this case, it is part of a distributed system.</span></span> <span data-ttu-id="73e7b-145">因为构建时考虑了客户端应用的需求，所以 API 网关模式有时也称为“用于前端的后端”[(BFF)](https://samnewman.io/patterns/architectural/bff/)。</span><span class="sxs-lookup"><span data-stu-id="73e7b-145">The API Gateway pattern is also sometimes known as the “backend for frontend” [(BFF)](https://samnewman.io/patterns/architectural/bff/) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="73e7b-146">图 4-13 演示自定义 API 网关如何适应基于微服务的体系结构。</span><span class="sxs-lookup"><span data-stu-id="73e7b-146">Figure 4-13 shows how a custom API Gateway can fit into a microservice-based architecture.</span></span>
<span data-ttu-id="73e7b-147">将使用面向多个不同客户端应用的单个自定义 API 网关服务，在该图中突出显示这一点非常重要。</span><span class="sxs-lookup"><span data-stu-id="73e7b-147">It is important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="73e7b-148">这一事实可能存在很大风险，因为 API 网关服务将根据客户端应用的多种不同要求而不断增长和发展。</span><span class="sxs-lookup"><span data-stu-id="73e7b-148">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="73e7b-149">最终，它将因这些不同的需求而膨胀，实际上，它会类似于整体式应用程序或整体式服务。</span><span class="sxs-lookup"><span data-stu-id="73e7b-149">Eventually, it will be bloated because of those different needs and effectively it could be pretty similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="73e7b-150">正因如此，强烈建议将 API 网关拆分成多个服务或多个更小的 API 网关（例如每种外形规格一个网关）。</span><span class="sxs-lookup"><span data-stu-id="73e7b-150">That is why it is very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per form-factor type, for instance.</span></span>

![](./media/image13.png)

<span data-ttu-id="73e7b-151">图 4-13。</span><span class="sxs-lookup"><span data-stu-id="73e7b-151">**Figure 4-13**.</span></span> <span data-ttu-id="73e7b-152">使用作为自定义 Web API 服务实现的 API 网关</span><span class="sxs-lookup"><span data-stu-id="73e7b-152">Using an API Gateway implemented as a custom Web API service</span></span>

<span data-ttu-id="73e7b-153">在此示例中，API 网关将作为自定义 Web API 服务实现，并作为容器运行。</span><span class="sxs-lookup"><span data-stu-id="73e7b-153">In this example, the API Gateway would be implemented as a custom Web API service running as a container.</span></span>

<span data-ttu-id="73e7b-154">如前所述，应实现多个 API 网关，以便具备不同外观，满足每个客户端应用的需求。</span><span class="sxs-lookup"><span data-stu-id="73e7b-154">As mentioned, you should implement several API Gateways so that you can have a different façade for the needs of each client app.</span></span> <span data-ttu-id="73e7b-155">每个 API 网关可以专为每个客户端应用提供不同的 API，甚至可以通过实现特定的适配器代码（该代码在下方调用多个内部微服务），根据客户端外形规格提供不同 API。</span><span class="sxs-lookup"><span data-stu-id="73e7b-155">Each API Gateway can provide a different API tailored for each client app, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices.</span></span>

<span data-ttu-id="73e7b-156">由于自定义 API 网关通常是数据聚合器，因此需要谨慎使用。</span><span class="sxs-lookup"><span data-stu-id="73e7b-156">Since a custom API Gateway is usually a data aggregator, you need to be careful with it.</span></span> <span data-ttu-id="73e7b-157">通常，不建议使用单个 API 网关聚合应用程序的所有内部微服务。</span><span class="sxs-lookup"><span data-stu-id="73e7b-157">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="73e7b-158">如果使用这种方式，它将作为整体式聚合器或业务流程协调程序，且会耦合所有微服务，违背微服务的自主性。</span><span class="sxs-lookup"><span data-stu-id="73e7b-158">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span> <span data-ttu-id="73e7b-159">因此，应根据业务边界分隔 API 网关，并且不将其用作整个应用程序的聚合器。</span><span class="sxs-lookup"><span data-stu-id="73e7b-159">Therefore, the API Gateways should be segregated based on business boundaries and not act as an aggregator for the whole application.</span></span>

<span data-ttu-id="73e7b-160">有时精细 API 网关自身也可以是微服务，甚至可以包含域或业务名称以及相关数据。</span><span class="sxs-lookup"><span data-stu-id="73e7b-160">Sometimes a granular API Gateway can also be a microservice by itself, and even have a domain or business name and related data.</span></span> <span data-ttu-id="73e7b-161">使用由业务或域指示的 API 网关边界将有助于更好地设计。</span><span class="sxs-lookup"><span data-stu-id="73e7b-161">Having the API Gateway’s boundaries dictated by the business or domain will help you to get a better design.</span></span>

<span data-ttu-id="73e7b-162">由于精细 API 网关的概念类似于 UI 组合服务，因此 API 网关层中的粒度特别适用于基于微服务的高级复合 UI 应用程序。</span><span class="sxs-lookup"><span data-stu-id="73e7b-162">Granularity in the API Gateway tier can be especially useful for more advanced composite UI applications based on microservices, because the concept of a fine-grained API Gateway is similar to a UI composition service.</span></span> <span data-ttu-id="73e7b-163">稍后我们将在[创建基于微服务的复合 UI](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices) 中介绍这一点。</span><span class="sxs-lookup"><span data-stu-id="73e7b-163">We discuss this later in the [Creating composite UI based on microservices](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices).</span></span>

<span data-ttu-id="73e7b-164">因此，对于许多大中型应用程序，使用自定义创建的 API 网关通常是一种好方法，但不能作为单个整体式聚合器或唯一的中央自定义 API 网关。</span><span class="sxs-lookup"><span data-stu-id="73e7b-164">Therefore, for many medium- and large-size applications, using a custom-built API Gateway is usually a good approach, but not as a single monolithic aggregator or unique central custom API Gateway.</span></span>

<span data-ttu-id="73e7b-165">另一种方法是使用 [Azure API 管理](https://azure.microsoft.com/services/api-management/) 等产品，如图 4-14 所示。</span><span class="sxs-lookup"><span data-stu-id="73e7b-165">Another approach is to use a product like [Azure API Management](https://azure.microsoft.com/services/api-management/) as shown in Figure 4-14.</span></span> <span data-ttu-id="73e7b-166">这种方法不仅能够满足 API 网关需求，还提供从 API 收集见解等功能。</span><span class="sxs-lookup"><span data-stu-id="73e7b-166">This approach not only solves your API Gateway needs, but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="73e7b-167">如果正在使用 API 管理解决方案，则 API 网关仅是整个 API 管理解决方案中的一个组成部分。</span><span class="sxs-lookup"><span data-stu-id="73e7b-167">If you are using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![](./media/image14.png)

<span data-ttu-id="73e7b-168">图 4-14。</span><span class="sxs-lookup"><span data-stu-id="73e7b-168">**Figure 4-14**.</span></span> <span data-ttu-id="73e7b-169">为 API 网关使用 Azure API 管理</span><span class="sxs-lookup"><span data-stu-id="73e7b-169">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="73e7b-170">在这种情况下，使用如 Azure API 管理之类的产品时，拥有单个 API 网关不会存在较大风险，因为这类 API 网关“更精细”，这意味着不会实现可能发展成整体式组件的自定义 C# 代码。</span><span class="sxs-lookup"><span data-stu-id="73e7b-170">In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span> 

<span data-ttu-id="73e7b-171">这类产品更像是用于入口通信的反向代理，也可以从内部微服务筛选 API，并授权此单层中的已发布 API。</span><span class="sxs-lookup"><span data-stu-id="73e7b-171">This type of product acts more like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="73e7b-172">API 管理系统中提供的见解有助于理解 API 的使用方式与性能表现。</span><span class="sxs-lookup"><span data-stu-id="73e7b-172">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="73e7b-173">通过查看近实时分析报告并标识可能影响业务的趋势，从而实现这一点。</span><span class="sxs-lookup"><span data-stu-id="73e7b-173">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="73e7b-174">此外，还可获取有关请求和响应活动的日志记录，以进一步进行联机和脱机分析。</span><span class="sxs-lookup"><span data-stu-id="73e7b-174">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="73e7b-175">借助 Azure API 管理，可以使用密钥、令牌和 IP 筛选器来保护 API。</span><span class="sxs-lookup"><span data-stu-id="73e7b-175">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="73e7b-176">通过这些功能，可以执行灵活且细化的配额和速率限制，使用策略修改 API 的形状和行为，并通过响应缓存提高性能。</span><span class="sxs-lookup"><span data-stu-id="73e7b-176">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="73e7b-177">在本指南和参考示例应用程序 (eShopOnContainers) 中，我们仅讨论较简单的自定义容器化体系结构，以便将重点放在未使用 PaaS 产品（如 Azure API 管理）的普通容器上。</span><span class="sxs-lookup"><span data-stu-id="73e7b-177">In this guide and the reference sample application (eShopOnContainers), we are limiting the architecture to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="73e7b-178">但是对于部署到 Microsoft Azure 的基于微服务的大型应用程序，我们建议查看并采用 Azure API 管理作为 API 网关的基础。</span><span class="sxs-lookup"><span data-stu-id="73e7b-178">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to review and adopt Azure API Management as the base for your API Gateways.</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="73e7b-179">API 网关模式的缺点</span><span class="sxs-lookup"><span data-stu-id="73e7b-179">Drawbacks of the API Gateway pattern</span></span>

-   <span data-ttu-id="73e7b-180">实现 API 网关时，会将该层与内部微服务进行耦合，这是它的最大缺点。</span><span class="sxs-lookup"><span data-stu-id="73e7b-180">The most important drawback is that when you implement an API Gateway, you are coupling that tier with the internal microservices.</span></span> <span data-ttu-id="73e7b-181">此类耦合可能会给应用程序带来严重问题。</span><span class="sxs-lookup"><span data-stu-id="73e7b-181">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="73e7b-182">Azure 服务总线团队的架构师 Clemens Vaster 在 GOTO 2016 的“[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)”（消息传递和微服务）一节中将此潜在问题描述为“新的 ESB”。</span><span class="sxs-lookup"><span data-stu-id="73e7b-182">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as “the new ESB” in his "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

-   <span data-ttu-id="73e7b-183">使用微服务 API 网关创建其他可能的单一故障点。</span><span class="sxs-lookup"><span data-stu-id="73e7b-183">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

-   <span data-ttu-id="73e7b-184">由于其他网络调用，API 网关可能会导致响应时间加长。</span><span class="sxs-lookup"><span data-stu-id="73e7b-184">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="73e7b-185">但是，相较于经常直接调用内部微服务的客户端接口，这种额外调用的影响更小。</span><span class="sxs-lookup"><span data-stu-id="73e7b-185">However, this extra call usually has less impact than having a client interface that is too chatty directly calling the internal microservices.</span></span>

-   <span data-ttu-id="73e7b-186">如果未正确扩展，API 网关可能成为瓶颈。</span><span class="sxs-lookup"><span data-stu-id="73e7b-186">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

-   <span data-ttu-id="73e7b-187">如果 API 网关包含自定义逻辑和数据聚合，则它需要额外的开发成本并且需要在日后进行维护。</span><span class="sxs-lookup"><span data-stu-id="73e7b-187">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="73e7b-188">开发人员必须更新 API 网关，公开每个微服务的终结点。</span><span class="sxs-lookup"><span data-stu-id="73e7b-188">Developers must update the API Gateway in order to expose each microservice’s endpoints.</span></span> <span data-ttu-id="73e7b-189">此外，内部微服务中的实现更改可能引起 API 网关级别的代码更改。</span><span class="sxs-lookup"><span data-stu-id="73e7b-189">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="73e7b-190">但是，如果 API 网关仅应用安全性、日志记录和版本控制（与使用 Azure API 管理时一样），则可能不会产生额外开发成本。</span><span class="sxs-lookup"><span data-stu-id="73e7b-190">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

-   <span data-ttu-id="73e7b-191">如果是由一个团队开发的 API 网关，则可能出现开发瓶颈。</span><span class="sxs-lookup"><span data-stu-id="73e7b-191">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="73e7b-192">这也是最好使用多个精细 API 网关满足不同客户端需求的另一原因。</span><span class="sxs-lookup"><span data-stu-id="73e7b-192">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="73e7b-193">还可以将 API 网关内部分隔到多个区域或多个层，这些区域或层由使用内部微服务的不同团队所有。</span><span class="sxs-lookup"><span data-stu-id="73e7b-193">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="73e7b-194">其他资源</span><span class="sxs-lookup"><span data-stu-id="73e7b-194">Additional resources</span></span>

-   <span data-ttu-id="73e7b-195">**Charles Richardson。Pattern: API Gateway / Backend for Front-End**（模式：API 网关/用于前端的后端）
    [https://microservices.io/patterns/apigateway.html](https://microservices.io/patterns/apigateway.html)</span><span class="sxs-lookup"><span data-stu-id="73e7b-195">**Charles Richardson. Pattern: API Gateway / Backend for Front-End**
[*https://microservices.io/patterns/apigateway.html*](https://microservices.io/patterns/apigateway.html)</span></span>

-   <span data-ttu-id="73e7b-196">**Azure API 管理**
    [https://azure.microsoft.com/services/api-management/](https://azure.microsoft.com/services/api-management/)</span><span class="sxs-lookup"><span data-stu-id="73e7b-196">**Azure API Management**
[*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span></span>

-   <span data-ttu-id="73e7b-197">**Udi Dahan.Service Oriented Composition**\（面向服务的组合）</span><span class="sxs-lookup"><span data-stu-id="73e7b-197">**Udi Dahan. Service Oriented Composition**\\</span></span>
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)

-   <span data-ttu-id="73e7b-198">**Clemens Vasters。Messaging and Microservices at GOTO 2016**（GOTO 2016 的消息传递和微服务）视频[https://www.youtube.com/watch?v=rXi5CLjIQ9k](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span><span class="sxs-lookup"><span data-stu-id="73e7b-198">**Clemens Vasters. Messaging and Microservices at GOTO 2016** (video) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="73e7b-199">[上一页] (identify-microservice-domain-model-boundaries.md) [下一页] (communication-in-microservice-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="73e7b-199">[Previous] (identify-microservice-domain-model-boundaries.md) [Next] (communication-in-microservice-architecture.md)</span></span>
