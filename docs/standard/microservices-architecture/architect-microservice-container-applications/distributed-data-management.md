---
title: "分布式的数据管理挑战和解决方案"
description: "为容器化的.NET 应用程序的.NET 微服务体系结构 |分布式的数据管理挑战和解决方案"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: f961475b40c74bf448cff1aeae04ae4866360e52
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/22/2017
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="4c67c-104">分布式的数据管理挑战和解决方案</span><span class="sxs-lookup"><span data-stu-id="4c67c-104">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="4c67c-105">质询\#1： 如何定义每个微服务构成的边界</span><span class="sxs-lookup"><span data-stu-id="4c67c-105">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="4c67c-106">定义 microservice 边界可能是任何人都遇到第一次质询。</span><span class="sxs-lookup"><span data-stu-id="4c67c-106">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="4c67c-107">每个微服务必须是一种你的应用程序，并且每个微服务应该自治与所有的优点和它具有的挑战。</span><span class="sxs-lookup"><span data-stu-id="4c67c-107">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="4c67c-108">但是，你如何标识这些边界？</span><span class="sxs-lookup"><span data-stu-id="4c67c-108">But how do you identify those boundaries?</span></span>

<span data-ttu-id="4c67c-109">首先，你需要专注于应用程序的逻辑域模型和相关的数据。</span><span class="sxs-lookup"><span data-stu-id="4c67c-109">First, you need to focus on the application’s logical domain models and related data.</span></span> <span data-ttu-id="4c67c-110">你必须尝试确定的数据和同一个应用程序中的不同上下文分离的岛。</span><span class="sxs-lookup"><span data-stu-id="4c67c-110">You must try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="4c67c-111">每个上下文可能具有不同业务语言 （不同的业务术语表示）。</span><span class="sxs-lookup"><span data-stu-id="4c67c-111">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="4c67c-112">应定义和独立管理上下文。</span><span class="sxs-lookup"><span data-stu-id="4c67c-112">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="4c67c-113">条款和在这些不同的上下文中使用的实体可能听起来类似，但你可能会发现，在特定上下文中，一个业务概念适用于在另一个上下文中，不同的用途并甚至可能具有不同的名称。</span><span class="sxs-lookup"><span data-stu-id="4c67c-113">The terms and entities used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="4c67c-114">例如，用户可以称为客户，则在 CRM 上下文中，为在未排序的上下文中购买者的标识或成员资格的上下文中的用户身份，等等。</span><span class="sxs-lookup"><span data-stu-id="4c67c-114">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="4c67c-115">为每个上下文完全是可以识别每个业务微服务和其相关的边界的方式标识具有不同的域的多个应用程序上下文之间的边界的方式域模型和数据。</span><span class="sxs-lookup"><span data-stu-id="4c67c-115">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="4c67c-116">你始终尝试最大程度减少这些微服务之间的耦合。</span><span class="sxs-lookup"><span data-stu-id="4c67c-116">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="4c67c-117">本指南将进入此部分中的标识和域的模型设计的更多详情[标识每个微服务的域模型边界](#identifying-domain-model-boundaries-for-each-microservice)更高版本。</span><span class="sxs-lookup"><span data-stu-id="4c67c-117">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="4c67c-118">质询\#2： 如何创建从多个微服务中检索数据的查询</span><span class="sxs-lookup"><span data-stu-id="4c67c-118">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="4c67c-119">第二个挑战是如何实现从多个微服务中检索数据，同时可避免聊天式通信到微服务从远程客户端应用程序的查询。</span><span class="sxs-lookup"><span data-stu-id="4c67c-119">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="4c67c-120">一个示例可能是单个屏幕从的移动应用程序需要显示用户拥有的购物篮、 目录和用户标识微服务的信息。</span><span class="sxs-lookup"><span data-stu-id="4c67c-120">An example could be a single screen from a mobile app that needs to show user information that is owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="4c67c-121">另一个示例将涉及位于多个微服务的多个表的复杂报表。</span><span class="sxs-lookup"><span data-stu-id="4c67c-121">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="4c67c-122">正确的解决方案取决于查询的复杂性。</span><span class="sxs-lookup"><span data-stu-id="4c67c-122">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="4c67c-123">但在任何情况下，你将需要聚合信息的方法，如果你想要改进你的系统的通信的效率。</span><span class="sxs-lookup"><span data-stu-id="4c67c-123">But in any case, you will need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="4c67c-124">最常用的解决方案如下所示。</span><span class="sxs-lookup"><span data-stu-id="4c67c-124">The most popular solutions are the following.</span></span>

<span data-ttu-id="4c67c-125">**API 网关**。</span><span class="sxs-lookup"><span data-stu-id="4c67c-125">**API Gateway**.</span></span> <span data-ttu-id="4c67c-126">用于从多个拥有不同的数据库的微服务的简单数据聚合、 建议的方法是称为 API 网关聚合微服务。</span><span class="sxs-lookup"><span data-stu-id="4c67c-126">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="4c67c-127">但是，你需要小心有关实现此模式中，因为它可以压点处于您的系统，并且它可以违反 microservice 自治的原则。</span><span class="sxs-lookup"><span data-stu-id="4c67c-127">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="4c67c-128">若要缓解这种可能性，可以具有多个细粒度 API 网关每一个将重点放在垂直"切片"或业务区域的系统。</span><span class="sxs-lookup"><span data-stu-id="4c67c-128">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical “slice” or business area of the system.</span></span> <span data-ttu-id="4c67c-129">API 网关模式中一节中使用的详细说明了一个 API 网关更高版本。</span><span class="sxs-lookup"><span data-stu-id="4c67c-129">The API Gateway pattern is explained in more detail in the section in the Using an API Gateway later.</span></span>

<span data-ttu-id="4c67c-130">**与查询/读取表 CQRS**。</span><span class="sxs-lookup"><span data-stu-id="4c67c-130">**CQRS with query/reads tables**.</span></span> <span data-ttu-id="4c67c-131">用于从多个微服务聚合数据的另一个解决方案是[具体化视图模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)。</span><span class="sxs-lookup"><span data-stu-id="4c67c-131">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="4c67c-132">在此方法中，你生成，请提前 （之前准备好非规范化的数据的实际查询发生这种情况），具有拥有的多个微服务的数据的只读的表。</span><span class="sxs-lookup"><span data-stu-id="4c67c-132">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that is owned by multiple microservices.</span></span> <span data-ttu-id="4c67c-133">表的格式适合客户端应用程序的需求。</span><span class="sxs-lookup"><span data-stu-id="4c67c-133">The table has a format suited to the client app’s needs.</span></span>

<span data-ttu-id="4c67c-134">请考虑用于移动应用程序的屏幕类似。</span><span class="sxs-lookup"><span data-stu-id="4c67c-134">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="4c67c-135">如果你有一个数据库，你可能使用的 SQL 查询来执行复杂的联接涉及多个表该屏幕的数据获取在一起。</span><span class="sxs-lookup"><span data-stu-id="4c67c-135">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="4c67c-136">但是，当你有多个数据库，并且每个数据库拥有的不同微服务，您无法查询这些数据库和创建 SQL 联接。</span><span class="sxs-lookup"><span data-stu-id="4c67c-136">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="4c67c-137">复杂查询是一项挑战。</span><span class="sxs-lookup"><span data-stu-id="4c67c-137">Your complex query becomes a challenge.</span></span> <span data-ttu-id="4c67c-138">你可以处理使用 CQRS 方法要求-仅用于查询的不同数据库中创建一个非规范化的表。</span><span class="sxs-lookup"><span data-stu-id="4c67c-138">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that is used just for queries.</span></span> <span data-ttu-id="4c67c-139">表可以专为具有所需的应用程序的屏幕和查询表中的列的字段之间的一对一关系的复杂查询所需的数据。</span><span class="sxs-lookup"><span data-stu-id="4c67c-139">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application’s screen and the columns in the query table.</span></span> <span data-ttu-id="4c67c-140">它也无法提供用于报告的数据。</span><span class="sxs-lookup"><span data-stu-id="4c67c-140">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="4c67c-141">此方法不仅解决了原始的问题 （如何查询和联接跨微服务）;它还改进了性能显著时与复杂的联接，进行比较，因为你已有该应用程序需要查询表中的数据。</span><span class="sxs-lookup"><span data-stu-id="4c67c-141">This approach not only solves the original problem (how to query and join across microservices); it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="4c67c-142">当然，查询/读取表中使用命令和查询责任分离 (CQRS) 意味着额外的开发工作，并且将需要采用最终一致性。</span><span class="sxs-lookup"><span data-stu-id="4c67c-142">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you will need to embrace eventual consistency.</span></span> <span data-ttu-id="4c67c-143">但是，对性能和中的高可伸缩性要求[协作方案](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/)（或者竞争的方案，具体取决于角度来看） 是你应在何处应用的多个数据库存在 CQRS。</span><span class="sxs-lookup"><span data-stu-id="4c67c-143">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) is where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="4c67c-144">**在中心数据库中的"冷数据"**。</span><span class="sxs-lookup"><span data-stu-id="4c67c-144">**“Cold data” in central databases**.</span></span> <span data-ttu-id="4c67c-145">对于复杂的报表可能不需要实时数据的查询，常见的方法是导出你"热数据"（从微服务的事务数据） 作为到大型数据库，仅用于报告的"冷数据"。</span><span class="sxs-lookup"><span data-stu-id="4c67c-145">For complex reports and queries that might not require real-time data, a common approach is to export your “hot data” (transactional data from the microservices) as “cold data” into large databases that are used only for reporting.</span></span> <span data-ttu-id="4c67c-146">该中央数据库系统可以是基于大数据的系统，如 Hadoop，类似于基于 Azure SQL 数据仓库或甚至单个 SQL 数据库仅用于报表，（如果大小将不会出现问题） 的数据仓库。</span><span class="sxs-lookup"><span data-stu-id="4c67c-146">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database used just for reports (if size will not be an issue).</span></span>

<span data-ttu-id="4c67c-147">请记住，此集中的数据库将仅用于进行查询和不需要实时数据的报表。</span><span class="sxs-lookup"><span data-stu-id="4c67c-147">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="4c67c-148">原始的更新和事务，为你资料来源，一定要处于微服务数据。</span><span class="sxs-lookup"><span data-stu-id="4c67c-148">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="4c67c-149">将同步数据的方法是通过使用事件驱动的通信 （在后面的部分中介绍） 或使用其他数据库基础结构导入/导出工具。</span><span class="sxs-lookup"><span data-stu-id="4c67c-149">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="4c67c-150">如果你使用事件驱动的通信，则该集成过程将类似于前面所述的 CQRS 查询表传播数据的方式。</span><span class="sxs-lookup"><span data-stu-id="4c67c-150">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="4c67c-151">但是，如果你的应用程序设计涉及不断地聚合从对于复杂的查询的多个微服务的信息，则可能是不好的设计的症状-microservice 应尽可能从其他微服务作为独立。</span><span class="sxs-lookup"><span data-stu-id="4c67c-151">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design—a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="4c67c-152">（这不包括报表/分析始终应使用冷数据中心数据库。）通常遇到此问题可能的原因合并微服务。</span><span class="sxs-lookup"><span data-stu-id="4c67c-152">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="4c67c-153">你需要平衡的变化情况自主性和的强依赖关系、 内聚，与数据聚合的每个微服务的部署。</span><span class="sxs-lookup"><span data-stu-id="4c67c-153">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="4c67c-154">质询\#3： 如何跨多个微服务实现一致性</span><span class="sxs-lookup"><span data-stu-id="4c67c-154">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="4c67c-155">如前面所述，并将数据拥有的每个微服务专用于该微服务仅可通过使用其微服务 API 访问。</span><span class="sxs-lookup"><span data-stu-id="4c67c-155">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="4c67c-156">因此，提供一个难题是如何在跨多个微服务保持一致性的同时实现端到端业务流程。</span><span class="sxs-lookup"><span data-stu-id="4c67c-156">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="4c67c-157">若要分析此问题，让我们看一个示例从[eShopOnContainers 引用应用程序](http://aka.ms/eshoponcontainers)。</span><span class="sxs-lookup"><span data-stu-id="4c67c-157">To analyze this problem, let’s look at an example from the [eShopOnContainers reference application](http://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="4c67c-158">目录微服务会维护有关所有产品，包括其库存级别的信息。</span><span class="sxs-lookup"><span data-stu-id="4c67c-158">The Catalog microservice maintains information about all the products, including their stock level.</span></span> <span data-ttu-id="4c67c-159">排序 microservice 管理订单，并必须验证新的顺序不能超过可用的编录产品库存。</span><span class="sxs-lookup"><span data-stu-id="4c67c-159">The Ordering microservice manages orders and must verify that a new order does not exceed the available catalog product stock.</span></span> <span data-ttu-id="4c67c-160">（或方案可能涉及处理延期交货产品的逻辑。）在此应用程序的假设整体版本，排序子系统无法只需使用 ACID 事务可以检查可用的库存、 订单表中创建订单和更新产品表中的可用库存。</span><span class="sxs-lookup"><span data-stu-id="4c67c-160">(Or the scenario might involve logic that handles backordered products.) In a hypothetical monolithic version of this application, the ordering subsystem could simply use an ACID transaction to check the available stock, create the order in the Orders table, and update the available stock in the Products table.</span></span>

<span data-ttu-id="4c67c-161">但是，在基于微服务的应用中，顺序和产品表由拥有其各自的微服务。</span><span class="sxs-lookup"><span data-stu-id="4c67c-161">However, in a microservices- based application, the Order and Product tables are owned by their respective microservices.</span></span> <span data-ttu-id="4c67c-162">没有 microservice 曾经应包括数据库拥有的另一个微服务在其自己的事务或查询，在图 4-9 中所示。</span><span class="sxs-lookup"><span data-stu-id="4c67c-162">No microservice should ever include databases owned by another microservice in its own transactions or queries, as shown in Figure 4-9.</span></span>

![](./media/image9.PNG)

<span data-ttu-id="4c67c-163">**图 4-9**。</span><span class="sxs-lookup"><span data-stu-id="4c67c-163">**Figure 4-9**.</span></span> <span data-ttu-id="4c67c-164">Microservice 不能直接访问另一个微服务中的表</span><span class="sxs-lookup"><span data-stu-id="4c67c-164">A microservice cannot directly access a table in another microservice</span></span>

<span data-ttu-id="4c67c-165">因为产品表拥有的目录 microservice 排序微服务不应直接，更新产品表。</span><span class="sxs-lookup"><span data-stu-id="4c67c-165">The Ordering microservice should not update the Products table directly, because the Products table is owned by the Catalog microservice.</span></span> <span data-ttu-id="4c67c-166">若要对目录 microservice 进行更新，排序 microservice 永远只有应使用异步通信，例如集成事件 （邮件和基于事件的通信）。</span><span class="sxs-lookup"><span data-stu-id="4c67c-166">To make an update to the Catalog microservice, the Ordering microservice should only ever use asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="4c67c-167">这是如何[eShopOnContainers](http://aka.ms/eshoponcontainers)引用应用程序执行此类型的更新。</span><span class="sxs-lookup"><span data-stu-id="4c67c-167">This is how the [eShopOnContainers](http://aka.ms/eshoponcontainers) reference application performs this type of update.</span></span>

<span data-ttu-id="4c67c-168">中所述[CAP 定理](https://en.wikipedia.org/wiki/CAP_theorem)，你需要可用性和 ACID 强一致性之间进行选择。</span><span class="sxs-lookup"><span data-stu-id="4c67c-168">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="4c67c-169">大多数基于微服务构成的方案要求可用性和而不是强一致性的高可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="4c67c-169">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="4c67c-170">任务关键型应用程序必须始终打开和运行时，开发人员可以使用和工作围绕强一致性技术用于使用弱或最终一致性。</span><span class="sxs-lookup"><span data-stu-id="4c67c-170">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="4c67c-171">这是通过大多数基于微服务的体系结构而采取的做法。</span><span class="sxs-lookup"><span data-stu-id="4c67c-171">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="4c67c-172">此外，ACID 样式或两阶段提交事务不只是针对微服务原则;大多数 NoSQL 数据库 （如 Azure Cosmos DB、 MongoDB 等） 不支持两阶段提交事务。</span><span class="sxs-lookup"><span data-stu-id="4c67c-172">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions.</span></span> <span data-ttu-id="4c67c-173">但是，维护数据在服务和数据库之间的一致性至关重要。</span><span class="sxs-lookup"><span data-stu-id="4c67c-173">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="4c67c-174">应对此挑战还与如何在多个微服务之间传播更改，某些数据需要冗余时这一问题 — 例如，当你需要拥有该产品的名称或目录微服务和购物篮中的说明微服务。</span><span class="sxs-lookup"><span data-stu-id="4c67c-174">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product’s name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="4c67c-175">此问题很好的解决方案是使用微服务说明哪些情况下通过事件驱动的通信和发布和订阅系统之间的最终一致性。</span><span class="sxs-lookup"><span data-stu-id="4c67c-175">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="4c67c-176">这些主题涵盖在部分[事件驱动的异步通信](#async_event_driven_communication)本指南中更高版本。</span><span class="sxs-lookup"><span data-stu-id="4c67c-176">These topics are covered in the section [Asynchronous event-driven communication](#async_event_driven_communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="4c67c-177">质询\#4： 如何设计跨微服务边界的通信</span><span class="sxs-lookup"><span data-stu-id="4c67c-177">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="4c67c-178">在微服务通信边界是真正的挑战。</span><span class="sxs-lookup"><span data-stu-id="4c67c-178">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="4c67c-179">在此上下文中，通信不是指什么协议你应使用 （HTTP 和 REST，AMQP，消息传递，等等）。</span><span class="sxs-lookup"><span data-stu-id="4c67c-179">In this context, communication does not refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="4c67c-180">相反，它解决了应使用何种通信样式，尤其是如何耦合你微服务应为。</span><span class="sxs-lookup"><span data-stu-id="4c67c-180">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="4c67c-181">根据耦合的级别，出现故障时，你的系统上该失败的影响将变化很大。</span><span class="sxs-lookup"><span data-stu-id="4c67c-181">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="4c67c-182">在类似于基于微服务的应用程序，与移动的许多项目和分布式服务分散在许多服务器或主机，分布式系统组件最终将会失败。</span><span class="sxs-lookup"><span data-stu-id="4c67c-182">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="4c67c-183">部分的失败和甚至更大的服务中断将会发生，因此你需要在这些考虑风险常见此类型的分布式系统中设计你微服务以及的通信。</span><span class="sxs-lookup"><span data-stu-id="4c67c-183">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them taking into account the risks common in this type of distributed system.</span></span>

<span data-ttu-id="4c67c-184">常用方法是实现 HTTP (REST)-基于微服务，由于其简单性。</span><span class="sxs-lookup"><span data-stu-id="4c67c-184">A popular approach is to implement HTTP (REST)- based microservices, due to their simplicity.</span></span> <span data-ttu-id="4c67c-185">基于 HTTP 的另一方法是完全可以接受;这里的主要问题与如何使用它。</span><span class="sxs-lookup"><span data-stu-id="4c67c-185">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="4c67c-186">如果使用 HTTP 请求和响应只是为了与你微服务从客户端应用程序或 API 网关进行交互，那也不错。</span><span class="sxs-lookup"><span data-stu-id="4c67c-186">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that is fine.</span></span> <span data-ttu-id="4c67c-187">但如果跨微服务创建的同步的 HTTP 调用的长链，就像微服务是在整体应用程序中，对象在其边界通信你的应用程序最终会遇到问题。</span><span class="sxs-lookup"><span data-stu-id="4c67c-187">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="4c67c-188">例如，假设客户端应用程序可以对如排序 microservice 单个微服务的 HTTP API 调用。</span><span class="sxs-lookup"><span data-stu-id="4c67c-188">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="4c67c-189">如果排序 microservice 反过来调用其他微服务在相同的请求/响应使用 HTTP 周期，你正在使用的 HTTP 调用链。</span><span class="sxs-lookup"><span data-stu-id="4c67c-189">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you are creating a chain of HTTP calls.</span></span> <span data-ttu-id="4c67c-190">它听起来合理最初。</span><span class="sxs-lookup"><span data-stu-id="4c67c-190">It might sound reasonable initially.</span></span> <span data-ttu-id="4c67c-191">但是，有停运此路径时要考虑的重要事项：</span><span class="sxs-lookup"><span data-stu-id="4c67c-191">However, there are important points to consider when going down this path:</span></span>

-   <span data-ttu-id="4c67c-192">阻塞和低性能。</span><span class="sxs-lookup"><span data-stu-id="4c67c-192">Blocking and low performance.</span></span> <span data-ttu-id="4c67c-193">由于 HTTP 同步性质，原始请求不会获得响应，直到所有内部的 HTTP 调用已完成。</span><span class="sxs-lookup"><span data-stu-id="4c67c-193">Due to the synchronous nature of HTTP, the original request will not get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="4c67c-194">假设是否这些调用的数量会显著增加，到微服务构成一个中间的 HTTP 调用的同时被阻止。</span><span class="sxs-lookup"><span data-stu-id="4c67c-194">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="4c67c-195">结果是，性能会受到影响，并且将作为其他 HTTP 请求增加指数级增长影响总体可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="4c67c-195">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

-   <span data-ttu-id="4c67c-196">与 HTTP 耦合微服务。</span><span class="sxs-lookup"><span data-stu-id="4c67c-196">Coupling microservices with HTTP.</span></span> <span data-ttu-id="4c67c-197">不应与其他业务微服务结合业务微服务。</span><span class="sxs-lookup"><span data-stu-id="4c67c-197">Business microservices should not be coupled with other business microservices.</span></span> <span data-ttu-id="4c67c-198">理想情况下，它们应不"知道"有关的其他微服务存在。</span><span class="sxs-lookup"><span data-stu-id="4c67c-198">Ideally, they should not “know” about the existence of other microservices.</span></span> <span data-ttu-id="4c67c-199">如果你的应用程序依赖于耦合如示例所示的微服务，实现每个微服务构成的自治将几乎不可能。</span><span class="sxs-lookup"><span data-stu-id="4c67c-199">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

-   <span data-ttu-id="4c67c-200">在任何一个的微服务时失败。</span><span class="sxs-lookup"><span data-stu-id="4c67c-200">Failure in any one microservice.</span></span> <span data-ttu-id="4c67c-201">如果你实现了微服务时任意微服务失败 （和最终它们将会失败） 的微服务的整个链链接通过 HTTP 调用的链将失败。</span><span class="sxs-lookup"><span data-stu-id="4c67c-201">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="4c67c-202">应设计基于微服务构成的系统能够继续在部分故障期间以及可能工作。</span><span class="sxs-lookup"><span data-stu-id="4c67c-202">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="4c67c-203">即使你实现重试使用指数退让或断路器机制的客户端逻辑，详细的复杂 HTTP 调用链也，它是实现基于 HTTP 的失败策略变得更加复杂。</span><span class="sxs-lookup"><span data-stu-id="4c67c-203">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="4c67c-204">事实上，如果你的内部微服务进行通信通过所述创建的 HTTP 请求的链，它无法将指出性具有整体的应用程序，但根据 HTTP 而不是 intraprocess 通信机制的进程之间。</span><span class="sxs-lookup"><span data-stu-id="4c67c-204">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intraprocess communication mechanisms.</span></span>

<span data-ttu-id="4c67c-205">因此，为了强制实施 microservice 自主性和具有更好的可恢复性，你应尽量少使用的请求/响应通信链跨微服务。</span><span class="sxs-lookup"><span data-stu-id="4c67c-205">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="4c67c-206">建议你将用于虚拟网络间微服务构成通信仅异步交互通过使用异步消息和基于事件的通信，或通过使用 HTTP 轮询与原始 HTTP 请求/响应周期无关。</span><span class="sxs-lookup"><span data-stu-id="4c67c-206">It is recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="4c67c-207">异步通信介绍了如何将包含在部分中的本指南后面的其他详细信息[异步微服务集成将强制使用微服务构成的自治](#asynchronous-microservice-integration-enforce-microservices-autonomy)和[异步基于消息的通信](#asynchronous-message-based-communication)。</span><span class="sxs-lookup"><span data-stu-id="4c67c-207">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice’s autonomy](#asynchronous-microservice-integration-enforce-microservices-autonomy) and [Asynchronous message-based communication](#asynchronous-message-based-communication).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="4c67c-208">其他资源</span><span class="sxs-lookup"><span data-stu-id="4c67c-208">Additional resources</span></span>

-   <span data-ttu-id="4c67c-209">**CAP 定理**
    [*https://en.wikipedia.org/wiki/CAP\_定理*](https://en.wikipedia.org/wiki/CAP_theorem)</span><span class="sxs-lookup"><span data-stu-id="4c67c-209">**CAP theorem**
[*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span></span>

-   <span data-ttu-id="4c67c-210">**最终一致性**
    [*https://en.wikipedia.org/wiki/Eventual\_一致性*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="4c67c-210">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="4c67c-211">**数据一致性入门**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span><span class="sxs-lookup"><span data-stu-id="4c67c-211">**Data Consistency Primer**
[*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span></span>

-   <span data-ttu-id="4c67c-212">**Martin Fowler。CQRS （命令和查询责任分离）**
    [*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span><span class="sxs-lookup"><span data-stu-id="4c67c-212">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)**
[*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span></span>

-   <span data-ttu-id="4c67c-213">**具体化视图**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="4c67c-213">**Materialized View**
[*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span></span>

-   <span data-ttu-id="4c67c-214">**Charles 行。ACID vs。基本： 数据库事务处理的 Shifting pH**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span><span class="sxs-lookup"><span data-stu-id="4c67c-214">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing**
[*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span></span>

-   <span data-ttu-id="4c67c-215">**补偿事务**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="4c67c-215">**Compensating Transaction**
[*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span></span>

-   <span data-ttu-id="4c67c-216">**Udi Dahan。面向服务的组合**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span><span class="sxs-lookup"><span data-stu-id="4c67c-216">**Udi Dahan. Service Oriented Composition**
[*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="4c67c-217">[以前](逻辑-而不是-物理-architecture.md) [下一步] (标识-微服务构成的域-模型-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="4c67c-217">[Previous] (logical-versus-physical-architecture.md) [Next] (identify-microservice-domain-model-boundaries.md)</span></span>
