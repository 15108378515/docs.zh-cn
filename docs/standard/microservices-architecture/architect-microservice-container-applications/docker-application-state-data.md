---
title: Docker 应用程序中的状态和数据
description: 适用于容器化 .NET 应用程序的 .NET 微服务体系结构 | Docker 应用程序中的状态和数据
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.openlocfilehash: c5cfe617335d8150d069149ac87f79206b1b5eca
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/04/2018
ms.locfileid: "33578650"
---
# <a name="state-and-data-in-docker-applications"></a><span data-ttu-id="d1009-103">Docker 应用程序中的状态和数据</span><span class="sxs-lookup"><span data-stu-id="d1009-103">State and data in Docker applications</span></span>

<span data-ttu-id="d1009-104">在大多数情况下，可以将容器视为进程的实例。</span><span class="sxs-lookup"><span data-stu-id="d1009-104">In most cases, you can think of a container as an instance of a process.</span></span> <span data-ttu-id="d1009-105">进程不维护持久状态。</span><span class="sxs-lookup"><span data-stu-id="d1009-105">A process does not maintain persistent state.</span></span> <span data-ttu-id="d1009-106">虽然容器可以写入其本地存储，但假设一个实例将无限期地存在，就像假设内存中的单个位置将是持久的一样。</span><span class="sxs-lookup"><span data-stu-id="d1009-106">While a container can write to its local storage, assuming that an instance will be around indefinitely would be like assuming that a single location in memory will be durable.</span></span> <span data-ttu-id="d1009-107">与进程一样，容器映像应该被假定有多个实例，或它们最终将会终止；如果它们是用容器业务流程协调程序管理的，那么应该假定它们可能从一个节点或 VM 移动到另一个节点或 VM。</span><span class="sxs-lookup"><span data-stu-id="d1009-107">Container images, like processes, should be assumed to have multiple instances or that they will eventually be killed; if they’re managed with a container orchestrator, it should be assumed that they might get moved from one node or VM to another.</span></span>

<span data-ttu-id="d1009-108">Docker 提供一个名为“覆盖文件系统”的功能。</span><span class="sxs-lookup"><span data-stu-id="d1009-108">Docker provides a feature named the *overlay file system*.</span></span> <span data-ttu-id="d1009-109">这实现了写入时复制任务，该任务将更新后的信息存储到容器的根文件系统中。</span><span class="sxs-lookup"><span data-stu-id="d1009-109">This implements a copy-on-write task that stores updated information to the root file system of the container.</span></span> <span data-ttu-id="d1009-110">该信息是容器所基于的原始映射之外的信息。</span><span class="sxs-lookup"><span data-stu-id="d1009-110">That information is in addition to the original image on which the container is based.</span></span> <span data-ttu-id="d1009-111">如果从系统中删除容器，则这些更改将丢失。</span><span class="sxs-lookup"><span data-stu-id="d1009-111">If the container is deleted from the system, those changes are lost.</span></span> <span data-ttu-id="d1009-112">因此，虽然可以在其本地存储中保存容器的状态，但围绕这一点设计一个系统将与容器设计的前提相冲突，而容器设计在默认情况下是无状态的。</span><span class="sxs-lookup"><span data-stu-id="d1009-112">Therefore, while it is possible to save the state of a container within its local storage, designing a system around this would conflict with the premise of container design, which by default is stateless.</span></span>

<span data-ttu-id="d1009-113">以下解决方案用于管理 Docker 应用程序中的持久性数据：</span><span class="sxs-lookup"><span data-stu-id="d1009-113">The following solutions are used to manage persistent data in Docker applications:</span></span>

-   <span data-ttu-id="d1009-114">装载到主机的[数据卷](https://docs.docker.com/engine/tutorials/dockervolumes/)。</span><span class="sxs-lookup"><span data-stu-id="d1009-114">[Data volumes](https://docs.docker.com/engine/tutorials/dockervolumes/) that mount to the host.</span></span>

-   <span data-ttu-id="d1009-115">使用外部容器提供跨容器共享存储的[数据卷容器](https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container)。</span><span class="sxs-lookup"><span data-stu-id="d1009-115">[Data volume containers](https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container) that provide shared storage across containers using an external container.</span></span>

-   <span data-ttu-id="d1009-116">将卷装载到远程服务以提供持久性的[卷插件](https://docs.docker.com/engine/tutorials/dockervolumes/)。</span><span class="sxs-lookup"><span data-stu-id="d1009-116">[Volume plugins](https://docs.docker.com/engine/tutorials/dockervolumes/) that mount volumes to remote services, providing long-term persistence.</span></span>

-   <span data-ttu-id="d1009-117">[Azure 存储](https://docs.microsoft.com/azure/storage/)，提供可异地分发存储，为容器提供良好的持久性解决方案。</span><span class="sxs-lookup"><span data-stu-id="d1009-117">[Azure Storage](https://docs.microsoft.com/azure/storage/), which provides geo-distributable storage, providing a good long-term persistence solution for containers.</span></span>

-   <span data-ttu-id="d1009-118">远程关系数据库（如 [Azure SQL 数据库](https://azure.microsoft.com/services/sql-database/)）或 NoSQL 数据库（如 [Azure Cosmos DB](https://docs.microsoft.com/azure/cosmos-db/introduction)）或缓存服务（如 [Redis](https://redis.io/)）。</span><span class="sxs-lookup"><span data-stu-id="d1009-118">Remote relational databases like [Azure SQL Database](https://azure.microsoft.com/services/sql-database/) or NoSQL databases like [Azure Cosmos DB](https://docs.microsoft.com/azure/cosmos-db/introduction), or cache services like [Redis](https://redis.io/).</span></span>

<span data-ttu-id="d1009-119">下面提供了有关这些选项的更多详细信息。</span><span class="sxs-lookup"><span data-stu-id="d1009-119">The following provides more detail about these options.</span></span>

<span data-ttu-id="d1009-120">数据卷是从主机操作系统映射到容器中目录的目录。</span><span class="sxs-lookup"><span data-stu-id="d1009-120">**Data volumes** are directories mapped from the host OS to directories in containers.</span></span> <span data-ttu-id="d1009-121">当容器中的代码访问该目录时，该访问实际上是对主机操作系统上的一个目录的访问。</span><span class="sxs-lookup"><span data-stu-id="d1009-121">When code in the container has access to the directory, that access is actually to a directory on the host OS.</span></span> <span data-ttu-id="d1009-122">此目录不与容器本身的生存期相关联，并且可以通过直接在主机操作系统上运行的代码或将同一主机目录映射到自身的另一个容器访问该目录。</span><span class="sxs-lookup"><span data-stu-id="d1009-122">This directory is not tied to the lifetime of the container itself, and the directory can be accessed from code running directly on the host OS or by another container that maps the same host directory to itself.</span></span> <span data-ttu-id="d1009-123">因此，数据卷用于将独立于容器的生命周期的数据持久保存。</span><span class="sxs-lookup"><span data-stu-id="d1009-123">Thus, data volumes are designed to persist data independently of the life of the container.</span></span> <span data-ttu-id="d1009-124">如果从 Docker 主机中删除容器或图像，不会删除数据卷中保留的数据。</span><span class="sxs-lookup"><span data-stu-id="d1009-124">If you delete a container or an image from the Docker host, the data persisted in the data volume is not deleted.</span></span> <span data-ttu-id="d1009-125">也可以从主机操作系统访问卷中的数据。</span><span class="sxs-lookup"><span data-stu-id="d1009-125">The data in a volume can be accessed from the host OS as well.</span></span>

<span data-ttu-id="d1009-126">数据卷容器是常规数据卷的演变。</span><span class="sxs-lookup"><span data-stu-id="d1009-126">**Data volume containers** are an evolution of regular data volumes.</span></span> <span data-ttu-id="d1009-127">数据卷容器是一个简单的容器，其中包含一个或多个数据卷。</span><span class="sxs-lookup"><span data-stu-id="d1009-127">A data volume container is a simple container that has one or more data volumes within it.</span></span> <span data-ttu-id="d1009-128">数据卷容器从中央装入点提供对容器的访问。</span><span class="sxs-lookup"><span data-stu-id="d1009-128">The data volume container provides access to containers from a central mount point.</span></span> <span data-ttu-id="d1009-129">这种数据访问方法由于提取了原始数据的位置，因而更方便。</span><span class="sxs-lookup"><span data-stu-id="d1009-129">This method of data access is convenient because it abstracts the location of the original data.</span></span> <span data-ttu-id="d1009-130">除此之外，其行为类似于常规数据卷，因此数据独立于应用程序容器的生命周期，保留于此专用容器中。</span><span class="sxs-lookup"><span data-stu-id="d1009-130">Other than that, its behavior is similar to that of a regular data volume, so data is persisted in this dedicated container independently of the lifecycle of the application’s containers.</span></span>

<span data-ttu-id="d1009-131">如图 4-5 所示，常规 Docker 卷可以存储在容器本身之外，但是在主机服务器或 VM 的物理边界内。</span><span class="sxs-lookup"><span data-stu-id="d1009-131">As shown in Figure 4-5, regular Docker volumes can be stored outside of the containers themselves but within the physical boundaries of the host server or VM.</span></span> <span data-ttu-id="d1009-132">但是，Docker 容器不能从一个主机服务器或 VM 访问另一个主机服务器或 VM 的卷。</span><span class="sxs-lookup"><span data-stu-id="d1009-132">However, Docker containers cannot access a volume from one host server or VM to another.</span></span> <span data-ttu-id="d1009-133">换而言之，使用这些卷，不能用于管理在不同的 Docker 主机运行的容器之间共享的数据</span><span class="sxs-lookup"><span data-stu-id="d1009-133">In other words, with these volumes, it is not possible to manage data shared between containers that run on different Docker hosts</span></span>

![](./media/image5.png)

<span data-ttu-id="d1009-134">**图 4-5**。</span><span class="sxs-lookup"><span data-stu-id="d1009-134">**Figure 4-5**.</span></span> <span data-ttu-id="d1009-135">基于容器的应用程序的数据卷和外部数据源</span><span class="sxs-lookup"><span data-stu-id="d1009-135">Data volumes and external data sources for container-based applications</span></span>

<span data-ttu-id="d1009-136">此外，当 Docker 容器由业务流程协调程序管理时，容器可能会在主机之间“移动”，这取决于集群所执行的优化。</span><span class="sxs-lookup"><span data-stu-id="d1009-136">In addition, when Docker containers are managed by an orchestrator, containers might “move” between hosts, depending on the optimizations performed by the cluster.</span></span> <span data-ttu-id="d1009-137">因此，不建议将数据卷用于业务数据。</span><span class="sxs-lookup"><span data-stu-id="d1009-137">Therefore, it is not recommended that you use data volumes for business data.</span></span> <span data-ttu-id="d1009-138">但它们是一种良好的机制，可以处理跟踪文件、时态文件或类似的不会影响业务数据一致性的文件。</span><span class="sxs-lookup"><span data-stu-id="d1009-138">But they are a good mechanism to work with trace files, temporal files, or similar that will not impact business data consistency.</span></span>

<span data-ttu-id="d1009-139">卷插件（如 [Flocker](https://clusterhq.com/flocker/)）提供了集群中所有主机的数据访问。</span><span class="sxs-lookup"><span data-stu-id="d1009-139">**Volume plugins** like [Flocker](https://clusterhq.com/flocker/) provide data access across all hosts in a cluster.</span></span> <span data-ttu-id="d1009-140">虽然并非所有卷插件都是相同的，但卷插件通常从不可变的容器中提供外部化的持久可靠存储。</span><span class="sxs-lookup"><span data-stu-id="d1009-140">While not all volume plugins are created equally, volume plugins typically provide externalized persistent reliable storage from immutable containers.</span></span>

<span data-ttu-id="d1009-141">远程数据源和缓存工具（如 Azure SQL 数据库、Azure Cosmos DB）或远程缓存（如 Redis）可以在容器化应用程序中使用，与开发时没有容器的使用方式相同。</span><span class="sxs-lookup"><span data-stu-id="d1009-141">**Remote data sources and cache** tools like Azure SQL Database, Azure Cosmos DB, or a remote cache like Redis can be used in containerized applications the same way they are used when developing without containers.</span></span> <span data-ttu-id="d1009-142">这是存储业务应用程序数据的一种行之有效的方法。</span><span class="sxs-lookup"><span data-stu-id="d1009-142">This is a proven way to store business application data.</span></span>

<span data-ttu-id="d1009-143">Azure 存储。</span><span class="sxs-lookup"><span data-stu-id="d1009-143">**Azure Storage.**</span></span> <span data-ttu-id="d1009-144">业务数据通常需要放在外部资源或数据库中，如 Azure 存储。</span><span class="sxs-lookup"><span data-stu-id="d1009-144">Business data usually will need to be placed in external resources or databases, like Azure Storage.</span></span> <span data-ttu-id="d1009-145">Azure 存储在云中具体提供以下服务：</span><span class="sxs-lookup"><span data-stu-id="d1009-145">Azure Storage, in concrete, provides the following services in the cloud:</span></span>

-   <span data-ttu-id="d1009-146">Blob 存储存储非结构化的对象数据。</span><span class="sxs-lookup"><span data-stu-id="d1009-146">Blob storage stores unstructured object data.</span></span> <span data-ttu-id="d1009-147">Blob 可以是任何类型的文本或二进制数据，如文档或媒体文件（图像、音频和视频文件）。</span><span class="sxs-lookup"><span data-stu-id="d1009-147">A blob can be any type of text or binary data, such as document or media files (images, audio, and video files).</span></span> <span data-ttu-id="d1009-148">Blob 存储也称为对象存储。</span><span class="sxs-lookup"><span data-stu-id="d1009-148">Blob storage is also referred to as Object storage.</span></span>

-   <span data-ttu-id="d1009-149">文件存储为使用标准 SMB 协议的旧版应用程序提供共享存储。</span><span class="sxs-lookup"><span data-stu-id="d1009-149">File storage offers shared storage for legacy applications using standard SMB protocol.</span></span> <span data-ttu-id="d1009-150">Azure 虚拟机和云服务可以通过装载的共享在应用程序组件之间共享文件数据。</span><span class="sxs-lookup"><span data-stu-id="d1009-150">Azure virtual machines and cloud services can share file data across application components via mounted shares.</span></span> <span data-ttu-id="d1009-151">本地应用程序可以通过文件服务 REST API 访问共享中的文件数据。</span><span class="sxs-lookup"><span data-stu-id="d1009-151">On-premises applications can access file data in a share via the File service REST API.</span></span>

-   <span data-ttu-id="d1009-152">表存储存储结构化数据集。</span><span class="sxs-lookup"><span data-stu-id="d1009-152">Table storage stores structured datasets.</span></span> <span data-ttu-id="d1009-153">表存储是 NoSQL 键属性数据存储，它允许快速开发和快速访问大量数据。</span><span class="sxs-lookup"><span data-stu-id="d1009-153">Table storage is a NoSQL key-attribute data store, which allows rapid development and fast access to large quantities of data.</span></span>

<span data-ttu-id="d1009-154">关系数据库和 NoSQL 数据库。</span><span class="sxs-lookup"><span data-stu-id="d1009-154">**Relational databases and NoSQL databases.**</span></span> <span data-ttu-id="d1009-155">外部数据库有很多选择，包括关系数据库（如 SQL Server、PostgreSQL、Oracle）或 NoSQL 数据库（如 Azure Cosmos DB、MongoDB）等。这些数据库将不会作为本指南的一部分加以解释，因为它们在一个完全不同的主题中。</span><span class="sxs-lookup"><span data-stu-id="d1009-155">There are many choices for external databases, from relational databases like SQL Server, PostgreSQL, Oracle, or NoSQL databases like Azure Cosmos DB, MongoDB, etc. These databases are not going to be explained as part of this guide since they are in a completely different subject.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="d1009-156">[上一篇] (containerize-monolithic-applications.md) [下一篇] (service-oriented-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="d1009-156">[Previous] (containerize-monolithic-applications.md) [Next] (service-oriented-architecture.md)</span></span>
