---
title: "标识每个微服务的域模型边界"
description: "为容器化的.NET 应用程序的.NET 微服务体系结构 |标识每个微服务的域模型边界"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 6fef11e5718706701abb29149c4c4a23ba39bde0
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/22/2017
---
# <a name="identify-domain-model-boundaries-for-each-microservice"></a><span data-ttu-id="90b64-104">标识每个微服务的域模型边界</span><span class="sxs-lookup"><span data-stu-id="90b64-104">Identify domain-model boundaries for each microservice</span></span>

<span data-ttu-id="90b64-105">在标识模型边界和每个微服务构成的大小的目标是不获取到的最高粒度分离有可能，尽管应尽可能往往向小微服务。</span><span class="sxs-lookup"><span data-stu-id="90b64-105">The goal when identifying model boundaries and size for each microservice is not to get to the most granular separation possible, although you should tend toward small microservices if possible.</span></span> <span data-ttu-id="90b64-106">相反，你的目标应是可用于访问由你的域知识指导的最有意义分离。</span><span class="sxs-lookup"><span data-stu-id="90b64-106">Instead, your goal should be to get to the most meaningful separation guided by your domain knowledge.</span></span> <span data-ttu-id="90b64-107">重点不是于此大小，而是在业务功能。</span><span class="sxs-lookup"><span data-stu-id="90b64-107">The emphasis is not on the size, but instead on business capabilities.</span></span> <span data-ttu-id="90b64-108">此外，如果没有清除内聚需要某些区的应用程序基于大量的依赖关系，指示单个 microservice，需过。</span><span class="sxs-lookup"><span data-stu-id="90b64-108">In addition, if there is clear cohesion needed for a certain area of the application based on a high number of dependencies, that indicates the need for a single microservice, too.</span></span> <span data-ttu-id="90b64-109">聚合是一种方法来确定如何分离或组一起微服务。</span><span class="sxs-lookup"><span data-stu-id="90b64-109">Cohesion is a way to identify how to break apart or group together microservices.</span></span> <span data-ttu-id="90b64-110">从根本上讲，而获得有关域的详细知识，你应以迭代方式调整你 microservice 的大小。</span><span class="sxs-lookup"><span data-stu-id="90b64-110">Ultimately, while you gain more knowledge about the domain, you should adapt the size of your microservice, iteratively.</span></span> <span data-ttu-id="90b64-111">查找适当的大小不是一个单步过程。</span><span class="sxs-lookup"><span data-stu-id="90b64-111">Finding the right size is not a one-shot process.</span></span>

<span data-ttu-id="90b64-112">[Sam Newman](http://samnewman.io/)的微服务和书籍的作者识别提升程序[构建微服务](http://samnewman.io/books/building_microservices/)，突出显示，你应设计基于绑定上下文 (BC) 模式 （的一部分你微服务域驱动设计），因为引入了更早版本。</span><span class="sxs-lookup"><span data-stu-id="90b64-112">[Sam Newman](http://samnewman.io/), a recognized promoter of microservices and author of the book [Building Microservices](http://samnewman.io/books/building_microservices/), highlights that you should design your microservices based on the Bounded Context (BC) pattern (part of domain-driven design), as introduced earlier.</span></span> <span data-ttu-id="90b64-113">有时，可能由业务连续性构成的多个物理服务，但反之则不然。</span><span class="sxs-lookup"><span data-stu-id="90b64-113">Sometimes, a BC could be composed of several physical services, but not vice versa.</span></span>

<span data-ttu-id="90b64-114">具有特定域实体的域模型中具体的业务连续性适用或微服务。</span><span class="sxs-lookup"><span data-stu-id="90b64-114">A domain model with specific domain entities applies within a concrete BC or microservice.</span></span> <span data-ttu-id="90b64-115">业务连续性分隔的域模型适用性和提供开发人员团队成员必须是什么凝聚力和新增功能可以单独开发的清除和共享了解。</span><span class="sxs-lookup"><span data-stu-id="90b64-115">A BC delimits the applicability of a domain model and gives developer team members a clear and shared understanding of what must be cohesive and what can be developed independently.</span></span> <span data-ttu-id="90b64-116">这些是微服务的相同目标。</span><span class="sxs-lookup"><span data-stu-id="90b64-116">These are the same goals for microservices.</span></span>

<span data-ttu-id="90b64-117">通知设计选择的另一个工具是[Conway 定律](https://en.wikipedia.org/wiki/Conway%27s_law)，所处的状态的应用程序将反映生成它的组织的社交边界。</span><span class="sxs-lookup"><span data-stu-id="90b64-117">Another tool that informs your design choice is [Conway’s law](https://en.wikipedia.org/wiki/Conway%27s_law), which states that an application will reflect the social boundaries of the organization that produced it.</span></span> <span data-ttu-id="90b64-118">但有时反过来也成立-公司的组织的正确的软件。</span><span class="sxs-lookup"><span data-stu-id="90b64-118">But sometimes the opposite is true—the company’s organization is formed by the software.</span></span> <span data-ttu-id="90b64-119">你可能需要反向 Conway 定律和生成边界你想要进行组织的公司的方式向业务流程咨询倾斜。</span><span class="sxs-lookup"><span data-stu-id="90b64-119">You might need to reverse Conway’s law and build the boundaries the way you want the company to be organized, leaning toward business process consulting.</span></span>

<span data-ttu-id="90b64-120">若要识别界限的上下文，可以使用此一个 DDD 模式是[上下文映射模式](https://www.infoq.com/articles/ddd-contextmapping)。</span><span class="sxs-lookup"><span data-stu-id="90b64-120">In order to identify bounded contexts, a DDD pattern that can be used for this is the [Context Mapping pattern](https://www.infoq.com/articles/ddd-contextmapping).</span></span> <span data-ttu-id="90b64-121">上下文映射，需要标识中应用程序和其边界的各种上下文。</span><span class="sxs-lookup"><span data-stu-id="90b64-121">With Context Mapping, you identify the various contexts in the application and their boundaries.</span></span> <span data-ttu-id="90b64-122">很常见，例如具有不同的上下文以及对于每个小子系统的边界。</span><span class="sxs-lookup"><span data-stu-id="90b64-122">It is common to have a different context and boundary for each small subsystem, for instance.</span></span> <span data-ttu-id="90b64-123">上下文映射是一种方法来定义和明确这些边界域之间。</span><span class="sxs-lookup"><span data-stu-id="90b64-123">The Context Map is a way to define and make explicit those boundaries between domains.</span></span> <span data-ttu-id="90b64-124">业务连续性是自治，包括单个域的详细信息-如域实体，并定义与其他 BCs 集成协定。</span><span class="sxs-lookup"><span data-stu-id="90b64-124">A BC is autonomous and includes the details of a single domain—details like the domain entities—and defines integration contracts with other BCs.</span></span> <span data-ttu-id="90b64-125">它类似于微服务构成的定义： 它是自治，它实现某些域功能，它必须提供接口。</span><span class="sxs-lookup"><span data-stu-id="90b64-125">This is similar to the definition of a microservice: it is autonomous, it implements certain domain capability, and it must provide interfaces.</span></span> <span data-ttu-id="90b64-126">这是为什么上下文映射和绑定上下文模式是用于标识你微服务的域模型边界的好方法。</span><span class="sxs-lookup"><span data-stu-id="90b64-126">This is why Context Mapping and the Bounded Context pattern are good approaches for identifying the domain model boundaries of your microservices.</span></span>

<span data-ttu-id="90b64-127">在设计大型应用程序时，你将看到其域模型可能存在碎片-从目录域域专家将命名实体不同域中的资源目录和清单专家，传送域不同的实例。</span><span class="sxs-lookup"><span data-stu-id="90b64-127">When designing a large application, you will see how its domain model can be fragmented — a domain expert from the catalog domain will name entities differently in the catalog and inventory domains than a shipping domain expert, for instance.</span></span> <span data-ttu-id="90b64-128">或者处理 CRM 专家想要存储每个非排序的域专业人员只需要有关客户的部分数据比客户有关的详细信息时，用户域实体可能是不同的大小和属性数目。</span><span class="sxs-lookup"><span data-stu-id="90b64-128">Or the user domain entity might be different in size and number of attributes when dealing with a CRM expert who wants to store every detail about the customer than for an ordering domain expert who just needs partial data about the customer.</span></span> <span data-ttu-id="90b64-129">它是很难消除所有域条款都歧义与大型应用程序相关的所有域。</span><span class="sxs-lookup"><span data-stu-id="90b64-129">It is very hard to disambiguate all domain terms across all the domains related to a large application.</span></span> <span data-ttu-id="90b64-130">但最重要的一点是，你不应尝试统一条款;应改为接受的差异和提供的每个域的丰富功能。</span><span class="sxs-lookup"><span data-stu-id="90b64-130">But the most important thing is that you should not try to unify the terms; instead, accept the differences and richness provided by each domain.</span></span> <span data-ttu-id="90b64-131">如果你尝试有一个统一的数据库，对整个应用程序，尝试在统一词汇将繁琐，并且不听起来右到多个域专业人员的任何。</span><span class="sxs-lookup"><span data-stu-id="90b64-131">If you try to have a unified database for the whole application, attempts at a unified vocabulary will be awkward and will not sound right to any of the multiple domain experts.</span></span> <span data-ttu-id="90b64-132">因此，BCs （微服务作为实现） 将帮助你以阐明，你可以使用某些域条款，并且你需要进行拆分系统，并使用不同的域中创建其他 BCs。</span><span class="sxs-lookup"><span data-stu-id="90b64-132">Therefore, BCs (implemented as microservices) will help you to clarify where you can use certain domain terms and where you will need to split the system and create additional BCs with different domains.</span></span>

<span data-ttu-id="90b64-133">您将知道你右边界和每个业务连续性的大小，并且域模型如果你有几个强关系之间域模型，并且您没有通常不需要合并来自多个域模型的信息时执行典型的应用程序操作。</span><span class="sxs-lookup"><span data-stu-id="90b64-133">You will know that you got the right boundaries and sizes of each BC and domain model if you have few strong relationships between domain models, and you do not usually need to merge information from multiple domain models when performing typical application operations.</span></span>

<span data-ttu-id="90b64-134">每个微服务的域模型应该多大的问题的最佳答案可能是以下： 它应具有自治的业务连续性，作为独立尽可能，可用于工作，而无不断地切换到其他上下文 （其他微服务构成的模型）。</span><span class="sxs-lookup"><span data-stu-id="90b64-134">Perhaps the best answer to the question of how big a domain model for each microservice should be is the following: it should have an autonomous BC, as isolated as possible, that enables you to work without having to constantly switch to other contexts (other microservice’s models).</span></span> <span data-ttu-id="90b64-135">图 4-10 可以看到如何多个微服务 (多个 BCs) 拥有其自己的模型和如何其实体定义，具体取决于每个应用程序中标识的域特定的要求。</span><span class="sxs-lookup"><span data-stu-id="90b64-135">In Figure 4-10 you can see how multiple microservices (multiple BCs) each have their own model and how their entities can be defined, depending on the specific requirements for each of the identified domains in your application.</span></span>

![](./media/image10.png)

<span data-ttu-id="90b64-136">**图 4-10**。</span><span class="sxs-lookup"><span data-stu-id="90b64-136">**Figure 4-10**.</span></span> <span data-ttu-id="90b64-137">确定实体和微服务模型边界</span><span class="sxs-lookup"><span data-stu-id="90b64-137">Identifying entities and microservice model boundaries</span></span>

<span data-ttu-id="90b64-138">图 4-10 演示了与联机会议管理系统的示例方案。</span><span class="sxs-lookup"><span data-stu-id="90b64-138">Figure 4-10 illustrates a sample scenario related to an online conference management system.</span></span> <span data-ttu-id="90b64-139">已标识就可以实现为微服务，基于域专家定义为你的域的多个 BCs。</span><span class="sxs-lookup"><span data-stu-id="90b64-139">You have identified several BCs that could be implemented as microservices, based on domains that domain experts defined for you.</span></span> <span data-ttu-id="90b64-140">如你所见，有仅在单个微服务模型中，如付款付款微服务中存在的实体。</span><span class="sxs-lookup"><span data-stu-id="90b64-140">As you can see, there are entities that are present just in a single microservice model, like Payments in the Payment microservice.</span></span> <span data-ttu-id="90b64-141">这些将容易实现。</span><span class="sxs-lookup"><span data-stu-id="90b64-141">Those will be easy to implement.</span></span>

<span data-ttu-id="90b64-142">但是，您还可能具有不同的形状，但在从多个微服务的多个域模型之间共享相同的标识的实体。</span><span class="sxs-lookup"><span data-stu-id="90b64-142">However, you might also have entities that have a different shape but share the same identity across the multiple domain models from the multiple microservices.</span></span> <span data-ttu-id="90b64-143">例如，在有关参加会议管理微服务中标识的用户实体。</span><span class="sxs-lookup"><span data-stu-id="90b64-143">For example, the User entity is identified in the Conferences Management microservice.</span></span> <span data-ttu-id="90b64-144">相同的用户，具有相同的标识，是一个在排序微服务，名为购买者或付款微服务，并甚至客户服务微服务中的一个命名的客户中一个名为的纳税人。</span><span class="sxs-lookup"><span data-stu-id="90b64-144">That same user, with the same identity, is the one named Buyers in the Ordering microservice, or the one named Payer in the Payment microservice, and even the one named Customer in the Customer Service microservice.</span></span> <span data-ttu-id="90b64-145">这是因为，具体取决于[无处不在语言](https://martinfowler.com/bliki/UbiquitousLanguage.html)使用每个域专家，用户可能会有不同的角度来看，甚至具有不同的属性。</span><span class="sxs-lookup"><span data-stu-id="90b64-145">This is because, depending on the [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) that each domain expert is using, a user might have a different perspective even with different attributes.</span></span> <span data-ttu-id="90b64-146">名为有关参加会议管理微服务模型中的用户实体可能已将其个人数据特性的大多数。</span><span class="sxs-lookup"><span data-stu-id="90b64-146">The user entity in the microservice model named Conferences Management might have most of its personal data attributes.</span></span> <span data-ttu-id="90b64-147">但是，在 microservice 付款或中的客户 microservice 客户服务中的形状的纳税人形状中相同的用户可能不需要相同的属性列表。</span><span class="sxs-lookup"><span data-stu-id="90b64-147">However, that same user in the shape of Payer in the microservice Payment or in the shape of Customer in the microservice Customer Service might not need the same list of attributes.</span></span>

<span data-ttu-id="90b64-148">类似的方法进行了阐释图 4-11。</span><span class="sxs-lookup"><span data-stu-id="90b64-148">A similar approach is illustrated in Figure 4-11.</span></span>

![](./media/image11.png)

<span data-ttu-id="90b64-149">**图 4-11**。</span><span class="sxs-lookup"><span data-stu-id="90b64-149">**Figure 4-11**.</span></span> <span data-ttu-id="90b64-150">将传统的数据模型分解成多个域模型</span><span class="sxs-lookup"><span data-stu-id="90b64-150">Decomposing traditional data models into multiple domain models</span></span>

<span data-ttu-id="90b64-151">你可以看到如何用户存在有关参加会议管理 microservice 模型作为用户实体中，并且也是定价 microservice，具有备用的属性或实际购买者时的用户详细信息中的 Buyer 实体形式存在。</span><span class="sxs-lookup"><span data-stu-id="90b64-151">You can see how the user is present in the Conferences Management microservice model as the User entity and is also present in the form of the Buyer entity in the Pricing microservice, with alternate attributes or details about the user when it is actually a buyer.</span></span> <span data-ttu-id="90b64-152">每个微服务或业务连续性可能不需要与用户实体，只是部分，具体取决于要解决的问题或上下文相关的所有数据。</span><span class="sxs-lookup"><span data-stu-id="90b64-152">Each microservice or BC might not need all the data related to a User entity, just part of it, depending on the problem to solve or the context.</span></span> <span data-ttu-id="90b64-153">例如，在定价微服务模型中，你不需要的地址或用户，只需 ID (标识） 和状态，这将影响对折扣时定价每 buyer 座位的 ID。</span><span class="sxs-lookup"><span data-stu-id="90b64-153">For instance, in the Pricing microservice model, you do not need the address or the ID of the user, just ID (as identity) and Status, which will have an impact on discounts when pricing the seats per buyer.</span></span>

<span data-ttu-id="90b64-154">座位实体具有相同名称但不同的属性，每个域模型中。</span><span class="sxs-lookup"><span data-stu-id="90b64-154">The Seat entity has the same name but different attributes in each domain model.</span></span> <span data-ttu-id="90b64-155">但是，座位共享标识基于相同的 ID，就像使用用户和购买。</span><span class="sxs-lookup"><span data-stu-id="90b64-155">However, Seat shares identity based on the same ID, as happens with User and Buyer.</span></span>

<span data-ttu-id="90b64-156">基本上，是用户的共享存在于多个服务 （域），所有的共享该用户的标识的概念。</span><span class="sxs-lookup"><span data-stu-id="90b64-156">Basically, there is a shared concept of a user that exists in multiple services (domains), which all share the identity of that user.</span></span> <span data-ttu-id="90b64-157">但每个域模型中可能有其他或不同的详细信息，有关该用户实体。</span><span class="sxs-lookup"><span data-stu-id="90b64-157">But in each domain model there might be additional or different details about the user entity.</span></span> <span data-ttu-id="90b64-158">因此，需要一种方法映射到另一个域 （微服务） 从一个用户实体。</span><span class="sxs-lookup"><span data-stu-id="90b64-158">Therefore, there needs to be a way to map a user entity from one domain (microservice) to another.</span></span>

<span data-ttu-id="90b64-159">有多个好处不与相同的属性数目跨域共享相同的用户实体。</span><span class="sxs-lookup"><span data-stu-id="90b64-159">There are several benefits to not sharing the same user entity with the same number of attributes across domains.</span></span> <span data-ttu-id="90b64-160">一个好处是减少重复项，以便 microservice 模型没有他们并不需要任何数据。</span><span class="sxs-lookup"><span data-stu-id="90b64-160">One benefit is to reduce duplication, so that microservice models do not have any data that they do not need.</span></span> <span data-ttu-id="90b64-161">另一个好处使拥有某种类型的每个实体的数据，以便更新和查询该类型的数据驱动只能由该 microservice master 微服务。</span><span class="sxs-lookup"><span data-stu-id="90b64-161">Another benefit is having a master microservice that owns a certain type of data per entity so that updates and queries for that type of data are driven only by that microservice.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="90b64-162">[以前](分布式的数据-management.md) [下一步] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)</span><span class="sxs-lookup"><span data-stu-id="90b64-162">[Previous] (distributed-data-management.md) [Next] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)</span></span>
