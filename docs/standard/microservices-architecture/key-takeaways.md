---
title: "记住的要点"
description: "为容器化的.NET 应用程序的.NET 微服务体系结构 |记住的要点"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: b557d0b641bfe95c025cadb13f82c3f8927f4bc8
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/18/2017
---
# <a name="key-takeaways"></a><span data-ttu-id="d6411-104">记住的要点</span><span class="sxs-lookup"><span data-stu-id="d6411-104">Key Takeaways</span></span>

<span data-ttu-id="d6411-105">作为摘要，并记住的要点，以下是利用本指南的最重要的结论。</span><span class="sxs-lookup"><span data-stu-id="d6411-105">As a summary and key takeaways, the following are the most important conclusions from this guide.</span></span>

<span data-ttu-id="d6411-106">**使用容器的好处。**</span><span class="sxs-lookup"><span data-stu-id="d6411-106">**Benefits of using containers.**</span></span> <span data-ttu-id="d6411-107">容器基于解决方案提供成本节省的重要优势，因为容器是因为缺少生产环境中的依赖关系的部署问题的解决方案。</span><span class="sxs-lookup"><span data-stu-id="d6411-107">Container-based solutions provide the important benefit of cost savings because containers are a solution to deployment problems caused by the lack of dependencies in production environments.</span></span> <span data-ttu-id="d6411-108">容器显著提高 DevOps 和生产操作。</span><span class="sxs-lookup"><span data-stu-id="d6411-108">Containers significantly improve DevOps and production operations.</span></span>

<span data-ttu-id="d6411-109">**容器将无处不在。**</span><span class="sxs-lookup"><span data-stu-id="d6411-109">**Containers will be ubiquitous.**</span></span> <span data-ttu-id="d6411-110">基于 docker 容器变得在容器行业中，支持的 Windows 和 Linux 生态系统中最重要供应商事实上的标准。</span><span class="sxs-lookup"><span data-stu-id="d6411-110">Docker-based containers are becoming the de facto standard in the container industry, supported by the most significant vendors in the Windows and Linux ecosystems.</span></span> <span data-ttu-id="d6411-111">这包括 Microsoft、 Amazon AWS、 Google、 和 IBM。</span><span class="sxs-lookup"><span data-stu-id="d6411-111">This includes Microsoft, Amazon AWS, Google, and IBM.</span></span> <span data-ttu-id="d6411-112">在不久的将来，Docker 将可能无处不在云中和本地数据中心内。</span><span class="sxs-lookup"><span data-stu-id="d6411-112">In the near future, Docker will probably be ubiquitous in both cloud and on-premises datacenters.</span></span>

<span data-ttu-id="d6411-113">**作为一个单元部署的容器。**</span><span class="sxs-lookup"><span data-stu-id="d6411-113">**Containers as a unit of deployment.**</span></span> <span data-ttu-id="d6411-114">Docker 容器变得越来越部署的任何基于服务器的应用程序或服务的标准单位。</span><span class="sxs-lookup"><span data-stu-id="d6411-114">A Docker container is becoming the standard unit of deployment for any server-based application or service.</span></span>

<span data-ttu-id="d6411-115">**微服务。**</span><span class="sxs-lookup"><span data-stu-id="d6411-115">**Microservices.**</span></span> <span data-ttu-id="d6411-116">微服务体系结构已变得分布式和大型或复杂任务关键型应用程序基于自治服务形式的多个独立子系统的首选的方法。</span><span class="sxs-lookup"><span data-stu-id="d6411-116">The microservices architecture is becoming the preferred approach for distributed and large or complex mission-critical applications based on multiple independent subsystems in the form of autonomous services.</span></span> <span data-ttu-id="d6411-117">在基于微服务的体系结构，该应用程序生成的服务可以是开发、 测试、 版本控制的部署，并且独立; 扩展的集合为这可能包括任何相关的自治数据库。</span><span class="sxs-lookup"><span data-stu-id="d6411-117">In a microservice-based architecture, the application is built as a collection of services that can be developed, tested, versioned, deployed, and scaled independently; this can include any related autonomous database.</span></span>

<span data-ttu-id="d6411-118">**域驱动的设计和 SOA。**</span><span class="sxs-lookup"><span data-stu-id="d6411-118">**Domain-driven design and SOA.**</span></span> <span data-ttu-id="d6411-119">从面向服务的体系结构 (SOA) 和域驱动设计 (DDD) 派生的微服务体系结构模式。</span><span class="sxs-lookup"><span data-stu-id="d6411-119">The microservices architecture patterns derive from service-oriented architecture (SOA) and domain-driven design (DDD).</span></span> <span data-ttu-id="d6411-120">当你在设计和开发不断变化的业务规则调整特定域的环境的微服务时，务必考虑到帐户 DDD 方法和模式。</span><span class="sxs-lookup"><span data-stu-id="d6411-120">When you design and develop microservices for environments with evolving business rules shaping a particular domain, it is important to take into account DDD approaches and patterns.</span></span>

<span data-ttu-id="d6411-121">**微服务挑战。**</span><span class="sxs-lookup"><span data-stu-id="d6411-121">**Microservices challenges.**</span></span> <span data-ttu-id="d6411-122">微服务提供许多强大的功能，如部署独立于、 强子系统边界和技术多样性。</span><span class="sxs-lookup"><span data-stu-id="d6411-122">Microservices offer many powerful capabilities, like independent deployment, strong subsystem boundaries, and technology diversity.</span></span> <span data-ttu-id="d6411-123">但是，它们也会引发许多如分片与分布式应用程序开发相关的新挑战和独立的数据模型、 弹性通信微服务、 最终一致性和操作的结果的复杂性之间聚合来自多个微服务的日志记录和监视信息。</span><span class="sxs-lookup"><span data-stu-id="d6411-123">However, they also raise many new challenges related to distributed application development, such as fragmented and independent data models, resilient communication between microservices, eventual consistency, and operational complexity that results from aggregating logging and monitoring information from multiple microservices.</span></span> <span data-ttu-id="d6411-124">这些方面引入比传统的整体应用程序的复杂性更高级别。</span><span class="sxs-lookup"><span data-stu-id="d6411-124">These aspects introduce a higher level of complexity than a traditional monolithic application.</span></span> <span data-ttu-id="d6411-125">因此，仅特定方案都适用于基于微服务构成的应用程序。</span><span class="sxs-lookup"><span data-stu-id="d6411-125">As a result, only specific scenarios are suitable for microservice-based applications.</span></span> <span data-ttu-id="d6411-126">其中包括多个不断发展子系统; 大型和复杂的应用程序在这些情况下，值得投资在更复杂的软件体系结构，因为它将提供更好地长期的灵活性和应用程序维护。</span><span class="sxs-lookup"><span data-stu-id="d6411-126">These include large and complex applications with multiple evolving subsystems; in these cases, it is worth investing in a more complex software architecture, because it will provide better long-term agility and application maintenance.</span></span>

<span data-ttu-id="d6411-127">**任何应用程序的的容器。**</span><span class="sxs-lookup"><span data-stu-id="d6411-127">**Containers for any application.**</span></span> <span data-ttu-id="d6411-128">容器便于微服务，但不是会为它们排他。</span><span class="sxs-lookup"><span data-stu-id="d6411-128">Containers are convenient for microservices, but are not exclusive for them.</span></span> <span data-ttu-id="d6411-129">此外可以与整体应用程序，包括基于传统的.NET Framework 和 Windows 容器通过得到改进的旧版应用程序使用容器。</span><span class="sxs-lookup"><span data-stu-id="d6411-129">Containers can also be used with monolithic applications, including legacy applications based on the traditional .NET Framework and modernized through Windows Containers.</span></span> <span data-ttu-id="d6411-130">使用 Docker，例如解决许多部署到生产问题并提供最先进的开发和测试环境的优点适用于许多不同类型的应用程序。</span><span class="sxs-lookup"><span data-stu-id="d6411-130">The benefits of using Docker, such as solving many deployment-to-production issues and providing state of the art Dev and Test environments, apply to many different types of applications.</span></span>

<span data-ttu-id="d6411-131">**与 IDE CLI。**</span><span class="sxs-lookup"><span data-stu-id="d6411-131">**CLI versus IDE.**</span></span> <span data-ttu-id="d6411-132">与 Microsoft 工具，你可以开发使用你首选的方法的容器化的.NET 应用程序。</span><span class="sxs-lookup"><span data-stu-id="d6411-132">With Microsoft tools, you can develop containerized .NET applications using your preferred approach.</span></span> <span data-ttu-id="d6411-133">你可以通过使用 Docker CLI 和 Visual Studio Code 开发使用 CLI 和基于编辑器的环境。</span><span class="sxs-lookup"><span data-stu-id="d6411-133">You can develop with a CLI and an editor-based environment by using the Docker CLI and Visual Studio Code.</span></span> <span data-ttu-id="d6411-134">或者你可以使用专注于 IDE 的方法与 Visual Studio 和其独特的功能对 Docker，如能够调试多容器应用程序。</span><span class="sxs-lookup"><span data-stu-id="d6411-134">Or you can use an IDE-focused approach with Visual Studio and its unique features for Docker, such as like being able to debug multi-container applications.</span></span>

<span data-ttu-id="d6411-135">**弹性云应用程序。**</span><span class="sxs-lookup"><span data-stu-id="d6411-135">**Resilient cloud applications.**</span></span> <span data-ttu-id="d6411-136">在基于云的系统和分布式的系统一般情况下，都始终部分的失败的风险。</span><span class="sxs-lookup"><span data-stu-id="d6411-136">In cloud-based systems and distributed systems in general, there is always the risk of partial failure.</span></span> <span data-ttu-id="d6411-137">由于客户端和服务都是单独的进程 （容器），服务可能无法及时方式与客户端的请求作出响应。</span><span class="sxs-lookup"><span data-stu-id="d6411-137">Since clients and services are separate processes (containers), a service might not be able to respond in a timely way to a client’s request.</span></span> <span data-ttu-id="d6411-138">例如，服务出现部分的失败或进行维护; 可能已关闭该服务可能重载，响应速度极慢于请求;或它可能只是无法访问在短时间由于网络问题。</span><span class="sxs-lookup"><span data-stu-id="d6411-138">For example, a service might be down because of a partial failure or for maintenance; the service might be overloaded and responding extremely slowly to requests; or it might simply not be accessible for a short time because of network issues.</span></span> <span data-ttu-id="d6411-139">因此，基于云的应用程序必须接受这些故障，并且具有策略设置，以响应这些故障。</span><span class="sxs-lookup"><span data-stu-id="d6411-139">Therefore, a cloud-based application must embrace those failures and have a strategy in place to respond to those failures.</span></span> <span data-ttu-id="d6411-140">这些策略可以包括重试策略 （重新发送消息或重试请求） 和实现的断路器模式，以避免指数负载的重复请求。</span><span class="sxs-lookup"><span data-stu-id="d6411-140">These strategies can include retry policies (resending messages or retrying requests) and implementing circuit-breaker patterns to avoid exponential load of repeated requests.</span></span> <span data-ttu-id="d6411-141">基本上，基于云的应用程序必须具有弹性的机制-自定义违规时，或者是基于云的基础结构，例如从 orchestrators 或服务总线高级框架。</span><span class="sxs-lookup"><span data-stu-id="d6411-141">Basically, cloud-based applications must have resilient mechanisms—either custom ones, or ones based on cloud infrastructure, such as high-level frameworks from orchestrators or service buses.</span></span>

<span data-ttu-id="d6411-142">**安全。**</span><span class="sxs-lookup"><span data-stu-id="d6411-142">**Security.**</span></span> <span data-ttu-id="d6411-143">我们现代世界中的容器和微服务可以公开新的漏洞。</span><span class="sxs-lookup"><span data-stu-id="d6411-143">Our modern world of containers and microservices can expose new vulnerabilities.</span></span> <span data-ttu-id="d6411-144">基本应用程序安全性取决于身份验证和授权;通过多种方法可实现这些。</span><span class="sxs-lookup"><span data-stu-id="d6411-144">Basic application security is based on authentication and authorization; multiple ways exist to implement these.</span></span> <span data-ttu-id="d6411-145">但是，容器安全包括导致本质上是更安全的应用程序的其他关键组件。</span><span class="sxs-lookup"><span data-stu-id="d6411-145">However, container security includes additional key components that result in inherently safer applications.</span></span> <span data-ttu-id="d6411-146">生成更安全的应用的关键元素有个与其他应用程序和系统通信的安全方式，有些东西，它通常需要凭据、 令牌、 密码和其他类型的机密信息-通常被称为应用程序机密。</span><span class="sxs-lookup"><span data-stu-id="d6411-146">A critical element of building safer apps is having a secure way of communicating with other apps and systems, something that often requires credentials, tokens, passwords, and other types of confidential information—usually referred to as application secrets.</span></span> <span data-ttu-id="d6411-147">任何安全的解决方案必须遵循安全最佳做法，例如加密传输; 的过程中的机密加密对静止; 机密并阻止无意中泄露时使用的最终应用程序机密。</span><span class="sxs-lookup"><span data-stu-id="d6411-147">Any secure solution must follow security best practices, such as encrypting secrets while in transit; encrypting secrets at rest; and preventing secrets from unintentionally leaking when consumed by the final application.</span></span> <span data-ttu-id="d6411-148">这些机密需要存储并保持安全的某处。</span><span class="sxs-lookup"><span data-stu-id="d6411-148">Those secrets need to be stored and kept safe somewhere.</span></span> <span data-ttu-id="d6411-149">为了安全，可以充分利用你选的 orchestrator 的基础结构，或云基础结构，如 Azure 密钥保管库和它的应用程序代码，若要使用它提供了的方式。</span><span class="sxs-lookup"><span data-stu-id="d6411-149">To help with security, you can take advantage of your chosen orchestrator’s infrastructure, or of cloud infrastructure like Azure Key Vault and the ways it provides for application code to use it.</span></span>

<span data-ttu-id="d6411-150">**Orchestrators。**</span><span class="sxs-lookup"><span data-stu-id="d6411-150">**Orchestrators.**</span></span> <span data-ttu-id="d6411-151">容器基于 orchestrators 类似 Azure 容器服务 （Kubernetes、 Mesos DC/操作系统和 Docker Swarm） 和 Azure Service Fabric 中提供的是必不可少为任何生产就绪基于微服务构成的应用程序和任何多容器使用大大增加复杂性、 可伸缩性的需要和不断发展的应用程序。</span><span class="sxs-lookup"><span data-stu-id="d6411-151">Container-based orchestrators like the ones provided in Azure Container Service (Kubernetes, Mesos DC/OS, and Docker Swarm) and Azure Service Fabric are indispensable for any production-ready microservice-based application and for any multi-container application with significant complexity, scalability needs, and constant evolution.</span></span> <span data-ttu-id="d6411-152">本指南中引入了 orchestrators 和基于微服务和容器基于解决方案中的其角色。</span><span class="sxs-lookup"><span data-stu-id="d6411-152">This guide has introduced orchestrators and their role in microservice-based and container-based solutions.</span></span> <span data-ttu-id="d6411-153">如果您的应用程序需要在迁移你向复杂的容器化应用程序，您将发现非常有用找出用于详细了解 orchestrators 的其他资源</span><span class="sxs-lookup"><span data-stu-id="d6411-153">If your application needs are moving you toward complex containerized apps, you will find it useful to seek out additional resources for learning more about orchestrators</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="d6411-154">[以前](secure-net-microservices-web-applications/azure-key-vault-protects-secrets.md)</span><span class="sxs-lookup"><span data-stu-id="d6411-154">[Previous] (secure-net-microservices-web-applications/azure-key-vault-protects-secrets.md)</span></span>
