---
title: "应用中的微服务构成的简化的 CQRS 和 DDD 模式"
description: "为容器化的.NET 应用程序的.NET 微服务体系结构 |应用中的微服务构成的简化的 CQRS 和 DDD 模式"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 99fd7ce32039742e23f8e01aa4c33cddd7a9f698
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/18/2017
---
# <a name="applying-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="0294c-104">应用中的微服务构成的简化的 CQRS 和 DDD 模式</span><span class="sxs-lookup"><span data-stu-id="0294c-104">Applying simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="0294c-105">CQRS 是分隔用于读取和写入数据的模型的体系结构模式。</span><span class="sxs-lookup"><span data-stu-id="0294c-105">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="0294c-106">相关的术语[命令查询分离 (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html)书籍最初定义通过 Bertrand Meyer*对象面向软件构造*。</span><span class="sxs-lookup"><span data-stu-id="0294c-106">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="0294c-107">基本理念都是你可以将划分为两个清晰地分隔类别的系统的操作：</span><span class="sxs-lookup"><span data-stu-id="0294c-107">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

-   <span data-ttu-id="0294c-108">查询。</span><span class="sxs-lookup"><span data-stu-id="0294c-108">Queries.</span></span> <span data-ttu-id="0294c-109">这些返回结果，不会更改系统的状态，并且它们是免费的副作用。</span><span class="sxs-lookup"><span data-stu-id="0294c-109">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

-   <span data-ttu-id="0294c-110">命令。</span><span class="sxs-lookup"><span data-stu-id="0294c-110">Commands.</span></span> <span data-ttu-id="0294c-111">这些更改系统的状态。</span><span class="sxs-lookup"><span data-stu-id="0294c-111">These change the state of a system.</span></span>

<span data-ttu-id="0294c-112">CQS 是一个简单的概念-即将中同一对象的方法正在查询或命令。</span><span class="sxs-lookup"><span data-stu-id="0294c-112">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="0294c-113">每个方法返回状态，或时会改变状态，但不是两个。</span><span class="sxs-lookup"><span data-stu-id="0294c-113">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="0294c-114">CQS 可以符合甚至单个存储库模式对象。</span><span class="sxs-lookup"><span data-stu-id="0294c-114">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="0294c-115">CQS 可考虑的基本原则 CQRS。</span><span class="sxs-lookup"><span data-stu-id="0294c-115">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="0294c-116">[命令和查询责任分离 (CQRS)](https://martinfowler.com/bliki/CQRS.html)已引入了 Greg Young 又强提升 Udi Dahan 和其他用户。</span><span class="sxs-lookup"><span data-stu-id="0294c-116">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="0294c-117">尽管更详细，它基于 CQS 原则。</span><span class="sxs-lookup"><span data-stu-id="0294c-117">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="0294c-118">它可被视为基于对命令和事件以及 （可选） 在异步消息模式。</span><span class="sxs-lookup"><span data-stu-id="0294c-118">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="0294c-119">在许多情况下，CQRS 与更高级的方案，如具有不同的物理数据库，从而可以读取 （查询） 比为写入操作 （更新）。</span><span class="sxs-lookup"><span data-stu-id="0294c-119">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="0294c-120">此外，多系统要求的 CQRS 系统可能会实现[事件来源 (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/)更新数据库，因此你将仅将事件存储在域模型中而不是存储的当前状态数据。</span><span class="sxs-lookup"><span data-stu-id="0294c-120">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="0294c-121">但是，这不是使用此指南; 中的方法我们正在使用的最简单的 CQRS 方法，其中包括只需将查询与命令区分开来。</span><span class="sxs-lookup"><span data-stu-id="0294c-121">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="0294c-122">CQRS 分离方面被通过分组一个层中的查询操作和另一个层中的命令。</span><span class="sxs-lookup"><span data-stu-id="0294c-122">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="0294c-123">每一层具有其自己的数据模型 （请注意，我们实质模型，不一定是不同的数据库），并使用其自己的模式和技术的组合进行构建。</span><span class="sxs-lookup"><span data-stu-id="0294c-123">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="0294c-124">更重要的是，有两个层可以在同一层或 microservice，如下所示 （排序微服务） 的示例用于本指南中。</span><span class="sxs-lookup"><span data-stu-id="0294c-124">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="0294c-125">或，以便它们可以优化和向外扩展单独而不会影响另一个无法在不同的微服务或进程上实现它们。</span><span class="sxs-lookup"><span data-stu-id="0294c-125">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="0294c-126">CQRS 是指存在两个对象的读/写操作，在其他上下文中还有一个。</span><span class="sxs-lookup"><span data-stu-id="0294c-126">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="0294c-127">没有具有非规范化的读取数据库，你可以在更高级的 CQRS 文献中了解有关的原因。</span><span class="sxs-lookup"><span data-stu-id="0294c-127">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="0294c-128">但我们不使用这种方法在这里，其目标在查询而不是限制的约束从类聚合 DDD 模式的查询具有更大的灵活性。</span><span class="sxs-lookup"><span data-stu-id="0294c-128">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="0294c-129">此类服务的一个示例是排序的微服务构成从 eShopOnContainers 引用应用程序。</span><span class="sxs-lookup"><span data-stu-id="0294c-129">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="0294c-130">此服务实现基于简化 CQRS 方法微服务。</span><span class="sxs-lookup"><span data-stu-id="0294c-130">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="0294c-131">它使用单个数据源或数据库，但两个逻辑模型以及 DDD 模式的事务的域，如图 9-2 中所示。</span><span class="sxs-lookup"><span data-stu-id="0294c-131">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 9-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="0294c-132">**图 9-2**。</span><span class="sxs-lookup"><span data-stu-id="0294c-132">**Figure 9-2**.</span></span> <span data-ttu-id="0294c-133">简化基于 CQRS 和 DDD 的微服务</span><span class="sxs-lookup"><span data-stu-id="0294c-133">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="0294c-134">应用程序层可以为 Web API 本身。</span><span class="sxs-lookup"><span data-stu-id="0294c-134">The application layer can be the Web API itself.</span></span> <span data-ttu-id="0294c-135">此处的重要设计方面是查询和 Viewmodel （尤其是创建客户端应用程序的数据模型），有了拆分微服务构成从命令、 域模型中和以下 CQRS 模式的事务。</span><span class="sxs-lookup"><span data-stu-id="0294c-135">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="0294c-136">此方法保留查询独立于限制和约束来自 DDD 模式仅用于事务和更新，有意义，更高版本的部分中所述。</span><span class="sxs-lookup"><span data-stu-id="0294c-136">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="0294c-137">[以前](index.md) [下一步] (eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="0294c-137">[Previous] (index.md) [Next] (eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
