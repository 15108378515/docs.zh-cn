---
title: "设计 DDD 面向微服务"
description: "为容器化的.NET 应用程序的.NET 微服务体系结构 |设计 DDD 面向微服务"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df45441089fd59d5e0e52b4bcec409adcc11fb71
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-ddd-oriented-microservice"></a><span data-ttu-id="d38c4-104">设计 DDD 面向微服务</span><span class="sxs-lookup"><span data-stu-id="d38c4-104">Designing a DDD-oriented microservice</span></span>

<span data-ttu-id="d38c4-105">域驱动设计 (DDD) 律师有帮助基于商业版作为与你使用的用例的现实的建模。</span><span class="sxs-lookup"><span data-stu-id="d38c4-105">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="d38c4-106">在生成应用程序的上下文中，DDD 介绍为域的问题。</span><span class="sxs-lookup"><span data-stu-id="d38c4-106">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="d38c4-107">它描述独立问题区域作为绑定上下文 （每个绑定的上下文对应于微服务），并强调一种通用的语言来讨论的这些问题。</span><span class="sxs-lookup"><span data-stu-id="d38c4-107">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="d38c4-108">此外，还推荐了许多的技术概念和模式，如具有丰富的模型的域实体 (没有[贫乏域模型](https://martinfowler.com/bliki/AnemicDomainModel.html))，值对象、 聚合和聚合根 （或根实体） 规则以支持内部实现。</span><span class="sxs-lookup"><span data-stu-id="d38c4-108">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="d38c4-109">本部分介绍的设计和实现这些内部的模式。</span><span class="sxs-lookup"><span data-stu-id="d38c4-109">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="d38c4-110">有时这些 DDD 技术规则和模式被公认为有用于实现 DDD 方法陡峭学习曲线的障碍。</span><span class="sxs-lookup"><span data-stu-id="d38c4-110">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="d38c4-111">但重要的部分是不模式本身，但组织代码以便对齐到的业务问题，并使用相同的业务术语表示 （无处不在语言）。</span><span class="sxs-lookup"><span data-stu-id="d38c4-111">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="d38c4-112">此外，仅当你要实现复杂的微服务，与重要的业务规则，则应该应用 DDD 方法。</span><span class="sxs-lookup"><span data-stu-id="d38c4-112">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="d38c4-113">可以使用更简单的方法管理更简单的职责，与 CRUD 服务，类似。</span><span class="sxs-lookup"><span data-stu-id="d38c4-113">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="d38c4-114">绘制边界的位置是在设计和定义微服务时的关键任务。</span><span class="sxs-lookup"><span data-stu-id="d38c4-114">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="d38c4-115">DDD 模式可帮助你了解域中的复杂性。</span><span class="sxs-lookup"><span data-stu-id="d38c4-115">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="d38c4-116">对于每个绑定上下文的域模型，你将标识，并定义实体、 值对象和模型你的域的聚合。</span><span class="sxs-lookup"><span data-stu-id="d38c4-116">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="d38c4-117">生成并优化包含定义您的上下文的边界内的域模型。</span><span class="sxs-lookup"><span data-stu-id="d38c4-117">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="d38c4-118">这也很明确微服务的形式。</span><span class="sxs-lookup"><span data-stu-id="d38c4-118">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="d38c4-119">这些边界内的组件最终将你微服务，但在某些情况下，业务连续性或多个物理服务可由业务微服务组成。</span><span class="sxs-lookup"><span data-stu-id="d38c4-119">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="d38c4-120">有关边界是 DDD 和微服务也是如此。</span><span class="sxs-lookup"><span data-stu-id="d38c4-120">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="d38c4-121">保留 microservice 上下文边界相对较小</span><span class="sxs-lookup"><span data-stu-id="d38c4-121">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="d38c4-122">确定绑定的上下文之间的边界的放置位置平衡两个竞争的目标。</span><span class="sxs-lookup"><span data-stu-id="d38c4-122">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="d38c4-123">首先，你想要最初创建最小可能微服务，但是，不应为主要的驱动程序;你应创建周围需要内聚的内容的边界。</span><span class="sxs-lookup"><span data-stu-id="d38c4-123">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="d38c4-124">其次，你想要避免微服务之间的聊天式通信。</span><span class="sxs-lookup"><span data-stu-id="d38c4-124">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="d38c4-125">这些目标可以标相互矛盾。</span><span class="sxs-lookup"><span data-stu-id="d38c4-125">These goals can contradict one another.</span></span> <span data-ttu-id="d38c4-126">应通过将系统分解成尽可能多的小微服务因为你可以直到您看到与每个再尝试进行单独的新的绑定上下文快速增长的通信边界来对它进行平衡它们。</span><span class="sxs-lookup"><span data-stu-id="d38c4-126">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="d38c4-127">内聚是单个的界限上下文中的密钥。</span><span class="sxs-lookup"><span data-stu-id="d38c4-127">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="d38c4-128">它是类似于[不适合关系密切，这样代码告知](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy)实现类时。</span><span class="sxs-lookup"><span data-stu-id="d38c4-128">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="d38c4-129">如果两个微服务需要大量相互配合，它们可能应该相同微服务。</span><span class="sxs-lookup"><span data-stu-id="d38c4-129">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="d38c4-130">另一种方法可以看到这是自治。</span><span class="sxs-lookup"><span data-stu-id="d38c4-130">Another way to look at this is autonomy.</span></span> <span data-ttu-id="d38c4-131">如果 microservice 必须依赖于其他服务进行直接为请求提供服务，它不是真正自治。</span><span class="sxs-lookup"><span data-stu-id="d38c4-131">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="d38c4-132">中 DDD 微服务层</span><span class="sxs-lookup"><span data-stu-id="d38c4-132">Layers in DDD microservices</span></span>

<span data-ttu-id="d38c4-133">重要的业务和技术的复杂性的大多数企业应用程序由多个层定义。</span><span class="sxs-lookup"><span data-stu-id="d38c4-133">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="d38c4-134">层是一个逻辑的项目，并与服务的部署不相关。</span><span class="sxs-lookup"><span data-stu-id="d38c4-134">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="d38c4-135">它们存在可帮助开发人员管理代码中的复杂性。</span><span class="sxs-lookup"><span data-stu-id="d38c4-135">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="d38c4-136">（如域模型层与表示层，等等） 的不同层可能具有不同的类型，这要求这些类型之间的转换。</span><span class="sxs-lookup"><span data-stu-id="d38c4-136">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="d38c4-137">例如，无法从数据库加载实体。</span><span class="sxs-lookup"><span data-stu-id="d38c4-137">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="d38c4-138">然后该信息或聚合的信息，包括其他数据从其他实体的一部分可发送到客户端通过 REST Web API 的 UI。</span><span class="sxs-lookup"><span data-stu-id="d38c4-138">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="d38c4-139">此处的一点是，域实体包含在域模型层中，不应将传播到它不属于，如给表示层的其他区域。</span><span class="sxs-lookup"><span data-stu-id="d38c4-139">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="d38c4-140">此外，你需要始终有效的实体 (请参阅[设计域模型层中的验证](#designing-validations-in-the-domain-model-layer)部分) 由聚合根 （根实体） 控制。</span><span class="sxs-lookup"><span data-stu-id="d38c4-140">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](#designing-validations-in-the-domain-model-layer) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="d38c4-141">因此，实体应不绑定到客户端视图，因为 UI 级别一些数据可能仍不验证。</span><span class="sxs-lookup"><span data-stu-id="d38c4-141">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="d38c4-142">这就是视图模型的用途。</span><span class="sxs-lookup"><span data-stu-id="d38c4-142">This is what the ViewModel is for.</span></span> <span data-ttu-id="d38c4-143">视图模型是专用于演示文稿层所需的数据模型。</span><span class="sxs-lookup"><span data-stu-id="d38c4-143">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="d38c4-144">直接向视图模型不属于域实体。</span><span class="sxs-lookup"><span data-stu-id="d38c4-144">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="d38c4-145">相反，你需要转换 Viewmodel 和域实体之间，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="d38c4-145">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="d38c4-146">当应对复杂性，务必要有受 （我们依次转到此更详细地更高版本），以确保所有的固定条件和规则相关的聚合根域模型，该组实体 （聚合） 将执行通过单个条目点或入口，聚合根。</span><span class="sxs-lookup"><span data-stu-id="d38c4-146">When tackling complexity, it is important to have a domain model controlled by aggregate roots (we go into this in more detail later) that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry point or gate, the aggregate root.</span></span>

<span data-ttu-id="d38c4-147">图 9-5 演示如何在 eShopOnContainers 应用程序中实施一种分层的设计。</span><span class="sxs-lookup"><span data-stu-id="d38c4-147">Figure 9-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![](./media/image6.png)

<span data-ttu-id="d38c4-148">**图 9-5**。</span><span class="sxs-lookup"><span data-stu-id="d38c4-148">**Figure 9-5**.</span></span> <span data-ttu-id="d38c4-149">在中 eShopOnContainers 排序微服务构成的 DDD 层</span><span class="sxs-lookup"><span data-stu-id="d38c4-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="d38c4-150">你想要将系统设计，以便只与某些其他层的每一层通信。</span><span class="sxs-lookup"><span data-stu-id="d38c4-150">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="d38c4-151">这可能是更轻松地强制实施如果层作为不同类库实现，因为你可以明确识别哪些依赖项都设置库之间。</span><span class="sxs-lookup"><span data-stu-id="d38c4-151">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="d38c4-152">例如，域模型层不会花费依赖其他层上 (域模型类应为纯旧 CLR 对象，或[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)，类)。</span><span class="sxs-lookup"><span data-stu-id="d38c4-152">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="d38c4-153">图 9-6 所示**Ordering.Domain**层库具有依赖关系，仅在.NET 核心库上但不是能在任何其他自定义库 （数据库、 持久性库等）。</span><span class="sxs-lookup"><span data-stu-id="d38c4-153">As shown in Figure 9-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries but not on any other custom library (data library, persistence library, etc.).</span></span>

![](./media/image7.PNG)

<span data-ttu-id="d38c4-154">**图 9-6**。</span><span class="sxs-lookup"><span data-stu-id="d38c4-154">**Figure 9-6**.</span></span> <span data-ttu-id="d38c4-155">层实现因为库允许更好地控制各层之间的依赖关系</span><span class="sxs-lookup"><span data-stu-id="d38c4-155">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="d38c4-156">域模型层</span><span class="sxs-lookup"><span data-stu-id="d38c4-156">The domain model layer</span></span>

<span data-ttu-id="d38c4-157">Eric Evans 绝佳簿[域驱动设计](http://domainlanguage.com/ddd/)显示以下消息的有关域模型层和应用程序层。</span><span class="sxs-lookup"><span data-stu-id="d38c4-157">Eric Evans's excellent book [Domain Driven Design](http://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="d38c4-158">**域模型层**： 负责表示的业务、 了解业务情形和业务规则的概念。</span><span class="sxs-lookup"><span data-stu-id="d38c4-158">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="d38c4-159">反映业务情形的状态是控制，并使用在这里，即使将其存储的技术细节委派向基础结构。</span><span class="sxs-lookup"><span data-stu-id="d38c4-159">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="d38c4-160">此层是业务软件的核心。</span><span class="sxs-lookup"><span data-stu-id="d38c4-160">This layer is the heart of business software.</span></span>

<span data-ttu-id="d38c4-161">域模型层是其中用表示业务。</span><span class="sxs-lookup"><span data-stu-id="d38c4-161">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="d38c4-162">当你在.NET 中实现 microservice 域模型层时，该层被编码为类库所捕获的数据以及行为 （使用逻辑的方法） 的域实体。</span><span class="sxs-lookup"><span data-stu-id="d38c4-162">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="d38c4-163">以下[持久性无感知](http://deviq.com/persistence-ignorance/)和[基础结构无知](https://ayende.com/blog/3137/infrastructure-ignorance)原则，此层必须完全忽略数据持久性详细信息。</span><span class="sxs-lookup"><span data-stu-id="d38c4-163">Following the [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="d38c4-164">由基础结构层执行这些持久性任务。</span><span class="sxs-lookup"><span data-stu-id="d38c4-164">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="d38c4-165">因此，此层不会花费直接的依赖关系的基础结构，这意味着重要规则不应为你的域模型实体类上[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s。</span><span class="sxs-lookup"><span data-stu-id="d38c4-165">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="d38c4-166">域实体于如实体框架或 nhibernate 进行任何数据访问基础结构框架中应没有任何直接的依赖关系 （如派生自的基类）。</span><span class="sxs-lookup"><span data-stu-id="d38c4-166">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="d38c4-167">理想情况下，你的域实体不应派生自或实现基础结构的任何框架中定义的任何类型。</span><span class="sxs-lookup"><span data-stu-id="d38c4-167">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="d38c4-168">如实体框架核心的大多数现代 ORM 框架允许这种方法，以便你的域模型类未耦合到基础结构。</span><span class="sxs-lookup"><span data-stu-id="d38c4-168">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="d38c4-169">但是，具有 POCO 实体并不总是可能时使用某些 NoSQL 数据库和框架，如 Actors 和 Reliable Collections Azure Service Fabric 中。</span><span class="sxs-lookup"><span data-stu-id="d38c4-169">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="d38c4-170">请务必遵循你的域模型持久性无感知原则，即使你不应忽略持久性问题。</span><span class="sxs-lookup"><span data-stu-id="d38c4-170">Even when it is important to follow the Persistence Ignorance principle for you Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="d38c4-171">它仍然是非常重要，以了解物理数据模型和如何映射到您的实体对象模型。</span><span class="sxs-lookup"><span data-stu-id="d38c4-171">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="d38c4-172">否则，您可以创建不可能的设计。</span><span class="sxs-lookup"><span data-stu-id="d38c4-172">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="d38c4-173">此外，这并不意味着你可以获取一种关系数据库的模式，并直接将其移到 NoSQL 或面向文档的数据库。</span><span class="sxs-lookup"><span data-stu-id="d38c4-173">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="d38c4-174">在某些实体模型中，可能适合模型，但通常不能。</span><span class="sxs-lookup"><span data-stu-id="d38c4-174">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="d38c4-175">仍有实体模型必须遵守，基于存储技术和 ORM 技术的约束。</span><span class="sxs-lookup"><span data-stu-id="d38c4-175">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="d38c4-176">应用程序层</span><span class="sxs-lookup"><span data-stu-id="d38c4-176">The application layer</span></span>

<span data-ttu-id="d38c4-177">继续转移到应用程序层中，我们可以再次涉及 Eric Evans 簿[域驱动设计](http://domainlanguage.com/ddd/):</span><span class="sxs-lookup"><span data-stu-id="d38c4-177">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](http://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="d38c4-178">**应用程序层：**定义软件为你做并指导来计算出问题的表达的域对象的作业。</span><span class="sxs-lookup"><span data-stu-id="d38c4-178">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="d38c4-179">此层负责任务是对业务有意义还是需要与其他系统的应用程序层之间的交互。</span><span class="sxs-lookup"><span data-stu-id="d38c4-179">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="d38c4-180">此层是保持精简。</span><span class="sxs-lookup"><span data-stu-id="d38c4-180">This layer is kept thin.</span></span> <span data-ttu-id="d38c4-181">它不包含业务规则或知识，但仅坐标任务和委托工作到域中的对象的下一层的协作下。</span><span class="sxs-lookup"><span data-stu-id="d38c4-181">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="d38c4-182">它不具有状态反映业务情形中，但它可以将反映用户或程序的任务的进度的状态。</span><span class="sxs-lookup"><span data-stu-id="d38c4-182">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="d38c4-183">.NET 中的微服务构成的应用程序层通常被编码为 ASP.NET 核心 Web API 项目中。</span><span class="sxs-lookup"><span data-stu-id="d38c4-183">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="d38c4-184">项目实现微服务的交互、 远程网络访问和 UI 或客户端应用中使用外部 Web Api。</span><span class="sxs-lookup"><span data-stu-id="d38c4-184">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="d38c4-185">如果使用 CQRS 方法，命令接受微服务，以及微服务 （集成事件） 之间甚至事件驱动的通信，它包括查询。</span><span class="sxs-lookup"><span data-stu-id="d38c4-185">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="d38c4-186">表示应用程序层 ASP.NET 核心 Web API 不能包含业务规则或域知识 （尤其是域规则为事务或更新）;这些应拥有的域模型类库。</span><span class="sxs-lookup"><span data-stu-id="d38c4-186">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="d38c4-187">应用程序层必须唯一坐标任务并必须不保存或定义任何域状态 （域模型）。</span><span class="sxs-lookup"><span data-stu-id="d38c4-187">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="d38c4-188">它将委托到的域模型类本身 （聚合根和域实体），这最终将更新这些域实体内的数据的业务规则的执行。</span><span class="sxs-lookup"><span data-stu-id="d38c4-188">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="d38c4-189">基本上，应用程序逻辑是其中实现依赖于给定的前端的所有用例。</span><span class="sxs-lookup"><span data-stu-id="d38c4-189">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="d38c4-190">例如，Web API 服务相关的实现。</span><span class="sxs-lookup"><span data-stu-id="d38c4-190">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="d38c4-191">目标是在域模型层、 其固定协定，数据模型和相关的业务规则的域逻辑，必须是完全独立于演示文稿和应用程序层。</span><span class="sxs-lookup"><span data-stu-id="d38c4-191">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="d38c4-192">最重要的是，域模型层必须不直接依赖于任何基础结构框架中。</span><span class="sxs-lookup"><span data-stu-id="d38c4-192">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="d38c4-193">基础结构层</span><span class="sxs-lookup"><span data-stu-id="d38c4-193">The infrastructure layer</span></span>

<span data-ttu-id="d38c4-194">基础结构层是如何最初 （内存中） 的域实体中存放的数据保持在数据库或其他持久存储。</span><span class="sxs-lookup"><span data-stu-id="d38c4-194">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="d38c4-195">一个示例使用实体框架核心代码来实现创建的 DBContext 用于将保存在关系数据库中的数据的存储库模式类。</span><span class="sxs-lookup"><span data-stu-id="d38c4-195">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="d38c4-196">根据前面所述[持久性无感知](http://deviq.com/persistence-ignorance/)和[基础结构无知](https://ayende.com/blog/3137/infrastructure-ignorance)原则，基础结构层必须不"污染"域模型层。</span><span class="sxs-lookup"><span data-stu-id="d38c4-196">In accordance with the previously mentioned [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="d38c4-197">你必须通过不在框架上会占用的硬依赖项用于将保存数据 （EF 或任何其他框架） 的基础结构保留域模型实体类不可知。</span><span class="sxs-lookup"><span data-stu-id="d38c4-197">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="d38c4-198">你的域模型层类库应正好有只有你的域代码， [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)实体类实现你的软件的核心和完全脱离基础结构技术。</span><span class="sxs-lookup"><span data-stu-id="d38c4-198">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="d38c4-199">因此，您的层或类库和项目应最终取决于你的域模型层 （库）、 反之则不然，如图 9-7 中所示。</span><span class="sxs-lookup"><span data-stu-id="d38c4-199">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 9-7.</span></span>

![](./media/image8.png)

<span data-ttu-id="d38c4-200">**图 9-7**。</span><span class="sxs-lookup"><span data-stu-id="d38c4-200">**Figure 9-7**.</span></span> <span data-ttu-id="d38c4-201">中 DDD 层之间的依赖关系</span><span class="sxs-lookup"><span data-stu-id="d38c4-201">Dependencies between layers in DDD</span></span>

<span data-ttu-id="d38c4-202">此层设计应是独立的每个微服务。</span><span class="sxs-lookup"><span data-stu-id="d38c4-202">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="d38c4-203">如前文所述，你可以实现最复杂的微服务遵循 DDD 模式，同时实施更简单数据驱动微服务 (在单个层的简单 CRUD) 中更简单的方法。</span><span class="sxs-lookup"><span data-stu-id="d38c4-203">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="d38c4-204">其他资源</span><span class="sxs-lookup"><span data-stu-id="d38c4-204">Additional resources</span></span>

-   <span data-ttu-id="d38c4-205">**DevIQ。持久性无感知原则**
    [*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span><span class="sxs-lookup"><span data-stu-id="d38c4-205">**DevIQ. Persistence Ignorance principle**
[*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span></span>

-   <span data-ttu-id="d38c4-206">**Oren Eini。基础结构无知**
    [*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span><span class="sxs-lookup"><span data-stu-id="d38c4-206">**Oren Eini. Infrastructure Ignorance**
[*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span></span>

-   <span data-ttu-id="d38c4-207">**天使 Lopez。分层体系结构在域驱动设计**
    [*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span><span class="sxs-lookup"><span data-stu-id="d38c4-207">**Angel Lopez. Layered Architecture In Domain-Driven Design**
[*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="d38c4-208">[以前](cqrs-microservice-reads.md) [下一步] (microservice 域 model.md)</span><span class="sxs-lookup"><span data-stu-id="d38c4-208">[Previous] (cqrs-microservice-reads.md) [Next] (microservice-domain-model.md)</span></span>
