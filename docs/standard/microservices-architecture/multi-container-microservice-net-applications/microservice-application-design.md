---
title: 设计面向微服务的应用程序
description: 适用于容器化 .NET 应用程序的 .NET 微服务体系结构 | 设计面向微服务的应用程序
keywords: Docker, 微服务, ASP.NET, 容器
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 116ddb44655f0a9708a6496cbe7fb4fbc608300b
ms.sourcegitcommit: c883637b41ee028786edceece4fa872939d2e64c
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/26/2018
---
# <a name="designing-a-microservice-oriented-application"></a><span data-ttu-id="eeb1e-104">设计面向微服务的应用程序</span><span class="sxs-lookup"><span data-stu-id="eeb1e-104">Designing a microservice-oriented application</span></span>

<span data-ttu-id="eeb1e-105">本部分重点介绍开发假设服务器端企业应用程序。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-105">This section focuses on developing a hypothetical server-side enterprise application.</span></span>

## <a name="application-specifications"></a><span data-ttu-id="eeb1e-106">应用程序规范</span><span class="sxs-lookup"><span data-stu-id="eeb1e-106">Application specifications</span></span>

<span data-ttu-id="eeb1e-107">假设应用程序通过执行业务逻辑、访问数据库，并返回 HTML、JSON 或 XML 响应处理请求。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-107">The hypothetical application handles requests by executing business logic, accessing databases, and then returning HTML, JSON, or XML responses.</span></span> <span data-ttu-id="eeb1e-108">我们将假定该应用程序必须支持多种客户端，包括运行单页面应用程序W (SPA)、传统 web 应用、移动 web 应用和本机移动应用的桌面浏览器。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-108">We will say that the application must support a variety of clients, including desktop browsers running Single Page Applications (SPAs), traditional web apps, mobile web apps, and native mobile apps.</span></span> <span data-ttu-id="eeb1e-109">应用程序可能还会公开一个 API，供第三方使用。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-109">The application might also expose an API for third parties to consume.</span></span> <span data-ttu-id="eeb1e-110">它还应异步集成其微服务或外部应用程序，因此该方法有助于在发生部分失败时恢复微服务。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-110">It should also be able to integrate its microservices or external applications asynchronously, so that approach will help resiliency of the microservices in the case of partial failures.</span></span>

<span data-ttu-id="eeb1e-111">应用程序将包括以下类型的组件：</span><span class="sxs-lookup"><span data-stu-id="eeb1e-111">The application will consist of these types of components:</span></span>

-   <span data-ttu-id="eeb1e-112">演示组件。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-112">Presentation components.</span></span> <span data-ttu-id="eeb1e-113">该组件负责处理 UI 并使用远程服务。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-113">These are responsible for handling the UI and consuming remote services.</span></span>

-   <span data-ttu-id="eeb1e-114">域或业务逻辑。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-114">Domain or business logic.</span></span> <span data-ttu-id="eeb1e-115">这是应用程序的域逻辑。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-115">This is the application’s domain logic.</span></span>

-   <span data-ttu-id="eeb1e-116">数据库访问逻辑。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-116">Database access logic.</span></span> <span data-ttu-id="eeb1e-117">这包括负责访问数据库（SQL 或 NoSQL）的数据访问组件。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-117">This consists of data access components responsible for accessing databases (SQL or NoSQL).</span></span>

-   <span data-ttu-id="eeb1e-118">应用程序集成逻辑。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-118">Application integration logic.</span></span> <span data-ttu-id="eeb1e-119">这包括主要基于消息代理的消息传递通道。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-119">This includes a messaging channel, mainly based on message brokers.</span></span>

<span data-ttu-id="eeb1e-120">应用程序需要高可伸缩性，同时允许其垂直的子系统自主横向扩展，因为某些子系统需要比其他子系统更大的可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-120">The application will require high scalability, while allowing its vertical subsystems to scale out autonomously, because certain subsystems will require more scalability than others.</span></span>

<span data-ttu-id="eeb1e-121">应用程序必须能在多个基础结构环境（多个公有云和本地）中部署，最好是跨平台，可从 Linux 轻松移动到 Windows（反之亦然）。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-121">The application must be able to be deployed in multiple infrastructure environments (multiple public clouds and on-premises) and ideally should be cross-platform, able to move from Linux to Windows (or vice versa) easily.</span></span>

## <a name="development-team-context"></a><span data-ttu-id="eeb1e-122">开发团队上下文</span><span class="sxs-lookup"><span data-stu-id="eeb1e-122">Development team context</span></span>

<span data-ttu-id="eeb1e-123">我们还对应用程序的开发过程进行以下假设：</span><span class="sxs-lookup"><span data-stu-id="eeb1e-123">We also assume the following about the development process for the application:</span></span>

-   <span data-ttu-id="eeb1e-124">不同的开发团队专注于应用程序的不同业务方面。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-124">You have multiple dev teams focusing on different business areas of the application.</span></span>

-   <span data-ttu-id="eeb1e-125">新的团队成员必须快速提高工作效率，且应用程序必须易于理解和修改。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-125">New team members must become productive quickly, and the application must be easy to understand and modify.</span></span>

-   <span data-ttu-id="eeb1e-126">应用程序将具有长期发展和不断变化的业务规则。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-126">The application will have a long-term evolution and ever-changing business rules.</span></span>

-   <span data-ttu-id="eeb1e-127">你需要良好的长期可维护性，这意味着在未来实现新更改时具有灵活性，同时能够更新多个子系统，且尽可能减少对其他子系统的影响。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-127">You need good long-term maintainability, which means having agility when implementing new changes in the future while being able to update multiple subsystems with minimum impact on the other subsystems.</span></span>

-   <span data-ttu-id="eeb1e-128">你希望执行应用程序的持续集成和持续部署。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-128">You want to practice continuous integration and continuous deployment of the application.</span></span>

-   <span data-ttu-id="eeb1e-129">你希望利用新兴技术（框架、编程语言等），同时发展应用程序。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-129">You want to take advantage of emerging technologies (frameworks, programming languages, etc.) while evolving the application.</span></span> <span data-ttu-id="eeb1e-130">你不想在转换为新技术时，对应用程序进行完整迁移，因为这样做会产生高额费用，且影响应用程序的可预测性和稳定性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-130">You do not want to make full migrations of the application when moving to new technologies, because that would result in high costs and impact the predictability and stability of the application.</span></span>

## <a name="choosing-an-architecture"></a><span data-ttu-id="eeb1e-131">选择体系结构</span><span class="sxs-lookup"><span data-stu-id="eeb1e-131">Choosing an architecture</span></span>

<span data-ttu-id="eeb1e-132">应用程序部署体系结构应该是什么？</span><span class="sxs-lookup"><span data-stu-id="eeb1e-132">What should the application deployment architecture be?</span></span> <span data-ttu-id="eeb1e-133">根据应用程序的规格以及开发上下文，应用程序的构建应采用以下方式：将其分解为独立的子系统（采用协作的微服务和容器的形式），其中微服务是容器。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-133">The specifications for the application, along with the development context, strongly suggest that you should architect the application by decomposing it into autonomous subsystems in the form of collaborating microservices and containers, where a microservice is a container.</span></span>

<span data-ttu-id="eeb1e-134">在此方法中，每个服务（容器）实现一组紧密结合且关联的功能。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-134">In this approach, each service (container) implements a set of cohesive and narrowly related functions.</span></span> <span data-ttu-id="eeb1e-135">例如，应用程序可能包含目录服务，订购服务、购物篮服务、用户个人资料服务等服务。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-135">For example, an application might consist of services such as the catalog service, ordering service, basket service, user profile service, etc.</span></span>

<span data-ttu-id="eeb1e-136">微服务不仅使用 HTTP (REST) 等协议通信，而且尽可能进行异步通信（如使用 AMQP），尤其是传播集成事件更新时。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-136">Microservices communicate using protocols such as HTTP (REST), but also asynchronously (for example, using AMQP) whenever possible, especially when propagating updates with integration events.</span></span>

<span data-ttu-id="eeb1e-137">微服务作为相互独立的容器开发和部署。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-137">Microservices are developed and deployed as containers independently of one another.</span></span> <span data-ttu-id="eeb1e-138">这意味着开发团队在开发和部署特定微服务时，不会影响其他子系统。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-138">This means that a development team can be developing and deploying a certain microservice without impacting other subsystems.</span></span>

<span data-ttu-id="eeb1e-139">每个微服务都有自己的数据库，从而能够从其他微服务中完全分离。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-139">Each microservice has its own database, allowing it to be fully decoupled from other microservices.</span></span> <span data-ttu-id="eeb1e-140">如有必要，可使用应用程序级集成事件（通过逻辑事件总线）实现不同微服务中的数据库间的一致性，正如命令查询职责分离 (CQRS) 中的处理一样。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-140">When necessary, consistency between databases from different microservices is achieved using application-level integration events (through a logical event bus), as handled in Command and Query Responsibility Segregation (CQRS).</span></span> <span data-ttu-id="eeb1e-141">由此，业务约束必须接受多个微服务和相关数据库之间的最终一致性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-141">Because of that, the business constraints must embrace eventual consistency between the multiple microservices and related databases.</span></span>

### <a name="eshoponcontainers-a-reference-application-for-net-core-and-microservices-deployed-using-containers"></a><span data-ttu-id="eeb1e-142">eShopOnContainers：使用容器部署的 .NET Core 和微服务的参考应用程序</span><span class="sxs-lookup"><span data-stu-id="eeb1e-142">eShopOnContainers: A reference application for .NET Core and microservices deployed using containers</span></span>

<span data-ttu-id="eeb1e-143">这样一来，你可专注于体系结构和技术，而无需考虑自己可能不知道的假设业务领域，我们已经选择了一个有名的业务领域，即简化的电子商务 (e-shop) 应用程序，其提供产品目录、处理客户订单、验证库存并执行其他业务功能。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-143">So that you can focus on the architecture and technologies instead of thinking about a hypothetic business domain that you might not know, we have selected a well-known business domain—namely, a simplified e-commerce (e-shop) application that presents a catalog of products, takes orders from customers, verifies inventory, and performs other business functions.</span></span> <span data-ttu-id="eeb1e-144">此基于容器的应用程序源代码可通过 [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) GitHub 存储库获取。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-144">This container-based application source code is available in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) GitHub repo.</span></span>

<span data-ttu-id="eeb1e-145">该应用程序包含多个子系统，包括多个应用商店 UI 前端（一个 Web 应用程序和本机移动应用），以及用于所有所需服务器端操作的后端微服务和容器。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-145">The application consists of multiple subsystems, including several store UI front ends (a Web application and a native mobile app), along with the back-end microservices and containers for all the required server-side operations.</span></span> <span data-ttu-id="eeb1e-146">图 8-1 显示了参考应用程序的体系结构。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-146">Figure 8-1 shows the architecture of the reference application.</span></span>

![](./media/image1.png)

<span data-ttu-id="eeb1e-147">**图 8-1**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-147">**Figure 8-1**.</span></span> <span data-ttu-id="eeb1e-148">EShopOnContainers 参考应用程序，显示直接的客户端到微服务通信和事件总线</span><span class="sxs-lookup"><span data-stu-id="eeb1e-148">The eShopOnContainers reference application, showing a direct client-to-microservice communication and the event bus</span></span>

<span data-ttu-id="eeb1e-149">**宿主环境**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-149">**Hosting environment**.</span></span> <span data-ttu-id="eeb1e-150">在图 8-1 中，你会看到一个 Docker 主机中部署的多个容器。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-150">In Figure 8-1, you see several containers deployed within a single Docker host.</span></span> <span data-ttu-id="eeb1e-151">使用 docker-compose up 命令部署到单个 Docker 主机便是这种情况。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-151">That would be the case when deploying to a single Docker host with the docker-compose up command.</span></span> <span data-ttu-id="eeb1e-152">但是，如果使用业务流程协调程序或容器群集，每个容器可能在不同主机（节点）运行，任何节点可能运行任意数目的容器，正如前面的体系结构部分所述。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-152">However, if you are using an orchestrator or container cluster, each container could be running in a different host (node), and any node could be running any number of containers, as we explained earlier in the architecture section.</span></span>

<span data-ttu-id="eeb1e-153">**通信体系结构**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-153">**Communication architecture**.</span></span> <span data-ttu-id="eeb1e-154">eShopOnContainers 应用程序使用两种通信类型，具体取决于功能操作的类型（查询与更新和事务）：</span><span class="sxs-lookup"><span data-stu-id="eeb1e-154">The eShopOnContainers application uses two communication types, depending on the kind of the functional action (queries versus updates and transactions):</span></span>

-   <span data-ttu-id="eeb1e-155">客户端到微服务直接通信。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-155">Direct client-to-microservice communication.</span></span> <span data-ttu-id="eeb1e-156">此类型用于查询，以及接受来自客户端应用的更新或事务命令。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-156">This is used for queries and when accepting update or transactional commands from the client apps.</span></span>

-   <span data-ttu-id="eeb1e-157">基于异步事件的通信。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-157">Asynchronous event-based communication.</span></span> <span data-ttu-id="eeb1e-158">这种类型通过事件总线发生，以跨微服务传播更新或与外部应用程序集成。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-158">This occurs through an event bus to propagate updates across microservices or to integrate with external applications.</span></span> <span data-ttu-id="eeb1e-159">可使用 RabbitMQ 等消息中转站基础结构技术或使用 Azure 服务总线、NServiceBus、MassTransit 或 Brighter 等较高级别服务总线实现此事件总线。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-159">The event bus can be implemented with any messaging-broker infrastructure technology like RabbitMQ, or using higher-level service buses like Azure Service Bus, NServiceBus, MassTransit, or Brighter.</span></span>

<span data-ttu-id="eeb1e-160">此应用程序以容器形式，作为一组微服务部署。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-160">The application is deployed as a set of microservices in the form of containers.</span></span> <span data-ttu-id="eeb1e-161">客户端应用可以与这些容器通信以及在微服务之间进行通信。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-161">Client apps can communicate with those containers as well as communicate between microservices.</span></span> <span data-ttu-id="eeb1e-162">如前文所述，此初始体系结构使用直接的客户端到微服务通信体系结构，这意味着客户端应用程序可以直接发出对每个微服务的请求。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-162">As mentioned, this initial architecture is using a direct client-to-microservice communication architecture, which means that a client application can make requests to each of the microservices directly.</span></span> <span data-ttu-id="eeb1e-163">每个微服务拥有一个公共终结点，如 https://servicename.applicationname.companyname。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-163">Each microservice has a public endpoint like https://servicename.applicationname.companyname.</span></span> <span data-ttu-id="eeb1e-164">如果需要，每个微服务可以使用不同的 TCP 端口。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-164">If required, each microservice can use a different TCP port.</span></span> <span data-ttu-id="eeb1e-165">在生产中，该 URL 将映射到微服务的负载均衡器，它会将请求分布到可用的微服务实例。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-165">In production, that URL would map to the microservices’ load balancer, which distributes requests across the available microservice instances.</span></span>

<span data-ttu-id="eeb1e-166">**eShopOnContainers 中的 API 网关和直接通信。**</span><span class="sxs-lookup"><span data-stu-id="eeb1e-166">**Important note on API Gateway vs. Direct Communication in eShopOnContainers.**</span></span> <span data-ttu-id="eeb1e-167">如本指南的体系结构部分中所述，直接的客户端到微服务通信体系结构可能在你创建大型、复杂的基于微服务的应用程序时具有缺陷。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-167">As explained in the architecture section of this guide, the direct client-to-microservice communication architecture can have drawbacks when you are building a large and complex microservice-based application.</span></span> <span data-ttu-id="eeb1e-168">但它对于小型应用程序（如 eShopOnContainers 应用程序）已经足够有效，其目的是专注于较简单的入门级的基于 Docker 容器的应用程序，而我们也不希望创建可影响微服务的开发自主性的整体式 API 网关。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-168">But it can be good enough for a small application, such as in the eShopOnContainers application, where the goal is to focus on a simpler getting started Docker container-based application and we didn’t want to create a single monolithic API Gateway that can impact the microservices’ development autonomy.</span></span>

<span data-ttu-id="eeb1e-169">但是，如果你要设计大型的基于微服务（包含许多微服务）的应用程序，强烈建议你考虑使用 API 网关模式，正如体系结构部分所述。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-169">But, if you are going to design a large microservice-based application with dozens of microservices, we strongly recommend that you consider the API Gateway pattern, as we explained in the architecture section.</span></span>
<span data-ttu-id="eeb1e-170">在考虑可供生产使用的应用程序和针对远程客户端的特制外观后，应重新作出体系结构决策。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-170">This architectural decision could be refactored once thinking about production-ready applications and specially-made facades for remote clients.</span></span> <span data-ttu-id="eeb1e-171">根据客户端应用的外形规格确定多个自定义 API 网关，不仅可以在每个客户端应用的不同数据聚合方面带来好处，而且还能让你对客户端应用隐藏内部微服务或 API，并在此单层中授权。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-171">Having multiple custom API Gateways depending on the client apps' form-factor can provide benefits in regard to different data aggregation per client app plus you can hide internal microservices or APIs to the client apps and authorize in that single tier.</span></span> 

<span data-ttu-id="eeb1e-172">但是，如前文所述，请注意大型 API 网关，它们可能会扼杀微服务的开发自主性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-172">However, and as mentioned, beware against large and monolithic API Gateways that might kill your microservices' development autonomy.</span></span>

### <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="eeb1e-173">每个微服务的数据主权</span><span class="sxs-lookup"><span data-stu-id="eeb1e-173">Data sovereignty per microservice</span></span>

<span data-ttu-id="eeb1e-174">在示例应用程序中，每个微服务拥有其自己的数据库或数据源，并且每个数据库或数据源部署为另一个容器。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-174">In the sample application, each microservice owns its own database or data source, and each database or data source is deployed as another container.</span></span> <span data-ttu-id="eeb1e-175">这种设计的目的是让开发者可轻松地从 GitHub 获取代码、进行克隆，并在 Visual Studio 或 Visual Studio Code 中打开它。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-175">This design decision was made only to make it easy for a developer to get the code from GitHub, clone it, and open it in Visual Studio or Visual Studio Code.</span></span> <span data-ttu-id="eeb1e-176">或者可让开发者轻松地使用 .NET Core CLI 和 Docker CLI 编译自定义 Docker 映像，然后在 Docker 开发环境中进行部署和运行。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-176">Or alternatively, it makes it easy to compile the custom Docker images using .NET Core CLI and the Docker CLI, and then deploy and run them in a Docker development environment.</span></span> <span data-ttu-id="eeb1e-177">无论是出于哪种目的，将容器用于数据源，都可让开发者在几分钟内生成和部署，无需预配外部数据库或任何其他严重依赖基础结构（云或本地）的数据源。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-177">Either way, using containers for data sources lets developers build and deploy in a matter of minutes without having to provision an external database or any other data source with hard dependencies on infrastructure (cloud or on-premises).</span></span>

<span data-ttu-id="eeb1e-178">在实际生产环境中，为了实现高可用性和可伸缩性，数据库应基于云端或本地数据库服务器，但不是容器。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-178">In a real production environment, for high availability and for scalability, the databases should be based on database servers in the cloud or on-premises, but not in containers.</span></span>

<span data-ttu-id="eeb1e-179">因此，微服务（甚至此应用程序中的数据库）的部署单元是 Docker 容器，参考应用程序是采用微服务原则的多容器应用程序。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-179">Therefore, the units of deployment for microservices (and even for databases in this application) are Docker containers, and the reference application is a multi-container application that embraces microservices principles.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="eeb1e-180">其他资源</span><span class="sxs-lookup"><span data-stu-id="eeb1e-180">Additional resources</span></span>

-   <span data-ttu-id="eeb1e-181">**eShopOnContainers GitHub 存储库。引用应用程序源代码**
    *https://aka.ms/eShopOnContainers/*</span><span class="sxs-lookup"><span data-stu-id="eeb1e-181">**eShopOnContainers GitHub repo. Source code for the reference application**
*https://aka.ms/eShopOnContainers/*</span></span>

## <a name="benefits-of-a-microservice-based-solution"></a><span data-ttu-id="eeb1e-182">基于微服务的解决方案的优点</span><span class="sxs-lookup"><span data-stu-id="eeb1e-182">Benefits of a microservice-based solution</span></span>

<span data-ttu-id="eeb1e-183">这样的基于微服务的解决方案有许多优点：</span><span class="sxs-lookup"><span data-stu-id="eeb1e-183">A microservice based solution like this has many benefits:</span></span>

<span data-ttu-id="eeb1e-184">**每个微服务相对较小，易于管理和发展**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-184">**Each microservice is relatively small—easy to manage and evolve**.</span></span> <span data-ttu-id="eeb1e-185">尤其是在下列情况下：</span><span class="sxs-lookup"><span data-stu-id="eeb1e-185">Specifically:</span></span>

-   <span data-ttu-id="eeb1e-186">易于开发者理解和快速提高工作效率。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-186">It is easy for a developer to understand and get started quickly with good productivity.</span></span>

-   <span data-ttu-id="eeb1e-187">容器启动速度快，从而提高开发者工作效率。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-187">Containers start fast, which makes developers more productive.</span></span>

-   <span data-ttu-id="eeb1e-188">Visual Studio 这样的 IDE 可以快速加载较小项目，从而提高开发者工作效率。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-188">An IDE like Visual Studio can load smaller projects fast, making developers productive.</span></span>

-   <span data-ttu-id="eeb1e-189">每个微服务可以彼此独立地设计、开发和部署，这可提供灵活性，因为可更轻松地经常部署微服务的新版本。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-189">Each microservice can be designed, developed, and deployed independently of other microservices, which provides agility because it is easier to deploy new versions of microservices frequently.</span></span>

<span data-ttu-id="eeb1e-190">**可以横向扩展应用程序的各个区域**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-190">**It is possible to scale out individual areas of the application**.</span></span> <span data-ttu-id="eeb1e-191">例如，目录服务或购物篮服务可能需要横向扩展，但不需要横向扩展订购流程。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-191">For instance, the catalog service or the basket service might need to be scaled out, but not the ordering process.</span></span> <span data-ttu-id="eeb1e-192">与整体式体系结构相比，微服务基础结构在横向扩展时的资源使用更高效。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-192">A microservices infrastructure will be much more efficient with regard to the resources used when scaling out than a monolithic architecture would be.</span></span>

<span data-ttu-id="eeb1e-193">**可以在多个团队之间划分开发工作**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-193">**You can divide the development work between multiple teams**.</span></span> <span data-ttu-id="eeb1e-194">每个服务可以由一个开发团队所有。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-194">Each service can be owned by a single development team.</span></span> <span data-ttu-id="eeb1e-195">每个团队可以独立于其他团队管理、开发、部署和缩放其服务。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-195">Each team can manage, develop, deploy, and scale their service independently of the rest of the teams.</span></span>

<span data-ttu-id="eeb1e-196">**可以更好地隔离问题**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-196">**Issues are more isolated**.</span></span> <span data-ttu-id="eeb1e-197">如果一个服务出现一个问题，最初只影响该服务（除非使用了错误设计，微服务之间有直接依赖项），其他服务可继续处理请求。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-197">If there is an issue in one service, only that service is initially impacted (except when the wrong design is used, with direct dependencies between microservices), and other services can continue to handle requests.</span></span> <span data-ttu-id="eeb1e-198">与此相反，整体式部署体系结构中的一个异常组件可影响整个系统，尤其是涉及资源（如内存泄露）时。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-198">In contrast, one malfunctioning component in a monolithic deployment architecture can bring down the entire system, especially when it involves resources, such as a memory leak.</span></span> <span data-ttu-id="eeb1e-199">此外，解决微服务问题后，可仅部署受影响的微服务，而不影响应用程序的其他部分。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-199">Additionally, when an issue in a microservice is resolved, you can deploy just the affected microservice without impacting the rest of the application.</span></span>

<span data-ttu-id="eeb1e-200">**可以使用最新技术**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-200">**You can use the latest technologies**.</span></span> <span data-ttu-id="eeb1e-201">由于可开始独立开发服务，然后并行运行这些服务（得益于容器和 .NET Core），可方便地开始使用最新技术和框架，而不受整个应用程序较旧堆栈或框架的限制。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-201">Because you can start developing services independently and run them side by side (thanks to containers and .NET Core), you can start using the latest technologies and frameworks expediently instead of being stuck on an older stack or framework for the whole application.</span></span>

## <a name="downsides-of-a-microservice-based-solution"></a><span data-ttu-id="eeb1e-202">基于微服务的解决方案的缺点</span><span class="sxs-lookup"><span data-stu-id="eeb1e-202">Downsides of a microservice-based solution</span></span>

<span data-ttu-id="eeb1e-203">这样的基于微服务的解决方案有一些缺点：</span><span class="sxs-lookup"><span data-stu-id="eeb1e-203">A microservice based solution like this also has some drawbacks:</span></span>

<span data-ttu-id="eeb1e-204">**分布式应用程序**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-204">**Distributed application**.</span></span> <span data-ttu-id="eeb1e-205">分布式应用程序增加了开发者在设计和生成服务时的难度。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-205">Distributing the application adds complexity for developers when they are designing and building the services.</span></span> <span data-ttu-id="eeb1e-206">例如，开发者必须使用 HTTP 或 AMPQ 等协议实现服务间通信，这会增加测试和异常处理的复杂性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-206">For example, developers must implement interservice communication using protocols like HTTP or AMPQ, which adds complexity for testing and exception handling.</span></span> <span data-ttu-id="eeb1e-207">还会增加系统延迟。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-207">It also adds latency to the system.</span></span>

<span data-ttu-id="eeb1e-208">**部署复杂性**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-208">**Deployment complexity**.</span></span> <span data-ttu-id="eeb1e-209">如果应用程序具有许多微服务类型，且需要高可伸缩性（需要能为一个服务创建许多实例且在许多主机中实现服务均衡），这意味着 IT 运营和管理需要应对高度部署复杂性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-209">An application that has dozens of microservices types and needs high scalability (it needs to be able to create many instances per service and balance those services across many hosts) means a high degree of deployment complexity for IT operations and management.</span></span> <span data-ttu-id="eeb1e-210">如果不使用面向微服务的基础结构（如业务流程协调程序和计划程序），为应对增加的复杂性所作的开发工作可能比业务应用程序本身多得多。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-210">If you are not using a microservice-oriented infrastructure (like an orchestrator and scheduler), that additional complexity can require far more development efforts than the business application itself.</span></span>

<span data-ttu-id="eeb1e-211">**原子事务**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-211">**Atomic transactions**.</span></span> <span data-ttu-id="eeb1e-212">多个微服务之间的原子事务通常不可能。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-212">Atomic transactions between multiple microservices usually are not possible.</span></span> <span data-ttu-id="eeb1e-213">业务要求必须接受多个微服务之间的最终一致性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-213">The business requirements have to embrace eventual consistency between multiple microservices.</span></span>

<span data-ttu-id="eeb1e-214">**增加全局资源需求**（所有服务器或主机的总内存、驱动器和网络资源）。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-214">**Increased global resource needs** (total memory, drives, and network resources for all the servers or hosts).</span></span> <span data-ttu-id="eeb1e-215">在许多情况下，如果用微服务方法替代整体式应用程序，新的基于微服务的应用程序所需的全局资源数量超过原始整体式应用程序的基础结构需要。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-215">In many cases, when you replace a monolithic application with a microservices approach, the amount of global resources needed by the new microservice-based application will be larger than the infrastructure needs of the original monolithic application.</span></span> <span data-ttu-id="eeb1e-216">这是因为更高程度的粒度和分布式服务需要更多全局资源。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-216">This is because the higher degree of granularity and distributed services requires more global resources.</span></span> <span data-ttu-id="eeb1e-217">但是，由于与开发整体式应用程序所需的长期成本相比，资源通常成本较低，且微服务方法具有可横向扩展应用程序特定区域的好处，增加资源使用量好过使用大型、长期应用程序。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-217">However, given the low cost of resources in general and the benefit of being able to scale out just certain areas of the application compared to long-term costs when evolving monolithic applications, the increased use of resources is usually a good tradeoff for large, long-term applications.</span></span>

<span data-ttu-id="eeb1e-218">**客户端到微服务直接通信的问题**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-218">**Issues with direct client‑to‑microservice communication**.</span></span> <span data-ttu-id="eeb1e-219">对于拥有许多微服务的大型应用程序，如果应用程序需要客户端到微服务直接通信，则存在难题和限制。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-219">When the application is large, with dozens of microservices, there are challenges and limitations if the application requires direct client-to-microservice communications.</span></span> <span data-ttu-id="eeb1e-220">一个问题是客户端和每个微服务公开的 API 的需要之间可能存在不匹配。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-220">One problem is a potential mismatch between the needs of the client and the APIs exposed by each of the microservices.</span></span> <span data-ttu-id="eeb1e-221">在某些情况下，客户端应用程序可能需要进行许多单独的请求，以构成 UI，这在 Internet 中效率低下，且在移动网络中不切实际。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-221">In certain cases, the client application might need to make many separate requests to compose the UI, which can be inefficient over the Internet and would be impractical over a mobile network.</span></span> <span data-ttu-id="eeb1e-222">因此，仅尽量减少从客户端应用程序到后端系统的请求。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-222">Therefore, requests from the client application to the back-end system should be minimized.</span></span>

<span data-ttu-id="eeb1e-223">客户端到微服务直接通信的另一个问题是某些微服务可能使用不支持 Web 的协议。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-223">Another problem with direct client-to-microservice communications is that some microservices might be using protocols that are not Web-friendly.</span></span> <span data-ttu-id="eeb1e-224">一个服务可能使用二进制协议，而另一个服务可能使用 AMQP 消息。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-224">One service might use a binary protocol, while another service might use AMQP messaging.</span></span> <span data-ttu-id="eeb1e-225">这些协议不支持防火墙，最好在内部使用。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-225">Those protocols are not firewall‑friendly and are best used internally.</span></span> <span data-ttu-id="eeb1e-226">通常情况下，应用程序应针对防火墙外的通信使用 HTTP 和 WebSockets 等协议。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-226">Usually, an application should use protocols such as HTTP and WebSockets for communication outside of the firewall.</span></span>

<span data-ttu-id="eeb1e-227">但是，客户端到服务直接方法的另一个缺点是难以重构这些微服务的协定。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-227">Yet another drawback with this direct client‑to‑service approach is that it makes it difficult to refactor the contracts for those microservices.</span></span> <span data-ttu-id="eeb1e-228">一段时间后，开发者可能需要更改系统分区到服务的方式。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-228">Over time developers might want to change how the system is partitioned into services.</span></span> <span data-ttu-id="eeb1e-229">例如，它们可能会合并两个服务或将一个服务拆分为两个或多个服务。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-229">For example, they might merge two services or split a service into two or more services.</span></span> <span data-ttu-id="eeb1e-230">但是，如果客户端直接与服务进行通信，执行这种重构可能会破坏与客户端应用的兼容性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-230">However, if clients communicate directly with the services, performing this kind of refactoring can break compatibility with client apps.</span></span>

<span data-ttu-id="eeb1e-231">正如体系结构部分所述，如果基于微服务设计和生成复杂应用程序，需要考虑使用多个细化 API 网关，而不是使用较简单的客户端到微服务直接通信方法。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-231">As mentioned in the architecture section, when designing and building a complex application based on microservices, you might consider the use of multiple fine-grained API Gateways instead of the simpler direct client‑to‑microservice communication approach.</span></span>

<span data-ttu-id="eeb1e-232">**微服务分区**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-232">**Partitioning the microservices**.</span></span> <span data-ttu-id="eeb1e-233">最后，无论针对微服务体系结构采用哪种方法，另一个难题是确定如何将端到端应用程序分区到多个微服务。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-233">Finally, no matter which approach you take for your microservice architecture, another challenge is deciding how to partition an end-to-end application into multiple microservices.</span></span> <span data-ttu-id="eeb1e-234">正如本指南的体系结构部分所述，可使用一系列技术和方法。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-234">As noted in the architecture section of the guide, there are several techniques and approaches you can take.</span></span> <span data-ttu-id="eeb1e-235">基本上，需要确定要从其他区域分离的应用程序区域，以及具有较少硬依赖项的区域。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-235">Basically, you need to identify areas of the application that are decoupled from the other areas and that have a low number of hard dependencies.</span></span> <span data-ttu-id="eeb1e-236">在许多情况下，这与按用例划分的分区服务一致。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-236">In many cases, this is aligned to partitioning services by use case.</span></span> <span data-ttu-id="eeb1e-237">例如，在 e-shop 应用程序中，订购服务负责与订购流程相关的所有业务逻辑。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-237">For example, in our e-shop application, we have an ordering service that is responsible for all the business logic related to the order process.</span></span> <span data-ttu-id="eeb1e-238">目录服务和购物篮服务则负责实现其他功能。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-238">We also have the catalog service and the basket service that implement other capabilities.</span></span> <span data-ttu-id="eeb1e-239">理想情况下，每个服务应仅具有一小部分职能。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-239">Ideally, each service should have only a small set of responsibilities.</span></span> <span data-ttu-id="eeb1e-240">这类似于应用于类的单一职责原则 (SRP)，该原则声明一个类应仅具有一个更改原因。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-240">This is similar to the single responsibility principle (SRP) applied to classes, which states that a class should only have one reason to change.</span></span> <span data-ttu-id="eeb1e-241">但我们现在探讨的是微服务，因此范围比单个类要大。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-241">But in this case, it is about microservices, so the scope will be larger than a single class.</span></span> <span data-ttu-id="eeb1e-242">最重要的是，微服务必须是端到端完全自主的，包括其自己数据源的职责。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-242">Most of all, a microservice has to be completely autonomous, end to end, including responsibility for its own data sources.</span></span>

## <a name="external-versus-internal-architecture-and-design-patterns"></a><span data-ttu-id="eeb1e-243">外部和内部体系结构和设计模式</span><span class="sxs-lookup"><span data-stu-id="eeb1e-243">External versus internal architecture and design patterns</span></span>

<span data-ttu-id="eeb1e-244">外部体系结构是由多个服务构成的微服务体系结构，遵循本指南中体系结构部分所介绍的原则。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-244">The external architecture is the microservice architecture composed by multiple services, following the principles described in the architecture section of this guide.</span></span> <span data-ttu-id="eeb1e-245">但是，根据每个微服务的本质，并独立于你所选择的高级别微服务体系结构，通常建议使用不同的内部体系结构，每个体系结构基于不同的模式，用于不同的微服务。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-245">However, depending on the nature of each microservice, and independently of high-level microservice architecture you choose, it is common and sometimes advisable to have different internal architectures, each based on different patterns, for different microservices.</span></span> <span data-ttu-id="eeb1e-246">微服务甚至可以使用不同的技术和编程语言。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-246">The microservices can even use different technologies and programming languages.</span></span> <span data-ttu-id="eeb1e-247">图 8-2 反映了此多样性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-247">Figure 8-2 illustrates this diversity.</span></span>

![](./media/image2.png)

<span data-ttu-id="eeb1e-248">**图 8-2**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-248">**Figure 8-2**.</span></span> <span data-ttu-id="eeb1e-249">外部和内部体系结构和设计</span><span class="sxs-lookup"><span data-stu-id="eeb1e-249">External versus internal architecture and design</span></span>

<span data-ttu-id="eeb1e-250">例如，在 eShopOnContainers 示例中，目录、购物篮和用户个人资料微服务很简单（基本上是 CRUD 子系统）。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-250">For instance, in our *eShopOnContainers* sample, the catalog, basket, and user profile microservices are simple (basically, CRUD subsystems).</span></span> <span data-ttu-id="eeb1e-251">因此，其内部体系结构和设计非常简单。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-251">Therefore, their internal architecture and design is straightforward.</span></span> <span data-ttu-id="eeb1e-252">但是，可能还有其他微服务，例如订购微服务，该服务更复杂，体现不断变化的业务规则，具有高度域复杂性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-252">However, you might have other microservices, such as the ordering microservice, which is more complex and represents ever-changing business rules with a high degree of domain complexity.</span></span> <span data-ttu-id="eeb1e-253">在这样的情况下，可能需要在特定微服务中实现更高级的模式，正如我们在 eShopOnContainers 订购微服务中采用的、使用域驱动设计 (DDD) 方法定义的模式。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-253">In cases like these, you might want to implement more advanced patterns within a particular microservice, like the ones defined with domain-driven design (DDD) approaches, as we are doing in the *eShopOnContainers* ordering microservice.</span></span> <span data-ttu-id="eeb1e-254">（我们将在下一部分中了解这些 DDD 模式，下一节介绍 eShopOnContainers 订购微服务的实现。）</span><span class="sxs-lookup"><span data-stu-id="eeb1e-254">(We will review these DDD patterns in the section later that explains the implementation of the *eShopOnContainers* ordering microservice.)</span></span>

<span data-ttu-id="eeb1e-255">每个微服务采用不同技术的另一个原因是每个微服务的本质。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-255">Another reason for a different technology per microservice might be the nature of each microservice.</span></span> <span data-ttu-id="eeb1e-256">例如，如果针对 AI 和机器学习域，最好使用功能编程语言，如 F\# 或 R，而不是面向对象编程语言，如 C\#。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-256">For example, it might be better to use a functional programming language like F\#, or even a language like R if you are targeting AI and machine learning domains, instead of a more object-oriented programming language like C\#.</span></span>

<span data-ttu-id="eeb1e-257">底线是每个微服务可基于不同设计模式具有不同内部体系结构。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-257">The bottom line is that each microservice can have a different internal architecture based on different design patterns.</span></span> <span data-ttu-id="eeb1e-258">并非所有微服务都应使用高级 DDD 模式实现，因为这可能会对其过度工程。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-258">Not all microservices should be implemented using advanced DDD patterns, because that would be over-engineering them.</span></span> <span data-ttu-id="eeb1e-259">类似地，具有不断变化业务逻辑的复杂微服务不应作为 CRUD 组件实现，否则会导致低质量代码。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-259">Similarly, complex microservices with ever-changing business logic should not be implemented as CRUD components, or you can end up with low-quality code.</span></span>



## <a name="the-new-world-multiple-architectural-patterns-and-polyglot-microservices"></a><span data-ttu-id="eeb1e-260">新体系：多个体系结构模式和 polyglot 微服务</span><span class="sxs-lookup"><span data-stu-id="eeb1e-260">The new world: multiple architectural patterns and polyglot microservices</span></span>

<span data-ttu-id="eeb1e-261">软件架构师和开发人员使用许多体系结构模式。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-261">There are many architectural patterns used by software architects and developers.</span></span> <span data-ttu-id="eeb1e-262">以下是一些模式（混合体系结构样式和体系结构模式）：：</span><span class="sxs-lookup"><span data-stu-id="eeb1e-262">The following are a few (mixing architecture styles and architecture patterns):</span></span>

-   <span data-ttu-id="eeb1e-263">简单 CRUD、单层级、单层。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-263">Simple CRUD, single-tier, single-layer.</span></span>

-   <span data-ttu-id="eeb1e-264">[传统 N 分层](https://msdn.microsoft.com/library/ee658109.aspx#Layers)。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-264">[Traditional N-Layered](https://msdn.microsoft.com/library/ee658109.aspx#Layers).</span></span>

-   <span data-ttu-id="eeb1e-265">[域驱动设计 N 分层](https://blogs.msdn.microsoft.com/cesardelatorre/2011/07/03/published-first-alpha-version-of-domain-oriented-n-layered-architecture-v2-0/)。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-265">[Domain-Driven Design N-layered](https://blogs.msdn.microsoft.com/cesardelatorre/2011/07/03/published-first-alpha-version-of-domain-oriented-n-layered-architecture-v2-0/).</span></span>

-   <span data-ttu-id="eeb1e-266">[清洁体系结构](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)（用于 [eShopOnWeb](http://aka.ms/WebAppArchitecture)）</span><span class="sxs-lookup"><span data-stu-id="eeb1e-266">[Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) (as used with [eShopOnWeb](http://aka.ms/WebAppArchitecture))</span></span>

-   <span data-ttu-id="eeb1e-267">[命令查询职责分离](https://martinfowler.com/bliki/CQRS.html) (CQRS)。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-267">[Command and Query Responsibility Segregation](https://martinfowler.com/bliki/CQRS.html) (CQRS).</span></span>

-   <span data-ttu-id="eeb1e-268">[事件驱动的体系结构](https://en.wikipedia.org/wiki/Event-driven_architecture) (EDA)。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-268">[Event-Driven Architecture](https://en.wikipedia.org/wiki/Event-driven_architecture) (EDA).</span></span>

<span data-ttu-id="eeb1e-269">还可使用许多技术和语言生成微服务，例如 ASP.NET Core Web API、NancyFx、ASP.NET Core SignalR（.NET Core 2 可用）、F\#Node.js、Python、Java, C++、GoLang 等。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-269">You can also build microservices with many technologies and languages, such as ASP.NET Core Web APIs, NancyFx, ASP.NET Core SignalR (available with .NET Core 2), F\#, Node.js, Python, Java, C++, GoLang, and more.</span></span>

<span data-ttu-id="eeb1e-270">请注意，没有适用于所有情况的特定体系结构模式、样式或技术。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-270">The important point is that no particular architecture pattern or style, nor any particular technology, is right for all situations.</span></span> <span data-ttu-id="eeb1e-271">图 8-3 显示了一些可用于不同微服务的方法和技术（但不是按照特定顺序）。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-271">Figure 8-3 shows some approaches and technologies (although not in any particular order) that could be used in different microservices.</span></span>

![](./media/image3.png)

<span data-ttu-id="eeb1e-272">**图 8-3**。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-272">**Figure 8-3**.</span></span> <span data-ttu-id="eeb1e-273">多体系结构模式和 polyglot 微服务体系</span><span class="sxs-lookup"><span data-stu-id="eeb1e-273">Multi-architectural patterns and the polyglot microservices world</span></span>

<span data-ttu-id="eeb1e-274">如图 8-3 所示，在由许多微服务（域驱动设计术语中的绑定上下文，或作为自主微服务的“子系统”）构成的应用程序中，可能会采用不同方式实现每个微服务。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-274">As shown in Figure 8-3, in applications composed of many microservices (Bounded Contexts in domain-driven design terminology, or simply “subsystems” as autonomous microservices), you might implement each microservice in a different way.</span></span> <span data-ttu-id="eeb1e-275">每个微服务可能具有不同体系结构模式，使用不同语言和数据库，具体取决于应用程序的本质、业务要求和优先级。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-275">Each might have a different architecture pattern and use different languages and databases depending on the application’s nature, business requirements, and priorities.</span></span> <span data-ttu-id="eeb1e-276">在某些情况下，微服务可能相似。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-276">In some cases, the microservices might be similar.</span></span> <span data-ttu-id="eeb1e-277">但这并不常见，因为每个子系统的上下文边界和要求通常不同。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-277">But that is not usually the case, because each subsystem’s context boundary and requirements are usually different.</span></span>

<span data-ttu-id="eeb1e-278">例如，对于简单的 CRUD 维护应用程序，设计和实现 DDD 模式可能无意义。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-278">For instance, for a simple CRUD maintenance application, it might not make sense to design and implement DDD patterns.</span></span> <span data-ttu-id="eeb1e-279">但对于核心域或核心业务，可能需要应用更高级的模式，以应对不断变化的业务规则的业务复杂性。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-279">But for your core domain or core business, you might need to apply more advanced patterns to tackle business complexity with ever-changing business rules.</span></span>

<span data-ttu-id="eeb1e-280">尤其是处理由多个子系统构成的大型应用程序时，不应基于单个体系结构模式应用单个顶级体系结构。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-280">Especially when you deal with large applications composed by multiple sub-systems, you should not apply a single top-level architecture based on a single architecture pattern.</span></span> <span data-ttu-id="eeb1e-281">例如，CQRS 不应作为整个应用程序的顶级体系结构，但可能适用于一组特定的服务。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-281">For instance, CQRS should not be applied as a top-level architecture for a whole application, but might be useful for a specific set of services.</span></span>

<span data-ttu-id="eeb1e-282">没有在任何情况下都通用的体系结构模式。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-282">There is no silver bullet or a right architecture pattern for every given case.</span></span> <span data-ttu-id="eeb1e-283">不可能有适合所有情况的体系结构模式。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-283">You cannot have “one architecture pattern to rule them all.”</span></span> <span data-ttu-id="eeb1e-284">必须根据每个微服务的优先级，为每个微服务选择不同方法，如以下各节所述。</span><span class="sxs-lookup"><span data-stu-id="eeb1e-284">Depending on the priorities of each microservice, you must choose a different approach for each, as explained in the following sections.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="eeb1e-285">[Previous] (index.md) [Next] (data-driven-crud-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="eeb1e-285">[Previous] (index.md) [Next] (data-driven-crud-microservice.md)</span></span>
