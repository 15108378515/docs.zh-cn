---
title: "设计面向微服务构成的应用程序"
description: "为容器化的.NET 应用程序的.NET 微服务体系结构 |设计面向微服务构成的应用程序"
keywords: "Docker, 微服务, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 1e1dc919c7e35580576c86b4cf9872b4f8cea2c2
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/22/2017
---
# <a name="designing-a-microservice-oriented-application"></a><span data-ttu-id="a5abf-104">设计面向微服务构成的应用程序</span><span class="sxs-lookup"><span data-stu-id="a5abf-104">Designing a microservice-oriented application</span></span>

<span data-ttu-id="a5abf-105">本部分重点介绍开发假设服务器端企业应用程序。</span><span class="sxs-lookup"><span data-stu-id="a5abf-105">This section focuses on developing a hypothetical server-side enterprise application.</span></span>

## <a name="application-specifications"></a><span data-ttu-id="a5abf-106">应用程序规范</span><span class="sxs-lookup"><span data-stu-id="a5abf-106">Application specifications</span></span>

<span data-ttu-id="a5abf-107">假设应用程序执行业务逻辑、 访问数据库，并返回 HTML、 JSON 或 XML 响应处理请求。</span><span class="sxs-lookup"><span data-stu-id="a5abf-107">The hypothetical application handles requests by executing business logic, accessing databases, and then returning HTML, JSON, or XML responses.</span></span> <span data-ttu-id="a5abf-108">我们将假定该应用程序必须支持各种客户端，包括桌面浏览器运行单页面应用程序 (Spa)、 传统 web 应用程序、 移动 web 应用和本机移动应用。</span><span class="sxs-lookup"><span data-stu-id="a5abf-108">We will say that the application must support a variety of clients, including desktop browsers running Single Page Applications (SPAs), traditional web apps, mobile web apps, and native mobile apps.</span></span> <span data-ttu-id="a5abf-109">应用程序还可能会公开一个 API，使第三方使用。</span><span class="sxs-lookup"><span data-stu-id="a5abf-109">The application might also expose an API for third parties to consume.</span></span> <span data-ttu-id="a5abf-110">它还应该能够以异步方式将其微服务或外部应用程序的集成，以便的方法将帮助的微服务对于部分故障的复原能力。</span><span class="sxs-lookup"><span data-stu-id="a5abf-110">It should also be able to integrate its microservices or external applications asynchronously, so that approach will help resiliency of the microservices in the case of partial failures.</span></span>

<span data-ttu-id="a5abf-111">应用程序将这些类型的组件包括：</span><span class="sxs-lookup"><span data-stu-id="a5abf-111">The application will consist of these types of components:</span></span>

-   <span data-ttu-id="a5abf-112">表示组件。</span><span class="sxs-lookup"><span data-stu-id="a5abf-112">Presentation components.</span></span> <span data-ttu-id="a5abf-113">这些是负责处理用户界面和使用远程服务。</span><span class="sxs-lookup"><span data-stu-id="a5abf-113">These are responsible for handling the UI and consuming remote services.</span></span>

-   <span data-ttu-id="a5abf-114">域或业务逻辑。</span><span class="sxs-lookup"><span data-stu-id="a5abf-114">Domain or business logic.</span></span> <span data-ttu-id="a5abf-115">这是应用程序的域的逻辑。</span><span class="sxs-lookup"><span data-stu-id="a5abf-115">This is the application’s domain logic.</span></span>

-   <span data-ttu-id="a5abf-116">数据库访问逻辑。</span><span class="sxs-lookup"><span data-stu-id="a5abf-116">Database access logic.</span></span> <span data-ttu-id="a5abf-117">这包括数据访问组件负责访问数据库 （SQL 或 NoSQL）。</span><span class="sxs-lookup"><span data-stu-id="a5abf-117">This consists of data access components responsible for accessing databases (SQL or NoSQL).</span></span>

-   <span data-ttu-id="a5abf-118">应用程序集成逻辑。</span><span class="sxs-lookup"><span data-stu-id="a5abf-118">Application integration logic.</span></span> <span data-ttu-id="a5abf-119">这包括主要基于消息代理的消息传递通道。</span><span class="sxs-lookup"><span data-stu-id="a5abf-119">This includes a messaging channel, mainly based on message brokers.</span></span>

<span data-ttu-id="a5abf-120">应用程序需要高可伸缩性，同时允许其垂直的子系统来自主，向外扩展，因为某些子系统需要比其他的多个可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="a5abf-120">The application will require high scalability, while allowing its vertical subsystems to scale out autonomously, because certain subsystems will require more scalability than others.</span></span>

<span data-ttu-id="a5abf-121">应用程序必须能够在多个基础结构环境 （多个公共云基础架构并在本地） 部署，理想情况下应该可以跨平台，可以轻松地将从 Linux 为 Windows （反之亦然）。</span><span class="sxs-lookup"><span data-stu-id="a5abf-121">The application must be able to be deployed in multiple infrastructure environments (multiple public clouds and on-premises) and ideally should be cross-platform, able to move from Linux to Windows (or vice versa) easily.</span></span>

## <a name="development-team-context"></a><span data-ttu-id="a5abf-122">开发团队上下文</span><span class="sxs-lookup"><span data-stu-id="a5abf-122">Development team context</span></span>

<span data-ttu-id="a5abf-123">我们还假设以下关于应用程序的开发过程：</span><span class="sxs-lookup"><span data-stu-id="a5abf-123">We also assume the following about the development process for the application:</span></span>

-   <span data-ttu-id="a5abf-124">必须将重点放在应用程序的不同业务区域上的多个开发团队。</span><span class="sxs-lookup"><span data-stu-id="a5abf-124">You have multiple dev teams focusing on different business areas of the application.</span></span>

-   <span data-ttu-id="a5abf-125">新的团队成员必须提高工作效率快速，以及应用程序必须易于理解和修改。</span><span class="sxs-lookup"><span data-stu-id="a5abf-125">New team members must become productive quickly, and the application must be easy to understand and modify.</span></span>

-   <span data-ttu-id="a5abf-126">应用程序将具有的长期发展和不断变化的业务规则。</span><span class="sxs-lookup"><span data-stu-id="a5abf-126">The application will have a long-term evolution and ever-changing business rules.</span></span>

-   <span data-ttu-id="a5abf-127">你需要良好的长期可维护性意味着具有灵活性，同时能够使用在其他子系统上的最小影响更新多个子系统实现将来新更改时。</span><span class="sxs-lookup"><span data-stu-id="a5abf-127">You need good long-term maintainability, which means having agility when implementing new changes in the future while being able to update multiple subsystems with minimum impact on the other subsystems.</span></span>

-   <span data-ttu-id="a5abf-128">你想做法持续集成和连续部署的应用程序。</span><span class="sxs-lookup"><span data-stu-id="a5abf-128">You want to practice continuous integration and continuous deployment of the application.</span></span>

-   <span data-ttu-id="a5abf-129">你想要利用新兴技术 （框架，编程语言，等等） 时不断演变的应用程序。</span><span class="sxs-lookup"><span data-stu-id="a5abf-129">You want to take advantage of emerging technologies (frameworks, programming languages, etc.) while evolving the application.</span></span> <span data-ttu-id="a5abf-130">您不想要使应用程序的完整迁移，在迁移到新的技术，因为这将导致高成本，并影响的可预测性和应用程序的稳定性。</span><span class="sxs-lookup"><span data-stu-id="a5abf-130">You do not want to make full migrations of the application when moving to new technologies, because that would result in high costs and impact the predictability and stability of the application.</span></span>

## <a name="choosing-an-architecture"></a><span data-ttu-id="a5abf-131">选择一种体系结构</span><span class="sxs-lookup"><span data-stu-id="a5abf-131">Choosing an architecture</span></span>

<span data-ttu-id="a5abf-132">应用程序部署体系结构应该是什么？</span><span class="sxs-lookup"><span data-stu-id="a5abf-132">What should the application deployment architecture be?</span></span> <span data-ttu-id="a5abf-133">对于应用程序，以及开发上下文中，规范强烈建议你应通过将其分解到自治子系统中的协作微服务和容器，窗体，其中 microservice 设计应用程序是一个容器。</span><span class="sxs-lookup"><span data-stu-id="a5abf-133">The specifications for the application, along with the development context, strongly suggest that you should architect the application by decomposing it into autonomous subsystems in the form of collaborating microservices and containers, where a microservice is a container.</span></span>

<span data-ttu-id="a5abf-134">在此方法中，每个服务 （容器） 实现一组提供一致性和较窄相关的函数。</span><span class="sxs-lookup"><span data-stu-id="a5abf-134">In this approach, each service (container) implements a set of cohesive and narrowly related functions.</span></span> <span data-ttu-id="a5abf-135">例如，应用程序可能包含目录服务，服务、 购物篮服务、 用户配置文件服务、 等排序等服务。</span><span class="sxs-lookup"><span data-stu-id="a5abf-135">For example, an application might consist of services such as the catalog service, ordering service, basket service, user profile service, etc.</span></span>

<span data-ttu-id="a5abf-136">微服务通信使用协议如 HTTP (REST)，但也以异步方式 （即 AMQP） 只要有可能，尤其是当传播使用更新集成事件。</span><span class="sxs-lookup"><span data-stu-id="a5abf-136">Microservices communicate using protocols such as HTTP (REST), but also asynchronously (that is AMQP) whenever possible, especially when propagating updates with integration events.</span></span>

<span data-ttu-id="a5abf-137">开发和部署为独立于另一个容器微服务时。</span><span class="sxs-lookup"><span data-stu-id="a5abf-137">Microservices are developed and deployed as containers independently of one another.</span></span> <span data-ttu-id="a5abf-138">这意味着，可以开发和部署某些 microservice 而不会影响其他子系统，开发团队。</span><span class="sxs-lookup"><span data-stu-id="a5abf-138">This means that a development team can be developing and deploying a certain microservice without impacting other subsystems.</span></span>

<span data-ttu-id="a5abf-139">每个微服务都有自己的数据库，使其能够从其他微服务完全分离。</span><span class="sxs-lookup"><span data-stu-id="a5abf-139">Each microservice has its own database, allowing it to be fully decoupled from other microservices.</span></span> <span data-ttu-id="a5abf-140">如有必要，从不同的微服务的数据库之间的一致性被实现使用 （通过逻辑事件 bus) 的应用程序级集成事件的处理命令和查询责任分离 (CQRS) 中。</span><span class="sxs-lookup"><span data-stu-id="a5abf-140">When necessary, consistency between databases from different microservices is achieved using application-level integration events (through a logical event bus), as handled in Command and Query Responsibility Segregation (CQRS).</span></span> <span data-ttu-id="a5abf-141">正因如此，业务约束必须接受多个微服务之间的最终一致性和相关数据库。</span><span class="sxs-lookup"><span data-stu-id="a5abf-141">Because of that, the business constraints must embrace eventual consistency between the multiple microservices and related databases.</span></span>

### <a name="eshoponcontainers-a-reference-application-for-net-core-and-microservices-deployed-using-containers"></a><span data-ttu-id="a5abf-142">eShopOnContainers： 用于.NET 核心和微服务部署使用容器的引用应用程序</span><span class="sxs-lookup"><span data-stu-id="a5abf-142">eShopOnContainers: A reference application for .NET Core and microservices deployed using containers</span></span>

<span data-ttu-id="a5abf-143">以便你可以专注于体系结构和技术而不是你可能不知道 hypothetic 业务领域的考虑，我们已选择的已知的业务域 — 即的简化的电子商务 （e-式应用商店） 应用程序提供的目录产品，接受来自客户的订单，验证清单，并执行其他业务功能。</span><span class="sxs-lookup"><span data-stu-id="a5abf-143">So that you can focus on the architecture and technologies instead of thinking about a hypothetic business domain that you might not know, we have selected a well-known business domain—namely, a simplified e-commerce (e-shop) application that presents a catalog of products, takes orders from customers, verifies inventory, and performs other business functions.</span></span> <span data-ttu-id="a5abf-144">此容器基于应用程序的源代码位于[eShopOnContainers](http://aka.ms/MicroservicesArchitecture) GitHub 存储库。</span><span class="sxs-lookup"><span data-stu-id="a5abf-144">This container-based application source code is available in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) GitHub repo.</span></span>

<span data-ttu-id="a5abf-145">该应用程序包含多个子系统，包括多个应用商店 UI 前端 （Web 应用程序和本机移动应用程序），以及后端微服务和容器的所有所需的服务器端操作。</span><span class="sxs-lookup"><span data-stu-id="a5abf-145">The application consists of multiple subsystems, including several store UI front ends (a Web application and a native mobile app), along with the back-end microservices and containers for all the required server-side operations.</span></span> <span data-ttu-id="a5abf-146">图 8-1 显示引用应用程序的体系结构。</span><span class="sxs-lookup"><span data-stu-id="a5abf-146">Figure 8-1 shows the architecture of the reference application.</span></span>

![](./media/image1.png)

<span data-ttu-id="a5abf-147">**图 8-1**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-147">**Figure 8-1**.</span></span> <span data-ttu-id="a5abf-148">EShopOnContainers 引用演示直接的微服务构成客户端通信和事件 bus 的应用程序</span><span class="sxs-lookup"><span data-stu-id="a5abf-148">The eShopOnContainers reference application, showing a direct client-to-microservice communication and the event bus</span></span>

<span data-ttu-id="a5abf-149">**宿主环境**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-149">**Hosting environment**.</span></span> <span data-ttu-id="a5abf-150">在图 8-1，你会看到一个 Docker 主机中部署的多个容器。</span><span class="sxs-lookup"><span data-stu-id="a5abf-150">In Figure 8-1, you see several containers deployed within a single Docker host.</span></span> <span data-ttu-id="a5abf-151">部署到使用 docker 一台 Docker 主机时，会出现此情况的编写命令。</span><span class="sxs-lookup"><span data-stu-id="a5abf-151">That would be the case when deploying to a single Docker host with the docker-compose up command.</span></span> <span data-ttu-id="a5abf-152">但是，如果你是使用 orchestrator 或容器群集时，每个容器无法在另一台主机 （节点） 中运行，并且任何节点无法运行任意数量的容器，如我们前面所述体系结构节中。</span><span class="sxs-lookup"><span data-stu-id="a5abf-152">However, if you are using an orchestrator or container cluster, each container could be running in a different host (node), and any node could be running any number of containers, as we explained earlier in the architecture section.</span></span>

<span data-ttu-id="a5abf-153">**通信体系结构**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-153">**Communication architecture**.</span></span> <span data-ttu-id="a5abf-154">EShopOnContainers 应用程序使用两个通信类型，具体取决于功能的操作 （而不是更新和事务的查询） 的类型：</span><span class="sxs-lookup"><span data-stu-id="a5abf-154">The eShopOnContainers application uses two communication types, depending on the kind of the functional action (queries versus updates and transactions):</span></span>

-   <span data-ttu-id="a5abf-155">直接微服务构成客户端通信。</span><span class="sxs-lookup"><span data-stu-id="a5abf-155">Direct client-to-microservice communication.</span></span> <span data-ttu-id="a5abf-156">接受更新或从客户端应用程序的事务处理命令时，这用于查询和。</span><span class="sxs-lookup"><span data-stu-id="a5abf-156">This is used for queries and when accepting update or transactional commands from the client apps.</span></span>

-   <span data-ttu-id="a5abf-157">基于事件的异步通信。</span><span class="sxs-lookup"><span data-stu-id="a5abf-157">Asynchronous event-based communication.</span></span> <span data-ttu-id="a5abf-158">通过在微服务之间传播更新，或与外部应用程序集成事件总线发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="a5abf-158">This occurs through an event bus to propagate updates across microservices or to integrate with external applications.</span></span> <span data-ttu-id="a5abf-159">可以使用任何如 RabbitMQ，或使用 Azure Service Bus、 NServiceBus、 MassTransit 或 Brighter 等的更高级别的服务总线的消息传递代理基础结构技术实现的事件总线。</span><span class="sxs-lookup"><span data-stu-id="a5abf-159">The event bus can be implemented with any messaging-broker infrastructure technology like RabbitMQ, or using higher-level service buses like Azure Service Bus, NServiceBus, MassTransit, or Brighter.</span></span>

<span data-ttu-id="a5abf-160">作为一套微服务容器的形式部署应用程序。</span><span class="sxs-lookup"><span data-stu-id="a5abf-160">The application is deployed as a set of microservices in the form of containers.</span></span> <span data-ttu-id="a5abf-161">客户端应用程序可以与这些容器通信以及微服务之间进行通信。</span><span class="sxs-lookup"><span data-stu-id="a5abf-161">Client apps can communicate with those containers as well as communicate between microservices.</span></span> <span data-ttu-id="a5abf-162">如前文所述，此初始体系结构使用直接微服务构成客户端通信体系结构，这意味着，直接客户端应用程序可以发出请求到每个微服务。</span><span class="sxs-lookup"><span data-stu-id="a5abf-162">As mentioned, this initial architecture is using a direct client-to-microservice communication architecture, which means that a client application can make requests to each of the microservices directly.</span></span> <span data-ttu-id="a5abf-163">每个微服务具有类似 https://servicename.applicationname.companyname 公共终结点。</span><span class="sxs-lookup"><span data-stu-id="a5abf-163">Each microservice has a public endpoint like https://servicename.applicationname.companyname.</span></span> <span data-ttu-id="a5abf-164">如果需要，每个微服务可以使用其他 TCP 端口。</span><span class="sxs-lookup"><span data-stu-id="a5abf-164">If required, each microservice can use a different TCP port.</span></span> <span data-ttu-id="a5abf-165">在生产中，URL 将映射到微服务的负载平衡器，其中将请求分布到可用的微服务实例。</span><span class="sxs-lookup"><span data-stu-id="a5abf-165">In production, that URL would map to the microservices’ load balancer, which distributes requests across the available microservice instances.</span></span>

<span data-ttu-id="a5abf-166">**API 网关 vs 的重要说明。在 eShopOnContainers 的直接通信。**</span><span class="sxs-lookup"><span data-stu-id="a5abf-166">**Important note on API Gateway vs. Direct Communication in eShopOnContainers.**</span></span> <span data-ttu-id="a5abf-167">如本指南的体系结构部分中所述，直接微服务构成客户端通信体系结构可以在生成的大型复杂基于微服务构成的应用程序有缺点。</span><span class="sxs-lookup"><span data-stu-id="a5abf-167">As explained in the architecture section of this guide, the direct client-to-microservice communication architecture can have drawbacks when you are building a large and complex microservice-based application.</span></span> <span data-ttu-id="a5abf-168">但它可以对已经足够好一个小的应用程序，如 eShopOnContainers 中启动应用程序，其目标是要专注于更简单的获取的 Docker 容器基于应用程序，并且我们不想创建可以影响单个整体 API 网关微服务的开发自治。</span><span class="sxs-lookup"><span data-stu-id="a5abf-168">But it can be good enough for a small application, such as in the eShopOnContainers application, where the goal is to focus on a simpler getting started Docker container-based application and we didn’t want to create a single monolithic API Gateway that can impact the microservices’ development autonomy.</span></span>

<span data-ttu-id="a5abf-169">但是，如果你要设计大型基于微服务构成的应用程序的微服务数十个，我们强烈建议你考虑 API 网关模式，如我们的体系结构部分中所述。</span><span class="sxs-lookup"><span data-stu-id="a5abf-169">But, if you are going to design a large microservice-based application with dozens of microservices, we strongly recommend that you consider the API Gateway pattern, as we explained in the architecture section.</span></span>
<span data-ttu-id="a5abf-170">无法重构此体系结构决策后立即可供生产应用程序和专门进行外观考虑为远程客户端。</span><span class="sxs-lookup"><span data-stu-id="a5abf-170">This architectural decision could be refactored once thinking about production-ready applications and specially-made facades for remote clients.</span></span> <span data-ttu-id="a5abf-171">具有多个的自定义 API 网关具体取决于客户端应用程序的外观可以提供有关每个客户端应用程序的不同的数据聚合的好处以及可以向客户端应用隐藏内部微服务或 Api 和单个该层中授权。</span><span class="sxs-lookup"><span data-stu-id="a5abf-171">Having multiple custom API Gateways depending on the client apps' form-factor can provide benefits in regard to different data aggregation per client app plus you can hide internal microservices or APIs to the client apps and authorize in that single tier.</span></span> 

<span data-ttu-id="a5abf-172">但是，并且提到过，请注意针对大型和整体 API 网关，可能会终止微服务的开发自治。</span><span class="sxs-lookup"><span data-stu-id="a5abf-172">However, and as mentioned, beware against large and monolithic API Gateways that might kill your microservices' development autonomy.</span></span>

### <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="a5abf-173">每个微服务构成的数据自主性</span><span class="sxs-lookup"><span data-stu-id="a5abf-173">Data sovereignty per microservice</span></span>

<span data-ttu-id="a5abf-174">在示例应用程序，每个微服务拥有其自己的数据库或数据源，并且每个数据库或数据源部署为另一个容器。</span><span class="sxs-lookup"><span data-stu-id="a5abf-174">In the sample application, each microservice owns its own database or data source, and each database or data source is deployed as another container.</span></span> <span data-ttu-id="a5abf-175">这种设计决策进行仅以方便开发人员可以从 GitHub 获取代码、 克隆它，并在 Visual Studio 或 Visual Studio Code 中打开它。</span><span class="sxs-lookup"><span data-stu-id="a5abf-175">This design decision was made only to make it easy for a developer to get the code from GitHub, clone it, and open it in Visual Studio or Visual Studio Code.</span></span> <span data-ttu-id="a5abf-176">或，或者，它可以轻松地编译自定义的 Docker 映像使用.NET 核心 CLI 和 Docker CLI 中，然后部署和在 Docker 开发环境中运行。</span><span class="sxs-lookup"><span data-stu-id="a5abf-176">Or alternatively, it makes it easy to compile the custom Docker images using .NET Core CLI and the Docker CLI, and then deploy and run them in a Docker development environment.</span></span> <span data-ttu-id="a5abf-177">两种方式的容器用于数据源的允许开发人员生成和部署在几分钟内，而无需设置外部数据库或任何其他数据源具有对基础结构 （云中或本地） 的硬依赖项。</span><span class="sxs-lookup"><span data-stu-id="a5abf-177">Either way, using containers for data sources lets developers build and deploy in a matter of minutes without having to provision an external database or any other data source with hard dependencies on infrastructure (cloud or on-premises).</span></span>

<span data-ttu-id="a5abf-178">在实际生产环境中，高可用性和可伸缩性，数据库应基于数据库服务器中的云或本地，但不是在容器。</span><span class="sxs-lookup"><span data-stu-id="a5abf-178">In a real production environment, for high availability and for scalability, the databases should be based on database servers in the cloud or on-premises, but not in containers.</span></span>

<span data-ttu-id="a5abf-179">因此，部署微服务 （和即使对于此应用程序中的数据库） 的单位为 Docker 容器，并且引用应用程序是一个多容器应用程序，可满足微服务原则。</span><span class="sxs-lookup"><span data-stu-id="a5abf-179">Therefore, the units of deployment for microservices (and even for databases in this application) are Docker containers, and the reference application is a multi-container application that embraces microservices principles.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="a5abf-180">其他资源</span><span class="sxs-lookup"><span data-stu-id="a5abf-180">Additional resources</span></span>

-   <span data-ttu-id="a5abf-181">**eShopOnContainers GitHub 存储库。源引用应用程序的代码**
    *https://aka.ms/eShopOnContainers/*</span><span class="sxs-lookup"><span data-stu-id="a5abf-181">**eShopOnContainers GitHub repo. Source code for the reference application**
*https://aka.ms/eShopOnContainers/*</span></span>

## <a name="benefits-of-a-microservice-based-solution"></a><span data-ttu-id="a5abf-182">一个基于微服务构成的解决方案的优点</span><span class="sxs-lookup"><span data-stu-id="a5abf-182">Benefits of a microservice-based solution</span></span>

<span data-ttu-id="a5abf-183">像这样一个基于 microservice 解决方案带来诸多好处：</span><span class="sxs-lookup"><span data-stu-id="a5abf-183">A microservice based solution like this has many benefits:</span></span>

<span data-ttu-id="a5abf-184">**每个微服务是相对较小-易于管理和发展**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-184">**Each microservice is relatively small—easy to manage and evolve**.</span></span> <span data-ttu-id="a5abf-185">尤其是在下列情况下：</span><span class="sxs-lookup"><span data-stu-id="a5abf-185">Specifically:</span></span>

-   <span data-ttu-id="a5abf-186">很容易开发人员了解并快速开始使用良好的工作效率。</span><span class="sxs-lookup"><span data-stu-id="a5abf-186">It is easy for a developer to understand and get started quickly with good productivity.</span></span>

-   <span data-ttu-id="a5abf-187">这使得开发人员提高工作效率，快速、 启动容器。</span><span class="sxs-lookup"><span data-stu-id="a5abf-187">Containers start fast, which makes developers more productive.</span></span>

-   <span data-ttu-id="a5abf-188">IDE 类似于 Visual Studio 可以负载较小项目快，使开发人员工作效率。</span><span class="sxs-lookup"><span data-stu-id="a5abf-188">An IDE like Visual Studio can load smaller projects fast, making developers productive.</span></span>

-   <span data-ttu-id="a5abf-189">每个微服务可以设计、 开发和部署独立于其他的微服务，提供灵活性，因为它是更轻松地频繁部署微服务的新版本。</span><span class="sxs-lookup"><span data-stu-id="a5abf-189">Each microservice can be designed, developed, and deployed independently of other microservices, which provides agility because it is easier to deploy new versions of microservices frequently.</span></span>

<span data-ttu-id="a5abf-190">**可以横向扩展应用程序的各个区域**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-190">**It is possible to scale out individual areas of the application**.</span></span> <span data-ttu-id="a5abf-191">例如，目录服务或购物篮服务可能需要向外扩展，但不是排序的过程。</span><span class="sxs-lookup"><span data-stu-id="a5abf-191">For instance, the catalog service or the basket service might need to be scaled out, but not the ordering process.</span></span> <span data-ttu-id="a5abf-192">微服务基础结构将更高效减少比整体体系结构，向外缩放时使用的资源。</span><span class="sxs-lookup"><span data-stu-id="a5abf-192">A microservices infrastructure will be much more efficient with regard to the resources used when scaling out than a monolithic architecture would be.</span></span>

<span data-ttu-id="a5abf-193">**你可以将多个团队的开发工作划分**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-193">**You can divide the development work between multiple teams**.</span></span> <span data-ttu-id="a5abf-194">每个服务可以拥有的是单个开发团队。</span><span class="sxs-lookup"><span data-stu-id="a5abf-194">Each service can be owned by a single development team.</span></span> <span data-ttu-id="a5abf-195">每个团队可以管理、 开发、 部署和缩放其服务独立于团队的其余部分。</span><span class="sxs-lookup"><span data-stu-id="a5abf-195">Each team can manage, develop, deploy, and scale their service independently of the rest of the teams.</span></span>

<span data-ttu-id="a5abf-196">**问题是更好隔离**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-196">**Issues are more isolated**.</span></span> <span data-ttu-id="a5abf-197">如果一个服务时出现问题，只有该服务最初影响 （除非错误设计使用时，直接之间的相关性微服务），和其他服务可以继续处理请求。</span><span class="sxs-lookup"><span data-stu-id="a5abf-197">If there is an issue in one service, only that service is initially impacted (except when the wrong design is used, with direct dependencies between microservices), and other services can continue to handle requests.</span></span> <span data-ttu-id="a5abf-198">相比之下，整体部署体系结构中的一个异常的组件可以关闭整个系统中，尤其是当涉及资源，例如内存泄漏。</span><span class="sxs-lookup"><span data-stu-id="a5abf-198">In contrast, one malfunctioning component in a monolithic deployment architecture can bring down the entire system, especially when it involves resources, such as a memory leak.</span></span> <span data-ttu-id="a5abf-199">此外时微服务中的问题得以解决后，, 可以部署仅受影响的微服务，而不会影响应用程序的其余部分。</span><span class="sxs-lookup"><span data-stu-id="a5abf-199">Additionally, when an issue in a microservice is resolved, you can deploy just the affected microservice without impacting the rest of the application.</span></span>

<span data-ttu-id="a5abf-200">**你可以使用最新技术**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-200">**You can use the latest technologies**.</span></span> <span data-ttu-id="a5abf-201">因为你可以开始独立开发服务，然后运行它们并排 （得益于容器和.NET Core），你可以开始而不停滞在较旧的堆栈或框架，用于整个迅速地使用的最新技术和框架应用程序。</span><span class="sxs-lookup"><span data-stu-id="a5abf-201">Because you can start developing services independently and run them side by side (thanks to containers and .NET Core), you can start using the latest technologies and frameworks expediently instead of being stuck on an older stack or framework for the whole application.</span></span>

## <a name="downsides-of-a-microservice-based-solution"></a><span data-ttu-id="a5abf-202">一个基于微服务构成的解决方案的不足之处</span><span class="sxs-lookup"><span data-stu-id="a5abf-202">Downsides of a microservice-based solution</span></span>

<span data-ttu-id="a5abf-203">像这样一个基于 microservice 解决方案还存在一些缺点：</span><span class="sxs-lookup"><span data-stu-id="a5abf-203">A microservice based solution like this also has some drawbacks:</span></span>

<span data-ttu-id="a5abf-204">**分布式应用程序**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-204">**Distributed application**.</span></span> <span data-ttu-id="a5abf-205">分发应用程序的开发人员增加复杂性，当设计和构建这些服务。</span><span class="sxs-lookup"><span data-stu-id="a5abf-205">Distributing the application adds complexity for developers when they are designing and building the services.</span></span> <span data-ttu-id="a5abf-206">例如，开发人员必须实现 interservice 通信使用协议，如 HTTP 或 AMPQ，增加了用于测试和异常处理的复杂性。</span><span class="sxs-lookup"><span data-stu-id="a5abf-206">For example, developers must implement interservice communication using protocols like HTTP or AMPQ, which adds complexity for testing and exception handling.</span></span> <span data-ttu-id="a5abf-207">它还添加到系统的延迟。</span><span class="sxs-lookup"><span data-stu-id="a5abf-207">It also adds latency to the system.</span></span>

<span data-ttu-id="a5abf-208">**部署的复杂性**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-208">**Deployment complexity**.</span></span> <span data-ttu-id="a5abf-209">拥有数十微服务类型，并需要高可伸缩性 （它需要能够创建每个服务的多个实例和这些服务分摊到多个主机） 的应用程序的方法来 IT 运营和管理部署的复杂性度很高。</span><span class="sxs-lookup"><span data-stu-id="a5abf-209">An application that has dozens of microservices types and needs high scalability (it needs to be able to create many instances per service and balance those services across many hosts) means a high degree of deployment complexity for IT operations and management.</span></span> <span data-ttu-id="a5abf-210">如果你不使用面向微服务的基础结构 （如 orchestrator 和计划程序），其他的复杂性可能需要比业务应用程序本身的更多的开发工作。</span><span class="sxs-lookup"><span data-stu-id="a5abf-210">If you are not using a microservice-oriented infrastructure (like an orchestrator and scheduler), that additional complexity can require far more development efforts than the business application itself.</span></span>

<span data-ttu-id="a5abf-211">**原子事务**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-211">**Atomic transactions**.</span></span> <span data-ttu-id="a5abf-212">通常多个微服务之间的原子事务中不可能。</span><span class="sxs-lookup"><span data-stu-id="a5abf-212">Atomic transactions between multiple microservices usually are not possible.</span></span> <span data-ttu-id="a5abf-213">业务要求需要采用多个微服务之间的最终一致性。</span><span class="sxs-lookup"><span data-stu-id="a5abf-213">The business requirements have to embrace eventual consistency between multiple microservices.</span></span>

<span data-ttu-id="a5abf-214">**增加全局资源需求**（总内存、 驱动器和网络资源的所有服务器或主机）。</span><span class="sxs-lookup"><span data-stu-id="a5abf-214">**Increased global resource needs** (total memory, drives, and network resources for all the servers or hosts).</span></span> <span data-ttu-id="a5abf-215">在许多情况下，使用微服务方法时，将整体应用程序时所需的基于微服务构成的新应用程序的全局资源量将大于原始的整体应用程序的基础结构需求。</span><span class="sxs-lookup"><span data-stu-id="a5abf-215">In many cases, when you replace a monolithic application with a microservices approach, the amount of global resources needed by the new microservice-based application will be larger than the infrastructure needs of the original monolithic application.</span></span> <span data-ttu-id="a5abf-216">这是因为更高程度的粒度和分布式的服务需要更具有全局性占用的资源。</span><span class="sxs-lookup"><span data-stu-id="a5abf-216">This is because the higher degree of granularity and distributed services requires more global resources.</span></span> <span data-ttu-id="a5abf-217">资源的增加的使用给定低成本的常规和一个优势是能够扩大相比长期成本时不断演变的整体应用程序的应用程序只是某些区域中的资源，但是，是通常为一个很好权衡大，长期的应用程序。</span><span class="sxs-lookup"><span data-stu-id="a5abf-217">However, given the low cost of resources in general and the benefit of being able to scale out just certain areas of the application compared to long-term costs when evolving monolithic applications, the increased use of resources is usually a good tradeoff for large, long-term applications.</span></span>

<span data-ttu-id="a5abf-218">**直接 client‑to‑microservice 通信问题**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-218">**Issues with direct client‑to‑microservice communication**.</span></span> <span data-ttu-id="a5abf-219">大型，使用数十个微服务应用程序时，有挑战和限制如果应用程序要求直接微服务构成客户端通信。</span><span class="sxs-lookup"><span data-stu-id="a5abf-219">When the application is large, with dozens of microservices, there are challenges and limitations if the application requires direct client-to-microservice communications.</span></span> <span data-ttu-id="a5abf-220">一个问题是客户端的需求和每个微服务公开的 Api 的潜在不匹配。</span><span class="sxs-lookup"><span data-stu-id="a5abf-220">One problem is a potential mismatch between the needs of the client and the APIs exposed by each of the microservices.</span></span> <span data-ttu-id="a5abf-221">在某些情况下，客户端应用程序可能需要进行许多单独的请求，以构成的用户界面，这会通过 Internet 效率低下，并将对移动网络不切实际。</span><span class="sxs-lookup"><span data-stu-id="a5abf-221">In certain cases, the client application might need to make many separate requests to compose the UI, which can be inefficient over the Internet and would be impractical over a mobile network.</span></span> <span data-ttu-id="a5abf-222">因此，客户端应用程序中对后端系统的请求应将最小化。</span><span class="sxs-lookup"><span data-stu-id="a5abf-222">Therefore, requests from the client application to the back-end system should be minimized.</span></span>

<span data-ttu-id="a5abf-223">与直接微服务构成客户端通信的另一个问题是某些微服务可能正在使用不是 Web 友好的协议。</span><span class="sxs-lookup"><span data-stu-id="a5abf-223">Another problem with direct client-to-microservice communications is that some microservices might be using protocols that are not Web-friendly.</span></span> <span data-ttu-id="a5abf-224">一个服务可能使用的二进制协议，而另一个服务可能使用 AMQP 消息。</span><span class="sxs-lookup"><span data-stu-id="a5abf-224">One service might use a binary protocol, while another service might use AMQP messaging.</span></span> <span data-ttu-id="a5abf-225">这些协议不是 firewall‑friendly，最好在内部使用。</span><span class="sxs-lookup"><span data-stu-id="a5abf-225">Those protocols are not firewall‑friendly and are best used internally.</span></span> <span data-ttu-id="a5abf-226">通常情况下，应用程序应使用在防火墙外的通信协议，如 HTTP 和 Websocket。</span><span class="sxs-lookup"><span data-stu-id="a5abf-226">Usually, an application should use protocols such as HTTP and WebSockets for communication outside of the firewall.</span></span>

<span data-ttu-id="a5abf-227">尚未使用此直接 client‑to‑service 方法的另一个缺点是，它使得难以重构这些微服务的协定。</span><span class="sxs-lookup"><span data-stu-id="a5abf-227">Yet another drawback with this direct client‑to‑service approach is that it makes it difficult to refactor the contracts for those microservices.</span></span> <span data-ttu-id="a5abf-228">随着时间的推移开发人员可能想要更改系统分区到服务的方式。</span><span class="sxs-lookup"><span data-stu-id="a5abf-228">Over time developers might want to change how the system is partitioned into services.</span></span> <span data-ttu-id="a5abf-229">例如，它们可能会合并两个服务或拆分为两个或多个服务的服务。</span><span class="sxs-lookup"><span data-stu-id="a5abf-229">For example, they might merge two services or split a service into two or more services.</span></span> <span data-ttu-id="a5abf-230">但是，如果客户端直接与服务进行通信，则执行这种重构可以中断与客户端应用程序兼容性。</span><span class="sxs-lookup"><span data-stu-id="a5abf-230">However, if clients communicate directly with the services, performing this kind of refactoring can break compatibility with client apps.</span></span>

<span data-ttu-id="a5abf-231">中所述的体系结构部分，在设计和构建复杂的应用程序基于微服务时，你可以考虑使用多个的细化 API 网关而不是更简单的直接 client‑to‑microservice 通信方法。</span><span class="sxs-lookup"><span data-stu-id="a5abf-231">As mentioned in the architecture section, when designing and building a complex application based on microservices, you might consider the use of multiple fine-grained API Gateways instead of the simpler direct client‑to‑microservice communication approach.</span></span>

<span data-ttu-id="a5abf-232">**分区微服务**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-232">**Partitioning the microservices**.</span></span> <span data-ttu-id="a5abf-233">最后，无论微服务体系结构采用哪种方法，另一个难题确定如何分区到多个微服务端到端应用程序。</span><span class="sxs-lookup"><span data-stu-id="a5abf-233">Finally, no matter which approach you take for your microservice architecture, another challenge is deciding how to partition an end-to-end application into multiple microservices.</span></span> <span data-ttu-id="a5abf-234">如本指南的体系结构部分中所述，有几种技术和您可以采取的方法。</span><span class="sxs-lookup"><span data-stu-id="a5abf-234">As noted in the architecture section of the guide, there are several techniques and approaches you can take.</span></span> <span data-ttu-id="a5abf-235">基本上，你需要识别的区域的应用程序从其他区域分隔和具有硬依赖项的数量较少。</span><span class="sxs-lookup"><span data-stu-id="a5abf-235">Basically, you need to identify areas of the application that are decoupled from the other areas and that have a low number of hard dependencies.</span></span> <span data-ttu-id="a5abf-236">在许多情况下，这是用例通过到服务分区对齐的。</span><span class="sxs-lookup"><span data-stu-id="a5abf-236">In many cases, this is aligned to partitioning services by use case.</span></span> <span data-ttu-id="a5abf-237">例如，在我们电子商店的应用程序，我们具有一排序的服务，它负责与订单过程相关的所有业务逻辑。</span><span class="sxs-lookup"><span data-stu-id="a5abf-237">For example, in our e-shop application, we have an ordering service that is responsible for all the business logic related to the order process.</span></span> <span data-ttu-id="a5abf-238">我们还提供目录服务和购物篮服务实现其他功能。</span><span class="sxs-lookup"><span data-stu-id="a5abf-238">We also have the catalog service and the basket service that implement other capabilities.</span></span> <span data-ttu-id="a5abf-239">理想情况下，每个服务应具有仅职责一小部分。</span><span class="sxs-lookup"><span data-stu-id="a5abf-239">Ideally, each service should have only a small set of responsibilities.</span></span> <span data-ttu-id="a5abf-240">这是类似于单独责任原则 (SRP) 应用于类，以指出，一个类只能有一个确实需要更改。</span><span class="sxs-lookup"><span data-stu-id="a5abf-240">This is similar to the single responsibility principle (SRP) applied to classes, which states that a class should only have one reason to change.</span></span> <span data-ttu-id="a5abf-241">但在这种情况下，它是有关微服务，因此该作用域将是大于单个类。</span><span class="sxs-lookup"><span data-stu-id="a5abf-241">But in this case, it is about microservices, so the scope will be larger than a single class.</span></span> <span data-ttu-id="a5abf-242">最重要的是，微服务必须是完全自治、 端到端，包括负责其自己的数据源。</span><span class="sxs-lookup"><span data-stu-id="a5abf-242">Most of all, a microservice has to be completely autonomous, end to end, including responsibility for its own data sources.</span></span>

## <a name="external-versus-internal-architecture-and-design-patterns"></a><span data-ttu-id="a5abf-243">与内部体系结构和设计模式的外部</span><span class="sxs-lookup"><span data-stu-id="a5abf-243">External versus internal architecture and design patterns</span></span>

<span data-ttu-id="a5abf-244">外部体系结构是由多个服务，按照本指南的体系结构部分所述的原则的微服务体系结构。</span><span class="sxs-lookup"><span data-stu-id="a5abf-244">The external architecture is the microservice architecture composed by multiple service, following the principles described in the architecture section of this guide.</span></span> <span data-ttu-id="a5abf-245">但是，根据每个微服务，并独立于你选择的高级微服务体系结构的性质，它很常见，并且有时最好具有不同的内部体系结构，每种为基于不同的模式，不同微服务。</span><span class="sxs-lookup"><span data-stu-id="a5abf-245">However, depending on the nature of each microservice, and independently of high-level microservice architecture you choose, it is common and sometimes advisable to have different internal architectures, each based on different patterns, for different microservices.</span></span> <span data-ttu-id="a5abf-246">微服务甚至可以使用不同的技术和编程语言。</span><span class="sxs-lookup"><span data-stu-id="a5abf-246">The microservices can even use different technologies and programming languages.</span></span> <span data-ttu-id="a5abf-247">图 8-2 演示了这种多样性。</span><span class="sxs-lookup"><span data-stu-id="a5abf-247">Figure 8-2 illustrates this diversity.</span></span>

![](./media/image2.png)

<span data-ttu-id="a5abf-248">**图 8-2**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-248">**Figure 8-2**.</span></span> <span data-ttu-id="a5abf-249">外部与内部体系结构和设计</span><span class="sxs-lookup"><span data-stu-id="a5abf-249">External versus internal architecture and design</span></span>

<span data-ttu-id="a5abf-250">例如，在我们*eShopOnContainers*示例中，目录、 购物篮和用户配置文件微服务是简单 （基本上，CRUD 子系统）。</span><span class="sxs-lookup"><span data-stu-id="a5abf-250">For instance, in our *eShopOnContainers* sample, the catalog, basket, and user profile microservices are simple (basically, CRUD subsystems).</span></span> <span data-ttu-id="a5abf-251">因此，其内部体系结构和设计非常简单。</span><span class="sxs-lookup"><span data-stu-id="a5abf-251">Therefore, their internal architecture and design is straightforward.</span></span> <span data-ttu-id="a5abf-252">但是，你可能必须其他微服务，如排序 microservice，这是更复杂，并且与域复杂性度很高表示不断变化的业务规则。</span><span class="sxs-lookup"><span data-stu-id="a5abf-252">However, you might have other microservices, such as the ordering microservice, which is more complex and represents ever-changing business rules with a high degree of domain complexity.</span></span> <span data-ttu-id="a5abf-253">在类似这样的情况下，你可能想要实现更高级的模式中特定的微服务，通过域驱动设计 (DDD) 方法定义为我们在中做的一样*eShopOnContainers*排序微服务。</span><span class="sxs-lookup"><span data-stu-id="a5abf-253">In cases like these, you might want to implement more advanced patterns within a particular microservice, like the ones defined with domain-driven design (DDD) approaches, as we are doing in the *eShopOnContainers* ordering microservice.</span></span> <span data-ttu-id="a5abf-254">(我们将查看更高版本的实现进行说明这部分中的这些 DDD 模式*eShopOnContainers*排序微服务。)</span><span class="sxs-lookup"><span data-stu-id="a5abf-254">(We will review these DDD patterns in the section later that explains the implementation of the *eShopOnContainers* ordering microservice.)</span></span>

<span data-ttu-id="a5abf-255">对于每个微服务使用的不同技术的另一个原因可能是每个微服务的性质。</span><span class="sxs-lookup"><span data-stu-id="a5abf-255">Another reason for a different technology per microservice might be the nature of each microservice.</span></span> <span data-ttu-id="a5abf-256">例如，它可能是更好的做法使用功能的编程语言，如 F\#，或者如果你正面向 AI 和机器学习域，而不是更加面向对象的编程语言 C 等甚至如 R 语言\#。</span><span class="sxs-lookup"><span data-stu-id="a5abf-256">For example, it might be better to use a functional programming language like F\#, or even a language like R if you are targeting AI and machine learning domains, instead of a more object-oriented programming language like C\#.</span></span>

<span data-ttu-id="a5abf-257">底部行是每个微服务可以有不同的内部体系结构，能根据不同的设计模式。</span><span class="sxs-lookup"><span data-stu-id="a5abf-257">The bottom line is that each microservice can have a different internal architecture based on different design patterns.</span></span> <span data-ttu-id="a5abf-258">并非所有微服务应使用来实现高级的 DDD 模式，因为，将会过度工程它们。</span><span class="sxs-lookup"><span data-stu-id="a5abf-258">Not all microservices should be implemented using advanced DDD patterns, because that would be over-engineering them.</span></span> <span data-ttu-id="a5abf-259">同样，不应作为 CRUD 组件实现包含不断变化的业务逻辑的复杂微服务或您可以得到质量较低的代码。</span><span class="sxs-lookup"><span data-stu-id="a5abf-259">Similarly, complex microservices with ever-changing business logic should not be implemented as CRUD components, or you can end up with low-quality code.</span></span>



## <a name="the-new-world-multiple-architectural-patterns-and-polyglot-microservices"></a><span data-ttu-id="a5abf-260">新体系： 多个体系结构模式和 polyglot 微服务</span><span class="sxs-lookup"><span data-stu-id="a5abf-260">The new world: multiple architectural patterns and polyglot microservices</span></span>

<span data-ttu-id="a5abf-261">有许多软件架构师和开发人员使用的体系结构模式。</span><span class="sxs-lookup"><span data-stu-id="a5abf-261">There are many architectural patterns used by software architects and developers.</span></span> <span data-ttu-id="a5abf-262">以下是一些 （即混合体系结构样式和体系结构模式）：</span><span class="sxs-lookup"><span data-stu-id="a5abf-262">The following are a few (mixing architecture styles and architecture patterns):</span></span>

-   <span data-ttu-id="a5abf-263">简单 CRUD，单层，单层。</span><span class="sxs-lookup"><span data-stu-id="a5abf-263">Simple CRUD, single-tier, single-layer.</span></span>

-   <span data-ttu-id="a5abf-264">[传统 N 分层](https://msdn.microsoft.com/en-us/library/ee658109.aspx#Layers)。</span><span class="sxs-lookup"><span data-stu-id="a5abf-264">[Traditional N-Layered](https://msdn.microsoft.com/en-us/library/ee658109.aspx#Layers).</span></span>

-   <span data-ttu-id="a5abf-265">[域驱动设计 N 分层](https://blogs.msdn.microsoft.com/cesardelatorre/2011/07/03/published-first-alpha-version-of-domain-oriented-n-layered-architecture-v2-0/)。</span><span class="sxs-lookup"><span data-stu-id="a5abf-265">[Domain-Driven Design N-layered](https://blogs.msdn.microsoft.com/cesardelatorre/2011/07/03/published-first-alpha-version-of-domain-oriented-n-layered-architecture-v2-0/).</span></span>

-   <span data-ttu-id="a5abf-266">[清理体系结构](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)(如用于[eShopOnWeb](http://aka.ms/WebAppArchitecture))</span><span class="sxs-lookup"><span data-stu-id="a5abf-266">[Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) (as used with [eShopOnWeb](http://aka.ms/WebAppArchitecture))</span></span>

-   <span data-ttu-id="a5abf-267">[命令和查询责任分离](https://martinfowler.com/bliki/CQRS.html)(CQRS)。</span><span class="sxs-lookup"><span data-stu-id="a5abf-267">[Command and Query Responsibility Segregation](https://martinfowler.com/bliki/CQRS.html) (CQRS).</span></span>

-   <span data-ttu-id="a5abf-268">[事件驱动的体系结构](https://en.wikipedia.org/wiki/Event-driven_architecture)(EDA)。</span><span class="sxs-lookup"><span data-stu-id="a5abf-268">[Event-Driven Architecture](https://en.wikipedia.org/wiki/Event-driven_architecture) (EDA).</span></span>

<span data-ttu-id="a5abf-269">你也可以生成与许多技术和语言，如 ASP.NET 核心 Web Api、 NancyFx、 ASP.NET 核心 SignalR （适用于.NET 核心 2）、 F 的微服务\#，Node.js、 Python、 Java、 c + +、 GoLang，和的详细信息。</span><span class="sxs-lookup"><span data-stu-id="a5abf-269">You can also build microservices with many technologies and languages, such as ASP.NET Core Web APIs, NancyFx, ASP.NET Core SignalR (available with .NET Core 2), F\#, Node.js, Python, Java, C++, GoLang, and more.</span></span>

<span data-ttu-id="a5abf-270">重要的一点是任何特定的体系结构模式或样式，也不任何特定的技术，最适合所有情况。</span><span class="sxs-lookup"><span data-stu-id="a5abf-270">The important point is that no particular architecture pattern or style, nor any particular technology, is right for all situations.</span></span> <span data-ttu-id="a5abf-271">图 8-3 显示了一些方法和技术 （尽管不是在任何特定的顺序），无法在不同的微服务中使用。</span><span class="sxs-lookup"><span data-stu-id="a5abf-271">Figure 8-3 shows some approaches and technologies (although not in any particular order) that could be used in different microservices.</span></span>

![](./media/image3.png)

<span data-ttu-id="a5abf-272">**图 8-3**。</span><span class="sxs-lookup"><span data-stu-id="a5abf-272">**Figure 8-3**.</span></span> <span data-ttu-id="a5abf-273">多体系结构模式和 polyglot 微服务世界</span><span class="sxs-lookup"><span data-stu-id="a5abf-273">Multi-architectural patterns and the polyglot microservices world</span></span>

<span data-ttu-id="a5abf-274">中所示图 8-3，应用程序中许多微服务组成 （绑定上下文中在域驱动设计术语中或只需"子系统"作为自治微服务），您可能会以不同的方式实现每个微服务。</span><span class="sxs-lookup"><span data-stu-id="a5abf-274">As shown in Figure 8-3, in applications composed of many microservices (Bounded Contexts in domain-driven design terminology, or simply “subsystems” as autonomous microservices), you might implement each microservice in a different way.</span></span> <span data-ttu-id="a5abf-275">每个可能具有不同的体系结构模式，并使用不同的语言和具体取决于应用程序的性质、 业务需求和优先级的数据库。</span><span class="sxs-lookup"><span data-stu-id="a5abf-275">Each might have a different architecture pattern and use different languages and databases depending on the application’s nature, business requirements, and priorities.</span></span> <span data-ttu-id="a5abf-276">在某些情况下可能是相似的微服务。</span><span class="sxs-lookup"><span data-stu-id="a5abf-276">In some cases the microservices might be similar.</span></span> <span data-ttu-id="a5abf-277">但这不是通常情况下，因为每个子系统的上下文边界和要求通常不同。</span><span class="sxs-lookup"><span data-stu-id="a5abf-277">But that is not usually the case, because each subsystem’s context boundary and requirements are usually different.</span></span>

<span data-ttu-id="a5abf-278">例如，对于简单 CRUD 维护应用程序，它可能毫无意义设计和实现 DDD 模式。</span><span class="sxs-lookup"><span data-stu-id="a5abf-278">For instance, for a simple CRUD maintenance application, it might not make sense to design and implement DDD patterns.</span></span> <span data-ttu-id="a5abf-279">但核心域或核心业务，你可能需要应用更高级的模式为处理独特业务的不断变化的业务规则的复杂性。</span><span class="sxs-lookup"><span data-stu-id="a5abf-279">But for your core domain or core business, you might need to apply more advanced patterns to tackle business complexity with ever-changing business rules.</span></span>

<span data-ttu-id="a5abf-280">尤其是当你处理大型应用程序由多个子系统，不应该应用基于单个体系结构模式同一个顶级体系结构。</span><span class="sxs-lookup"><span data-stu-id="a5abf-280">Especially when you deal with large applications composed by multiple sub-systems, you should not apply a single top-level architecture based on a single architecture pattern.</span></span> <span data-ttu-id="a5abf-281">例如，CQRS 不应作为整个应用程序的顶级结构应用，但可能适用于一组特定的服务。</span><span class="sxs-lookup"><span data-stu-id="a5abf-281">For instance, CQRS should not be applied as a top-level architecture for a whole application, but might be useful for a specific set of services.</span></span>

<span data-ttu-id="a5abf-282">没有任何银级的项目符号或每个给定的用例的正确的体系结构模式。</span><span class="sxs-lookup"><span data-stu-id="a5abf-282">There is no silver bullet or a right architecture pattern for every given case.</span></span> <span data-ttu-id="a5abf-283">不能有"一个体系结构模式规则其全部。"</span><span class="sxs-lookup"><span data-stu-id="a5abf-283">You cannot have “one architecture pattern to rule them all.”</span></span> <span data-ttu-id="a5abf-284">具体取决于每个微服务构成的优先级，必须选择不同的方法对于每个，如以下各节中所述。</span><span class="sxs-lookup"><span data-stu-id="a5abf-284">Depending on the priorities of each microservice, you must choose a different approach for each, as explained in the following sections.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="a5abf-285">[以前](index.md) [下一步] (数据-驱动的 crud-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="a5abf-285">[Previous] (index.md) [Next] (data-driven-crud-microservice.md)</span></span>
