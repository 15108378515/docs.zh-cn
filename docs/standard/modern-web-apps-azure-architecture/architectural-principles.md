---
title: "体系结构原则"
description: "设计使用 ASP.NET Core 和 Azure 的现代 Web 应用程序 |体系结构原则"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: 20524c8aa0e64fd40a1a4a6811063557f74074d2
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2017
---
#<a name="architectural-principles"></a><span data-ttu-id="69db5-103">体系结构原则</span><span class="sxs-lookup"><span data-stu-id="69db5-103">Architectural Principles</span></span>

> <span data-ttu-id="69db5-104">"如果生成器生成建筑物方式程序员编写程序，然后应运而生第一个 woodpecker 将销毁文明。"</span><span class="sxs-lookup"><span data-stu-id="69db5-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="69db5-105">_\-Gerald Weinberg_</span><span class="sxs-lookup"><span data-stu-id="69db5-105">_\- Gerald Weinberg_</span></span>

## <a name="summary"></a><span data-ttu-id="69db5-106">摘要</span><span class="sxs-lookup"><span data-stu-id="69db5-106">Summary</span></span>

<span data-ttu-id="69db5-107">应设计并设计软件解决方案通过记住可维护性。</span><span class="sxs-lookup"><span data-stu-id="69db5-107">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="69db5-108">本部分中概述的原则可帮助指导您向将导致干净、 可维护性应用程序的体系结构决策。</span><span class="sxs-lookup"><span data-stu-id="69db5-108">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="69db5-109">通常情况下，这些原则将指导你向生成传出离散组件到应用程序的其他部分不紧密耦合但而是通过显式接口通信的应用程序或消息传送系统。</span><span class="sxs-lookup"><span data-stu-id="69db5-109">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="69db5-110">常见的设计原则</span><span class="sxs-lookup"><span data-stu-id="69db5-110">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="69db5-111">分离问题</span><span class="sxs-lookup"><span data-stu-id="69db5-111">Separation of Concerns</span></span>

<span data-ttu-id="69db5-112">在开发时的指导原则是**问题分离**。</span><span class="sxs-lookup"><span data-stu-id="69db5-112">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="69db5-113">这一原则断言应该分隔软件基于它所执行的工作的类型。</span><span class="sxs-lookup"><span data-stu-id="69db5-113">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="69db5-114">例如，假设一个应用程序，包括用于标识要显示给用户，值得注意项的逻辑和该格式以特定的方式，以使它们更明显的此类项。</span><span class="sxs-lookup"><span data-stu-id="69db5-114">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="69db5-115">负责选择要设置格式的项的行为应保持独立于负责项，因为这些是仅而巧合的是与另一个相关的任务分离进行格式设置的行为。</span><span class="sxs-lookup"><span data-stu-id="69db5-115">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="69db5-116">体系结构上，可以以逻辑方式构建应用程序通过将从基础结构和用户界面逻辑中分离核心业务行为遵循这一原则。</span><span class="sxs-lookup"><span data-stu-id="69db5-116">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="69db5-117">理想情况下，业务规则和逻辑应驻留在一个单独的项目，不应依赖于应用程序中其他项目。</span><span class="sxs-lookup"><span data-stu-id="69db5-117">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="69db5-118">这有助于确保业务模型易于测试和可以演化而不进行紧密耦合到低级别的实现详细信息。</span><span class="sxs-lookup"><span data-stu-id="69db5-118">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="69db5-119">分离问题是应用程序体系结构中的层后面使用一个关键考虑事项。</span><span class="sxs-lookup"><span data-stu-id="69db5-119">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="69db5-120">封装</span><span class="sxs-lookup"><span data-stu-id="69db5-120">Encapsulation</span></span>

<span data-ttu-id="69db5-121">应使用的应用程序的不同部分**封装**要使其从应用程序的其他部分。</span><span class="sxs-lookup"><span data-stu-id="69db5-121">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="69db5-122">应用程序组件和层应能够调整其内部实现，而不会破坏其协作者，只要不违反外部的协定。</span><span class="sxs-lookup"><span data-stu-id="69db5-122">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="69db5-123">封装的正确使用有助于实现松散耦合和在应用程序设计中，模块性，因为处理程序，但前提是保留相同的接口可以使用备用实现替换对象和包。</span><span class="sxs-lookup"><span data-stu-id="69db5-123">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="69db5-124">在类中，封装被通过外部对类的内部状态的访问限制。</span><span class="sxs-lookup"><span data-stu-id="69db5-124">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="69db5-125">如果外部参与者想要操作的对象的状态，它应这样做通过明确定义的函数 （或属性 setter），而不是使直接访问的对象的私有状态。</span><span class="sxs-lookup"><span data-stu-id="69db5-125">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="69db5-126">同样，应用程序组件和应用程序本身应公开对其使用，而非是允许直接修改其状态的协作者定义完善的接口。</span><span class="sxs-lookup"><span data-stu-id="69db5-126">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="69db5-127">这会释放应用程序的内部设计的发展方式，随着时间的推移而不必担心，这样做因此将中断协作者，处理程序，但前提保留的公共协定。</span><span class="sxs-lookup"><span data-stu-id="69db5-127">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="69db5-128">依赖项反转</span><span class="sxs-lookup"><span data-stu-id="69db5-128">Dependency Inversion</span></span>

<span data-ttu-id="69db5-129">应用程序中的依赖项的方向应为抽象，不实现详细信息的方向。</span><span class="sxs-lookup"><span data-stu-id="69db5-129">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="69db5-130">大多数应用程序的编写以便编译时依赖项的运行时执行方向流动。</span><span class="sxs-lookup"><span data-stu-id="69db5-130">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="69db5-131">这将产生直接的依赖项关系图。</span><span class="sxs-lookup"><span data-stu-id="69db5-131">This produces a direct dependency graph.</span></span> <span data-ttu-id="69db5-132">也就是说，如果模块 A 调用 B，模块中的函数调用的函数在模块 C，然后在编译时间 A 将取决于 B 将依赖于 C，在图 4-1 中所示。</span><span class="sxs-lookup"><span data-stu-id="69db5-132">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B which will depend on C, as shown in Figure 4-1.</span></span>

![](./media/image4-1.png)

<span data-ttu-id="69db5-133">**图 4-1。**</span><span class="sxs-lookup"><span data-stu-id="69db5-133">**Figure 4-1.**</span></span> <span data-ttu-id="69db5-134">直接的依赖项关系图。</span><span class="sxs-lookup"><span data-stu-id="69db5-134">Direct dependency graph.</span></span>

<span data-ttu-id="69db5-135">应用的依赖项反向原则允许 A 调用 B 实现时，调用 B，在运行时，使它可以 a 的抽象方法，但的 B 依赖于接口控制由 A 在编译时 (因此，*反转*典型编译时依赖项）。</span><span class="sxs-lookup"><span data-stu-id="69db5-135">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="69db5-136">在运行时，控制程序执行流程保持不变，但接口简介意味着可以轻松插入这些接口的不同实施。</span><span class="sxs-lookup"><span data-stu-id="69db5-136">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![](./media/image4-2.png)

<span data-ttu-id="69db5-137">**图 4-2。**</span><span class="sxs-lookup"><span data-stu-id="69db5-137">**Figure 4-2.**</span></span> <span data-ttu-id="69db5-138">倒依赖项关系图。</span><span class="sxs-lookup"><span data-stu-id="69db5-138">Inverted dependency graph.</span></span>

<span data-ttu-id="69db5-139">**依赖项反向**是生成松散耦合的应用程序，因为可以编写实现详细信息为依赖于并实现更高级别的抽象，而不是另一种方法解决的关键部分。</span><span class="sxs-lookup"><span data-stu-id="69db5-139">**Dependency inversion** is a key part of building loosely-coupled applications, since implementation details can be written to depend on and implement higher level abstractions, rather than the other way around.</span></span> <span data-ttu-id="69db5-140">生成的应用程序作为结果是更可测试、 模块化和可维护性。</span><span class="sxs-lookup"><span data-stu-id="69db5-140">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="69db5-141">这一做法*依赖关系注入*可按照依赖反向原则。</span><span class="sxs-lookup"><span data-stu-id="69db5-141">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="69db5-142">显式依赖关系</span><span class="sxs-lookup"><span data-stu-id="69db5-142">Explicit Dependencies</span></span>

<span data-ttu-id="69db5-143">**方法和类应显式要求才能正常工作所需的任何协作对象。**</span><span class="sxs-lookup"><span data-stu-id="69db5-143">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="69db5-144">类构造函数提供类以确定为了处于有效状态，然后才能正常工作所需的内容有机会。</span><span class="sxs-lookup"><span data-stu-id="69db5-144">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="69db5-145">如果你定义的类，可以构造和调用，但这将仅正常工作如果某些全局或基础结构组件均已到位，这些类正在*恶意*与其客户端。</span><span class="sxs-lookup"><span data-stu-id="69db5-145">If you define classes that can be constructed and called, but which will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="69db5-146">构造函数协定将告诉客户端，但然后在它变为出对象的运行时指定的内容 (可能为 nothing 如果类仅使用默认构造函数)，只需要真正未需要其他内容。</span><span class="sxs-lookup"><span data-stu-id="69db5-146">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a default constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="69db5-147">按照显式依赖关系原则，正在诚实有关它们才能正常需要与其客户端类和方法。</span><span class="sxs-lookup"><span data-stu-id="69db5-147">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="69db5-148">这使得自行详细记录你的代码和代码协定更加友好的用户，因为用户将逐渐信任，只要它们提供哪些必需的形式的方法或构造函数参数，它们正在使用的对象的行为正确在运行时。</span><span class="sxs-lookup"><span data-stu-id="69db5-148">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="69db5-149">单独责任</span><span class="sxs-lookup"><span data-stu-id="69db5-149">Single Responsibility</span></span>

<span data-ttu-id="69db5-150">单独责任原则适用于面向对象的设计，但也可以将其视为类似于关注点分离一个体系结构原则。</span><span class="sxs-lookup"><span data-stu-id="69db5-150">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="69db5-151">它指出对象应具有只有一个责任并且也应只有一个确实需要更改。</span><span class="sxs-lookup"><span data-stu-id="69db5-151">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="69db5-152">具体而言，应在其中更改对象的唯一情况是如果必须更新中将执行一个责任的方式。</span><span class="sxs-lookup"><span data-stu-id="69db5-152">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="69db5-153">按照这一原则松散耦合的有助于生成更和模块化系统，因为许多类型的新行为可以实现新类，而不是通过将添加到现有类的其他责任。</span><span class="sxs-lookup"><span data-stu-id="69db5-153">Following this principle helps to produce more loosely-coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="69db5-154">添加新类始终是比因为任何代码更改现有类，更安全，但取决于新的类。</span><span class="sxs-lookup"><span data-stu-id="69db5-154">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="69db5-155">在整体应用程序中，我们可以将单独责任原则在高级别应用于应用程序中的层。</span><span class="sxs-lookup"><span data-stu-id="69db5-155">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="69db5-156">演示文稿责任应保留在 UI 项目，而数据访问责任应保留在基础结构项目内。</span><span class="sxs-lookup"><span data-stu-id="69db5-156">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="69db5-157">业务逻辑应保持在应用程序核心项目中，它可以轻松地测试并可以从其他职责独立地变化。</span><span class="sxs-lookup"><span data-stu-id="69db5-157">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="69db5-158">当这一原则应用于应用程序体系结构，并转到其逻辑的终结点时，可以微服务。</span><span class="sxs-lookup"><span data-stu-id="69db5-158">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="69db5-159">给定的微服务应具有单独的责任。</span><span class="sxs-lookup"><span data-stu-id="69db5-159">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="69db5-160">如果你需要扩展系统的行为，则通常最好执行此操作通过添加其他微服务，而不是添加到现有的责任。</span><span class="sxs-lookup"><span data-stu-id="69db5-160">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="69db5-161">了解有关微服务体系结构的详细信息</span><span class="sxs-lookup"><span data-stu-id="69db5-161">Learn more about microservices architecture</span></span>](http://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="69db5-162">切勿重复 （干）</span><span class="sxs-lookup"><span data-stu-id="69db5-162">Don't Repeat Yourself (DRY)</span></span>

<span data-ttu-id="69db5-163">应用程序应避免指定与多个位置中的特定概念相关，因为这是错误的根源，频繁的行为。</span><span class="sxs-lookup"><span data-stu-id="69db5-163">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="69db5-164">在某些时候中要求, 的更改将需要更改此行为和可能性行为该至少一个实例将无法更新将导致不一致的行为的系统。</span><span class="sxs-lookup"><span data-stu-id="69db5-164">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="69db5-165">而不会复制逻辑，请将它封装编程构造中。</span><span class="sxs-lookup"><span data-stu-id="69db5-165">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="69db5-166">使此构建单个颁发机构对此行为，并将任何其他部分的应用程序需要此现象，请使用新的构造。</span><span class="sxs-lookup"><span data-stu-id="69db5-166">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="69db5-167">避免将绑定在一起才而巧合的是重复的行为。</span><span class="sxs-lookup"><span data-stu-id="69db5-167">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="69db5-168">例如，只是因为两个不同的常数这两个具有相同的值，，并不意味着应将只有一个量，如果从概念上讲指不同的情况。</span><span class="sxs-lookup"><span data-stu-id="69db5-168">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="69db5-169">持久性无感知</span><span class="sxs-lookup"><span data-stu-id="69db5-169">Persistence Ignorance</span></span>

<span data-ttu-id="69db5-170">**持久性无感知**(PI) 是指的类型需要保持不变，但其代码不受持久性技术的选择。</span><span class="sxs-lookup"><span data-stu-id="69db5-170">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="69db5-171">.NET 中的此类类型是有时称为普通旧 CLR 对象 (POCOs)，因为它们不需要从特定的基类继承或实现特定接口。</span><span class="sxs-lookup"><span data-stu-id="69db5-171">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="69db5-172">持久性无感知很有用，因为它允许相同的业务模型，采用多种方式，提供更多灵活性，应用程序保留。</span><span class="sxs-lookup"><span data-stu-id="69db5-172">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="69db5-173">持久性选项可能会更改段时间后，从到另一个数据库技术或其他形式的持久性可能需要除了应用程序与启动的任何内容 (例如，使用 Redis 缓存或 Azure DocumentDb 除了关系数据库）。</span><span class="sxs-lookup"><span data-stu-id="69db5-173">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure DocumentDb in addition to a relational database).</span></span>

<span data-ttu-id="69db5-174">这一原则冲突的一些示例包括：</span><span class="sxs-lookup"><span data-stu-id="69db5-174">Some examples of violations of this principle include:</span></span>

-   <span data-ttu-id="69db5-175">所需的基类</span><span class="sxs-lookup"><span data-stu-id="69db5-175">A required base class</span></span>

-   <span data-ttu-id="69db5-176">所需的接口实现</span><span class="sxs-lookup"><span data-stu-id="69db5-176">A required interface implementation</span></span>

-   <span data-ttu-id="69db5-177">类负责保存本身 （例如活动的记录模式中）</span><span class="sxs-lookup"><span data-stu-id="69db5-177">Classes responsible for saving themselves (such as the Active Record pattern)</span></span>

-   <span data-ttu-id="69db5-178">所需的默认构造函数</span><span class="sxs-lookup"><span data-stu-id="69db5-178">Required default constructor</span></span>

-   <span data-ttu-id="69db5-179">要求 virtual 关键字的属性</span><span class="sxs-lookup"><span data-stu-id="69db5-179">Properties requiring virtual keyword</span></span>

-   <span data-ttu-id="69db5-180">特定于持久性的必需的特性</span><span class="sxs-lookup"><span data-stu-id="69db5-180">Persistence-specific required attributes</span></span>

<span data-ttu-id="69db5-181">类具有上述功能或行为的任何要求将添加要保留的类型和所选的持久性技术，使它更难以进行将来采用新的数据访问策略之间的耦合。</span><span class="sxs-lookup"><span data-stu-id="69db5-181">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="69db5-182">绑定的上下文</span><span class="sxs-lookup"><span data-stu-id="69db5-182">Bounded Contexts</span></span>

<span data-ttu-id="69db5-183">**绑定上下文**是 Domain-Driven 设计中的中央模式。</span><span class="sxs-lookup"><span data-stu-id="69db5-183">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="69db5-184">它们通过将其分成单独概念模块提供了一种在大型应用程序或组织中的应对复杂性。</span><span class="sxs-lookup"><span data-stu-id="69db5-184">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="69db5-185">每个概念模块则表示分开其他上下文的上下文 （因此，划分边界），并可以独立地变化。</span><span class="sxs-lookup"><span data-stu-id="69db5-185">Each conceptual module then represents a context which is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="69db5-186">每个界限的上下文理想情况下应随意自己为选择的名称，其中的概念，并应具有其自己的永久性存储到的独占访问权限。</span><span class="sxs-lookup"><span data-stu-id="69db5-186">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="69db5-187">至少，单独的 web 应用程序应尽量可与自身的业务模式，而不与其他应用程序共享一个数据库自己持久性存储区他们自己界限的上下文。</span><span class="sxs-lookup"><span data-stu-id="69db5-187">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="69db5-188">通过编程接口，而不是允许的业务逻辑的共享数据库，则会发生界限上下文之间的通信和事件才能置于响应发生的更改。</span><span class="sxs-lookup"><span data-stu-id="69db5-188">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="69db5-189">限定上下文映射限定密切微服务，它还理想情况下其自己单独的绑定上下文作为实现。</span><span class="sxs-lookup"><span data-stu-id="69db5-189">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

> ### <a name="references--modern-web-applications"></a><span data-ttu-id="69db5-190">引用 – 现代 Web 应用程序</span><span class="sxs-lookup"><span data-stu-id="69db5-190">References – Modern Web Applications</span></span>
> - <span data-ttu-id="69db5-191">**分离问题**</span><span class="sxs-lookup"><span data-stu-id="69db5-191">**Separation of Concerns**</span></span>  
> <span data-ttu-id="69db5-192"><http://deviq.com/separation-of-concerns/></span><span class="sxs-lookup"><span data-stu-id="69db5-192"><http://deviq.com/separation-of-concerns/></span></span>
> - <span data-ttu-id="69db5-193">**封装** <http://deviq.com/encapsulation/></span><span class="sxs-lookup"><span data-stu-id="69db5-193">**Encapsulation** <http://deviq.com/encapsulation/></span></span>
> - <span data-ttu-id="69db5-194">**依赖项反向原则**</span><span class="sxs-lookup"><span data-stu-id="69db5-194">**Dependency Inversion Principle**</span></span>  
> <span data-ttu-id="69db5-195"><http://deviq.com/dependency-inversion-principle/></span><span class="sxs-lookup"><span data-stu-id="69db5-195"><http://deviq.com/dependency-inversion-principle/></span></span>
> - <span data-ttu-id="69db5-196">**显式依赖关系原则**</span><span class="sxs-lookup"><span data-stu-id="69db5-196">**Explicit Dependencies Principle**</span></span>  
> <span data-ttu-id="69db5-197"><http://deviq.com/explicit-dependencies-principle/></span><span class="sxs-lookup"><span data-stu-id="69db5-197"><http://deviq.com/explicit-dependencies-principle/></span></span>
> - <span data-ttu-id="69db5-198">**切勿重复**</span><span class="sxs-lookup"><span data-stu-id="69db5-198">**Don't Repeat Yourself**</span></span>  
> <span data-ttu-id="69db5-199"><http://deviq.com/don-t-repeat-yourself/></span><span class="sxs-lookup"><span data-stu-id="69db5-199"><http://deviq.com/don-t-repeat-yourself/></span></span>
> - <span data-ttu-id="69db5-200">**持久性无感知**</span><span class="sxs-lookup"><span data-stu-id="69db5-200">**Persistence Ignorance**</span></span>  
> <span data-ttu-id="69db5-201"><http://deviq.com/persistence-ignorance/></span><span class="sxs-lookup"><span data-stu-id="69db5-201"><http://deviq.com/persistence-ignorance/></span></span>
> - <span data-ttu-id="69db5-202">**界限的上下文**</span><span class="sxs-lookup"><span data-stu-id="69db5-202">**Bounded Context**</span></span>  
> <span data-ttu-id="69db5-203"><https://martinfowler.com/bliki/BoundedContext.html></span><span class="sxs-lookup"><span data-stu-id="69db5-203"><https://martinfowler.com/bliki/BoundedContext.html></span></span>

> [!div class="step-by-step"]
<span data-ttu-id="69db5-204">[以前](choose-between-traditional-web-and-single-page-apps.md) [下一步] (common-web-application-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="69db5-204">[Previous] (choose-between-traditional-web-and-single-page-apps.md) [Next] (common-web-application-architectures.md)</span></span>
