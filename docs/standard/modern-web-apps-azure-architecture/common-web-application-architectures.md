---
title: "常见的 web 应用程序体系结构"
description: "设计使用 ASP.NET 核心和 Microsoft Azure 的现代 web 应用程序 |常见的 web 应用程序体系结构"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: b6236cfab290211f930d6a1987075abeade4fd6d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2017
---
#<a name="common-web-application-architectures"></a>常见的 Web 应用程序体系结构

> "如果您认为良好的体系结构将占用大量资源，请尝试错误体系结构。"  
> _-Brian Foote 和 Joseph Yoder_

## <a name="summary"></a>摘要

大多数传统的.NET 应用程序作为单个单位对应于可执行文件或在单个 IIS 应用程序域内运行的单个 web 应用程序部署。 这是最简单的部署模型，并很好地提供很多内部和较小公共应用程序。 但是，即使给定部署此单个单元，最重要的业务应用程序受益于一些逻辑分离到多个层。

## <a name="what-is-a-monolithic-application"></a>整体应用程序是什么？

整体应用程序是指是完全独立的根据其行为。 它可能交互的方式与其他服务或数据的存储过程中执行其操作，但其行为的核心程序在其自己的进程中运行和整个应用程序通常部署作为单个单元。 如果此类应用程序需要横向扩展，通常会将整个应用程序复制跨多个服务器或虚拟机。

## <a name="all-in-one-applications"></a>多功能一体应用程序

一个可能的最小的应用程序体系结构的项目数。 在此体系结构，应用程序的整个逻辑包含在单个项目中、 编译到单个程序集，和作为单个单元部署。

一个新的 ASP.NET Core 项目，是否创建 Visual Studio 中或从命令行中，启动时作为简单的"一体-"monolith。 它包含的所有应用程序，包括演示文稿、 业务和数据访问逻辑的行为。 图 5-1 显示的单一项目应用的文件结构。

**图 5-1。** 单个项目 ASP.NET Core 应用

![](./media/image5-1.png)

在单个项目方案中，分离问题是通过使用文件夹实现的。 默认模板包括用于数据和服务的模型、 视图和控制器，MVC 模式职责的单独文件夹以及其他文件夹。 和在这种配置，应尽可能多地到 Views 文件夹中，有限演示文稿详细信息数据访问实现详细信息应限于保留数据文件夹中的类。 业务逻辑应驻留在服务和模型文件夹中的类。

尽管简单，单项目整体解决方案具有某些缺点。 项目的大小和复杂性增大时，文件和文件夹的数量将继续随之增加。 用户界面顾虑 （模型、 视图、 控制器） 驻留在多个文件夹中，不组合在一起按字母顺序。 其他 UI 级别构造，如筛选器或 ModelBinders，添加在其自己的文件夹中时，此问题仅获取更糟。 业务逻辑分散之间模型和服务文件夹中，并且没有其中哪些文件夹中的类应依赖于哪些其他未明确表示出。 在项目级别的组织缺少通常会导致[复式代码](http://deviq.com/spaghetti-code/)。

为了解决这些问题，应用程序通常发展为多项目解决方案，其中每个项目被视为位于特定*层*的应用程序。

## <a name="what-are-layers"></a>层有哪些？

如应用程序的复杂性增加，一种方法来管理该复杂性是应用程序分解根据其职责或相关问题。 这遵循问题原则的分离，可以帮助保护组织，以便开发人员可以轻松地找到其中实现某些功能的不断增长的基本代码。 分层体系结构通过提供的多种超出只代码组织的优点。

通过将代码组织到层中，可以在整个应用程序重复使用常见的低级功能。 因为它意味着需要编写更少的代码，并且它可以允许应用程序在单个实现，遵照干原则上标准化，此重用是有益的。

与分层体系结构，应用程序可以强制实施的限制在其层可以与其他层进行通信。 这可帮助实现封装。 当一个层已更改或替换时，仅使用这些层应受到影响。 通过限制其层依赖以便一项更改不会影响整个应用程序，则可以缓解在其上发生更改的影响的其他层。

层 （和封装） 使其可以更轻松地替换应用程序中的功能。 例如，应用程序可能最初为暂留，使用其自己的 SQL Server 数据库，但更高版本可以选择要使用的基于云的持久性策略，或一个后面 web API。 如果应用程序具有正确封装逻辑层内的其持久性实现，该 SQL Server 特定层无法替换为一个新实现的相同的公共接口。

除了可能交换出实现的未来需求的变化的响应中，应用程序层可以也更加轻松地换出以进行测试的实现。 而无需编写针对实际的数据层或应用程序的 UI 层中运行的测试，这些层可以替换为在测试时提供已知的请求的响应的假实现。 这通常会使测试更易于编写和到快得多运行相比运行时再次测试应用程序的实际基础结构。

逻辑分层是一种提高组织中企业软件应用程序的代码的常用技术，有几种方法可以在其中为层中组织代码。

> [!NOTE]
> *层*表示应用程序中的逻辑分隔。 中，应用程序逻辑以物理方式分布到单独的服务器或进程，这些单独的物理部署目标称为*层*。 是有可能，并且很常见，若要部署到单个层内的 N 层应用程序。

## <a name="traditional-n-layer-architecture-applications"></a>传统的"N 层"体系结构应用程序

最常见的应用程序逻辑注入组织层它在图 5-2 中所示。

**图 5-2。** 典型的应用程序层。

![](./media/image5-2.png)

这些层经常缩写为 UI，BLL （业务逻辑层） 和 DAL （数据访问层）。 用户使用这种体系结构，请通过仅与 BLL 交互的 UI 层的请求。 反过来，BLL，可以为数据访问请求调用 DAL。 UI 层不应作出的任何请求与 DAL 直接，也不应该它与交互直接通过其他方式的持久性。 同样，BLL 应仅通过与交互持久性经过 DAL。 这种方式，每个层都有其自己的已知的责任。

此传统的分层方法的一个缺点是，编译时依赖关系运行从顶部到底部。 即，UI 层依赖于 BLL，具体取决于 DAL。 这意味着 BLL，它通常在应用程序中保存的最重要的逻辑，取决于数据访问实现详细信息 （通常数据库存在）。 在这种体系结构中测试业务逻辑很困难，需要测试数据库。 可以使用依赖项反向原则来解决此问题，正如你将看到的下一节中。

图 5-3 显示一个示例解决方案，分解为三个项目的应用程序，由负责 （或层）。

**图 5-3。** 具有三个项目的简单整体应用程序。

![](./media/image5-3.png)

尽管此应用程序针对组织而使用多个项目，但仍将其部署为单个单元，并与其进行交互的与其客户端将与单个 web 应用。 这使得非常简单的部署过程。 图 5-4 显示了此类应用可能会如何承载使用 Windows Azure。

![](./media/image5-4.png)

**图 5-4。** Azure Web 应用的简单部署

随着应用程序需求的增长，可能需要更复杂而功能强大的部署解决方案。 图 5-5 所示的更复杂的部署计划所支持的其他功能的示例。

![](./media/image5-5.png)

**图 5-5。** 将 web 应用部署到 Azure App Service

在内部，此项目的单位分成若干个基于责任的多个项目可以提高应用程序的可维护性。

此单元可以扩展或扩大来利用基于云的按需可伸缩性。 向上扩展意味着添加到承载你的应用程序的服务器的额外 CPU、 内存、 磁盘空间或其他资源。 向外扩展意味着添加其他服务器实例的此类，无论它们是物理服务器或虚拟机。 当你的应用程序承载跨多个实例时，负载平衡器用于将请求分配给各个应用程序实例。

在 Azure 中缩放 web 应用程序的最简单方法是配置中应用程序的 App Service 计划的手动缩放。 图 5-6 显示相应的 Azure 仪表板的屏幕配置多少个实例都服务于应用程序。

![](./media/image5-6.png)

**图 5-6。** App Service 计划缩放在 Azure 中。

## <a name="clean-architecture"></a>干净的体系结构

请按照依赖反向原则以及 Domain-Driven 设计 (DDD) 原则的应用程序往往会到达相似的体系结构。 多年来，此体系结构已通过多个名称。 第一个名称之一已六边形体系结构，跟端口适配器。 最近，它已提到作为[透视体系结构](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/)或[干净的体系结构](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)。 它是此最后一个名称，干净体系结构，用于描述此电子书中的体系结构用作的基础。

> [!NOTE]
> 使用 DDD 时构建干净的体系结构可以应用于应用程序并不是使用 DDD 原则以及生成的术语。 对于前者，此组合可能被称为"干净 DDD 体系结构"。

干净的体系结构将业务逻辑和应用程序模型放在应用程序的中心。 而不是让业务逻辑依赖于数据访问或其他基础结构问题，反转此依赖关系： 基础结构和实现的详细信息取决于应用程序核心。 这被通过在应用程序核心，然后通过在基础结构层中定义的类型实现中定义抽象或接口。 可视化此体系结构的常用方法是使用一系列同心圆，类似于透视。 图 5-X 显示举例说明这种样式的体系结构的表示形式。

![](./media/image5-7.png)

**图 5-7。** 清理体系结构;透视视图

在此图中，依赖关系流接近最里面的圈。 因此，你可以看到应用程序核心 （这将从其核心的此关系图的位置获取其名称） 上的其他应用程序层没有任何依赖项。 在非常中心是应用程序的实体和接口。 外部，但仍在应用程序核心，是由域服务，通常可通过实现在内部圆周中定义的接口。 在应用程序核心，外部用户界面和基础结构层取决于在应用程序核心，但不是能在另一个 （一定）。

图 5-X 显示更好地反映 UI 和其他层之间的依赖关系的更传统水平层关系图。

![](./media/image5-8.png)

**图 5-8。** 清理体系结构;水平层视图

请注意实线箭头表示编译时依赖关系，而的虚线的箭头表示仅运行时依赖项。 使用干净的体系结构，UI 层适用于在编译时，在应用程序核心中定义的接口，理想情况下应不具有任何知道的实现类型中定义基础结构层。 在运行时，但是，这些实现类型将是必需的应用程序以执行，因此它们将需要存在，并且最多的应用程序核心接口通过依赖关系注入有线。

图 5-9 显示 ASP.NET Core 应用程序的体系结构生成以下这些建议时的更详细的视图。

![ASPNET 核心体系结构](./media/image5-9.png)

**图 5-9。** ASP.NET 核心体系结构关系图以下干净的体系结构。

应用程序核心不依赖于基础结构，因为它是很容易为该层编写自动的单元测试。 图 5-10 和 5-11 显示测试如何适合此体系结构。

![UnitTestCore](./media/image5-10.png)

**图 5-10。** 中的单元测试应用程序核心隔离。

![IntegrationTests](./media/image5-11.png)

**图 5-11。** 集成测试具有外部依赖项的基础结构实现。

同样，由于 UI 层基础结构项目中定义的类型上没有任何直接的依赖关系，很很容易交换出实现中，或者以便于测试或更改应用程序要求的响应。 ASP.NET Core 内置利用和依赖关系注入的支持使此体系结构对结构非普通整体应用程序的最佳方式。

对于单一应用程序的应用程序核心、 基础架构和用户界面的项目是所有以运行单个应用程序。 运行时应用程序体系结构可能看起来像图 5-12 中。

![ASPNET 核心体系结构 2](./media/image5-12.png)

**图 5-12。** 示例 ASP.NET Core 应用程序的运行时体系结构。

### <a name="organizing-code-in-clean-architecture"></a>组织干净的体系结构中的代码

在干净的体系结构解决方案中，每个项目已清除的职责。 在这种情况下，某些类型将属于每个项目中，你将经常找到相应的项目中的这些类型相对应的文件夹。

应用程序核心包含业务模型，其中包括实体、 服务和接口。 这些接口包括用于将使用基础结构，例如数据访问、 文件系统访问、 网络调用等执行的操作的抽象。有时将需要服务或接口定义在此层可以使用没有 UI 或基础结构的依赖项的非实体类型。 这些可定义为简单数据传输对象 (Dto)。

> ### <a name="application-core-types"></a>应用程序核心类型
> -   实体 （业务模型类的持久化）
> -   接口
> -   服务
> -   Dto

基础结构项目通常将包括数据访问实现。 在典型的 ASP.NET 核心 web 应用程序，这将包括实体框架 DbContext、 已定义，任何 EF 核心迁移和数据访问实现类。 抽象数据访问实现代码的最常见方法是使用[存储库设计模式](http://deviq.com/repository-pattern/)。

除了数据访问实现基础结构项目应包含必须与支持基础结构进行交互的服务的实现。 这些服务，应实现在应用程序核心中定义的接口，并因此基础结构应具有对应用程序核心项目的引用。

> ### <a name="infrastructure-types"></a>基础结构类型
> -   EF 核心类型 （DbContext，迁移）
> -   数据访问实现类型 （存储库）
> -   基础结构特定服务 （FileLogger、 SmtpNotifier，等等。）

ASP.NET 核心 MVC 应用程序的用户界面层将对应用程序的入口点，将 ASP.NET 核心 MVC 项目。 此项目应引用应用程序核心项目中，并且其类型应与严格通过在应用程序核心中定义的接口的基础结构进行交互。 没有直接实例化 （或静态调用） 基础结构层类型应允许 UI 层中。

> ### <a name="ui-layer-types"></a>UI 层类型
> -   控制器
> -   筛选器
> -   视图
> -   Viewmodel
> -   启动

Startup 类负责用于配置应用程序，并实现类型绑定到接口，允许在运行时正常工作的依赖关系注入。

> [!NOTE]
> 为了连接依赖关系注入中 ConfigureServices Startup.cs 文件中的 UI 项目，项目可能需要引用基础结构项目。 可以消除此依赖关系，最轻松地使用自定义 DI 容器。 此示例的目的，最简单的方法是允许 UI 项目，以引用该基础结构项目。

## <a name="monolithic-applications-and-containers"></a>整体应用程序和容器 

你可以生成单个和整体部署基于的 Web 应用程序或服务，并将其部署为一个容器。 在应用程序，它可能不是整体但组织到多个库、 组件或图层。 外部它是类似于单个进程、 单个 web 应用程序或单个服务的单个容器。

若要管理此模型，你可以部署单个容器来表示应用程序。 若要缩放，只需添加对负载平衡器在前面的其他副本。 为了简单起见来自于管理单个部署中的单个容器或 VM。

![](./media/image5-13.png)

你可以包括多个组件/库或内部层中每个容器，如图 5-X 中所示。 但是，以下的容器主体的*"做一件事，并会在一个进程中的容器*"，整体模式可能冲突。

此方法的缺点是如果/应用程序会增长，需要进行调整。 如果整个应用程序缩放，它不是真正的问题。 但是，在大多数情况下，应用程序的几个部分是瓶颈，需要进行缩放外，其他组件时使用小于。

使用典型电子商务示例;你可能需要缩放是产品信息组件。 许多多个客户浏览产品不是购买必需的许可证。 更多的客户使用他们的购物篮不是使用付款管道。 更少的客户添加注释，或查看其购买历史记录。 并且，您可能只需少量的员工组，在单个区域中，需要管理内容和市场营销活动。 通过缩放单一式设计，所有的代码被部署了多次。

除了刻度问题，所有内容对单个组件的更改需要完成重新测试整个应用程序，以及完成重新部署的所有实例。

整体方法很常见，并且许多组织正在开发使用此体系结构的方法。 许多在遇到不会有什么足够结果，而其他人已达到限制。 许多设计为在此模型中，其应用程序，因为工具和基础结构已太难生成面向服务体系结构 (SOA)，直到应用程序增长，他们看不到需要的。 如果你找到要达到的整体方法的限制，分割应用程序以使其能够更好地利用容器和微服务可能是下一步的逻辑步骤。

![](./media/image5-14.png)

部署 Microsoft Azure 中的整体应用程序可以实现为每个实例使用专用的虚拟机。 使用[Azure VM 缩放集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)，你可以轻松地缩放 Vm。 [Azure 应用程序服务](https://azure.microsoft.com/services/app-service/)可以运行的单一应用程序并轻松缩放而无需管理虚拟机的实例。 Azure 应用程序服务可以运行单一实例的 Docker 容器都一样，从而简化部署。 使用 Docker，可以部署一个单独的 VM 为 Docker 主机，并运行多个实例。 使用 Azure 平衡器，在图 5-14 所示，你可以管理缩放。

部署到各种主机可通过传统部署技术。 可以使用类似的命令管理 Docker 主机**docker 运行**如连续传送 (CD) 管道执行手动或通过自动化。

### <a name="monolithic-application-deployed-as-a-container"></a>部署为容器的整体应用程序

没有使用容器管理整体应用程序部署的好处。 缩放的容器实例是得更快比更容易地部署其他虚拟机。 使用 VM 缩放集缩放 Vm，即使它们到实例需要的时间。 在部署为应用程序实例，该应用程序的配置管理 VM 的一部分。

部署更新，因为 Docker 映像是得相当快和高效的网络。 Docker 映像通常情况下会以秒为单位，从而加快首次推出。 关闭的 Docker 实例非常简单，只需为颁发**docker 停止**命令，通常少于一秒内完成。

容器是设计使然本质上是不可变，因为您从不需要以担心损坏 Vm，而更新脚本可能会忘记帐户为某些特定的配置或剩余的文件在磁盘上。

整体应用可以受益于 Docker，分解到可以进行扩展，子系统整体应用程序开发而单独部署可能是你到领域的微服务的入口点。

> ### <a name="references--common-web-architectures"></a>引用 – 常见 Web 体系结构
> - **干净的体系结构**  
> <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - **透视体系结构**  
> <http://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - **存储库模式**  
> <http://deviq.com/repository-pattern/>
> - **清理体系结构解决方案示例**  
> <https://github.com/ardalis/cleanarchitecture>
> - **构建微服务电子书** <http://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
[以前](体系结构-principles.md) [下一步] (常见的客户端-端-web-technologies.md)
