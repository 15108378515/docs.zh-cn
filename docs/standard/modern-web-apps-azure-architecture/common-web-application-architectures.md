---
title: "常见的 web 应用程序体系结构"
description: "设计使用 ASP.NET 核心和 Microsoft Azure 的现代 web 应用程序 |常见的 web 应用程序体系结构"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: b6236cfab290211f930d6a1987075abeade4fd6d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2017
---
#<a name="common-web-application-architectures"></a><span data-ttu-id="0566b-103">常见的 Web 应用程序体系结构</span><span class="sxs-lookup"><span data-stu-id="0566b-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="0566b-104">"如果您认为良好的体系结构将占用大量资源，请尝试错误体系结构。"</span><span class="sxs-lookup"><span data-stu-id="0566b-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="0566b-105">_-Brian Foote 和 Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="0566b-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="0566b-106">摘要</span><span class="sxs-lookup"><span data-stu-id="0566b-106">Summary</span></span>

<span data-ttu-id="0566b-107">大多数传统的.NET 应用程序作为单个单位对应于可执行文件或在单个 IIS 应用程序域内运行的单个 web 应用程序部署。</span><span class="sxs-lookup"><span data-stu-id="0566b-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="0566b-108">这是最简单的部署模型，并很好地提供很多内部和较小公共应用程序。</span><span class="sxs-lookup"><span data-stu-id="0566b-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="0566b-109">但是，即使给定部署此单个单元，最重要的业务应用程序受益于一些逻辑分离到多个层。</span><span class="sxs-lookup"><span data-stu-id="0566b-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="0566b-110">整体应用程序是什么？</span><span class="sxs-lookup"><span data-stu-id="0566b-110">What is a monolithic application?</span></span>

<span data-ttu-id="0566b-111">整体应用程序是指是完全独立的根据其行为。</span><span class="sxs-lookup"><span data-stu-id="0566b-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="0566b-112">它可能交互的方式与其他服务或数据的存储过程中执行其操作，但其行为的核心程序在其自己的进程中运行和整个应用程序通常部署作为单个单元。</span><span class="sxs-lookup"><span data-stu-id="0566b-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="0566b-113">如果此类应用程序需要横向扩展，通常会将整个应用程序复制跨多个服务器或虚拟机。</span><span class="sxs-lookup"><span data-stu-id="0566b-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="0566b-114">多功能一体应用程序</span><span class="sxs-lookup"><span data-stu-id="0566b-114">All-in-One applications</span></span>

<span data-ttu-id="0566b-115">一个可能的最小的应用程序体系结构的项目数。</span><span class="sxs-lookup"><span data-stu-id="0566b-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="0566b-116">在此体系结构，应用程序的整个逻辑包含在单个项目中、 编译到单个程序集，和作为单个单元部署。</span><span class="sxs-lookup"><span data-stu-id="0566b-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="0566b-117">一个新的 ASP.NET Core 项目，是否创建 Visual Studio 中或从命令行中，启动时作为简单的"一体-"monolith。</span><span class="sxs-lookup"><span data-stu-id="0566b-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="0566b-118">它包含的所有应用程序，包括演示文稿、 业务和数据访问逻辑的行为。</span><span class="sxs-lookup"><span data-stu-id="0566b-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="0566b-119">图 5-1 显示的单一项目应用的文件结构。</span><span class="sxs-lookup"><span data-stu-id="0566b-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="0566b-120">**图 5-1。**</span><span class="sxs-lookup"><span data-stu-id="0566b-120">**Figure 5-1.**</span></span> <span data-ttu-id="0566b-121">单个项目 ASP.NET Core 应用</span><span class="sxs-lookup"><span data-stu-id="0566b-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="0566b-122">在单个项目方案中，分离问题是通过使用文件夹实现的。</span><span class="sxs-lookup"><span data-stu-id="0566b-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="0566b-123">默认模板包括用于数据和服务的模型、 视图和控制器，MVC 模式职责的单独文件夹以及其他文件夹。</span><span class="sxs-lookup"><span data-stu-id="0566b-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="0566b-124">和在这种配置，应尽可能多地到 Views 文件夹中，有限演示文稿详细信息数据访问实现详细信息应限于保留数据文件夹中的类。</span><span class="sxs-lookup"><span data-stu-id="0566b-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="0566b-125">业务逻辑应驻留在服务和模型文件夹中的类。</span><span class="sxs-lookup"><span data-stu-id="0566b-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="0566b-126">尽管简单，单项目整体解决方案具有某些缺点。</span><span class="sxs-lookup"><span data-stu-id="0566b-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="0566b-127">项目的大小和复杂性增大时，文件和文件夹的数量将继续随之增加。</span><span class="sxs-lookup"><span data-stu-id="0566b-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="0566b-128">用户界面顾虑 （模型、 视图、 控制器） 驻留在多个文件夹中，不组合在一起按字母顺序。</span><span class="sxs-lookup"><span data-stu-id="0566b-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="0566b-129">其他 UI 级别构造，如筛选器或 ModelBinders，添加在其自己的文件夹中时，此问题仅获取更糟。</span><span class="sxs-lookup"><span data-stu-id="0566b-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="0566b-130">业务逻辑分散之间模型和服务文件夹中，并且没有其中哪些文件夹中的类应依赖于哪些其他未明确表示出。</span><span class="sxs-lookup"><span data-stu-id="0566b-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="0566b-131">在项目级别的组织缺少通常会导致[复式代码](http://deviq.com/spaghetti-code/)。</span><span class="sxs-lookup"><span data-stu-id="0566b-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="0566b-132">为了解决这些问题，应用程序通常发展为多项目解决方案，其中每个项目被视为位于特定*层*的应用程序。</span><span class="sxs-lookup"><span data-stu-id="0566b-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="0566b-133">层有哪些？</span><span class="sxs-lookup"><span data-stu-id="0566b-133">What are layers?</span></span>

<span data-ttu-id="0566b-134">如应用程序的复杂性增加，一种方法来管理该复杂性是应用程序分解根据其职责或相关问题。</span><span class="sxs-lookup"><span data-stu-id="0566b-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="0566b-135">这遵循问题原则的分离，可以帮助保护组织，以便开发人员可以轻松地找到其中实现某些功能的不断增长的基本代码。</span><span class="sxs-lookup"><span data-stu-id="0566b-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="0566b-136">分层体系结构通过提供的多种超出只代码组织的优点。</span><span class="sxs-lookup"><span data-stu-id="0566b-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="0566b-137">通过将代码组织到层中，可以在整个应用程序重复使用常见的低级功能。</span><span class="sxs-lookup"><span data-stu-id="0566b-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="0566b-138">因为它意味着需要编写更少的代码，并且它可以允许应用程序在单个实现，遵照干原则上标准化，此重用是有益的。</span><span class="sxs-lookup"><span data-stu-id="0566b-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="0566b-139">与分层体系结构，应用程序可以强制实施的限制在其层可以与其他层进行通信。</span><span class="sxs-lookup"><span data-stu-id="0566b-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="0566b-140">这可帮助实现封装。</span><span class="sxs-lookup"><span data-stu-id="0566b-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="0566b-141">当一个层已更改或替换时，仅使用这些层应受到影响。</span><span class="sxs-lookup"><span data-stu-id="0566b-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="0566b-142">通过限制其层依赖以便一项更改不会影响整个应用程序，则可以缓解在其上发生更改的影响的其他层。</span><span class="sxs-lookup"><span data-stu-id="0566b-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="0566b-143">层 （和封装） 使其可以更轻松地替换应用程序中的功能。</span><span class="sxs-lookup"><span data-stu-id="0566b-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="0566b-144">例如，应用程序可能最初为暂留，使用其自己的 SQL Server 数据库，但更高版本可以选择要使用的基于云的持久性策略，或一个后面 web API。</span><span class="sxs-lookup"><span data-stu-id="0566b-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="0566b-145">如果应用程序具有正确封装逻辑层内的其持久性实现，该 SQL Server 特定层无法替换为一个新实现的相同的公共接口。</span><span class="sxs-lookup"><span data-stu-id="0566b-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="0566b-146">除了可能交换出实现的未来需求的变化的响应中，应用程序层可以也更加轻松地换出以进行测试的实现。</span><span class="sxs-lookup"><span data-stu-id="0566b-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="0566b-147">而无需编写针对实际的数据层或应用程序的 UI 层中运行的测试，这些层可以替换为在测试时提供已知的请求的响应的假实现。</span><span class="sxs-lookup"><span data-stu-id="0566b-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="0566b-148">这通常会使测试更易于编写和到快得多运行相比运行时再次测试应用程序的实际基础结构。</span><span class="sxs-lookup"><span data-stu-id="0566b-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="0566b-149">逻辑分层是一种提高组织中企业软件应用程序的代码的常用技术，有几种方法可以在其中为层中组织代码。</span><span class="sxs-lookup"><span data-stu-id="0566b-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="0566b-150">*层*表示应用程序中的逻辑分隔。</span><span class="sxs-lookup"><span data-stu-id="0566b-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="0566b-151">中，应用程序逻辑以物理方式分布到单独的服务器或进程，这些单独的物理部署目标称为*层*。</span><span class="sxs-lookup"><span data-stu-id="0566b-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="0566b-152">是有可能，并且很常见，若要部署到单个层内的 N 层应用程序。</span><span class="sxs-lookup"><span data-stu-id="0566b-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="0566b-153">传统的"N 层"体系结构应用程序</span><span class="sxs-lookup"><span data-stu-id="0566b-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="0566b-154">最常见的应用程序逻辑注入组织层它在图 5-2 中所示。</span><span class="sxs-lookup"><span data-stu-id="0566b-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="0566b-155">**图 5-2。**</span><span class="sxs-lookup"><span data-stu-id="0566b-155">**Figure 5-2.**</span></span> <span data-ttu-id="0566b-156">典型的应用程序层。</span><span class="sxs-lookup"><span data-stu-id="0566b-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="0566b-157">这些层经常缩写为 UI，BLL （业务逻辑层） 和 DAL （数据访问层）。</span><span class="sxs-lookup"><span data-stu-id="0566b-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="0566b-158">用户使用这种体系结构，请通过仅与 BLL 交互的 UI 层的请求。</span><span class="sxs-lookup"><span data-stu-id="0566b-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="0566b-159">反过来，BLL，可以为数据访问请求调用 DAL。</span><span class="sxs-lookup"><span data-stu-id="0566b-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="0566b-160">UI 层不应作出的任何请求与 DAL 直接，也不应该它与交互直接通过其他方式的持久性。</span><span class="sxs-lookup"><span data-stu-id="0566b-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="0566b-161">同样，BLL 应仅通过与交互持久性经过 DAL。</span><span class="sxs-lookup"><span data-stu-id="0566b-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="0566b-162">这种方式，每个层都有其自己的已知的责任。</span><span class="sxs-lookup"><span data-stu-id="0566b-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="0566b-163">此传统的分层方法的一个缺点是，编译时依赖关系运行从顶部到底部。</span><span class="sxs-lookup"><span data-stu-id="0566b-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="0566b-164">即，UI 层依赖于 BLL，具体取决于 DAL。</span><span class="sxs-lookup"><span data-stu-id="0566b-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="0566b-165">这意味着 BLL，它通常在应用程序中保存的最重要的逻辑，取决于数据访问实现详细信息 （通常数据库存在）。</span><span class="sxs-lookup"><span data-stu-id="0566b-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="0566b-166">在这种体系结构中测试业务逻辑很困难，需要测试数据库。</span><span class="sxs-lookup"><span data-stu-id="0566b-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="0566b-167">可以使用依赖项反向原则来解决此问题，正如你将看到的下一节中。</span><span class="sxs-lookup"><span data-stu-id="0566b-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="0566b-168">图 5-3 显示一个示例解决方案，分解为三个项目的应用程序，由负责 （或层）。</span><span class="sxs-lookup"><span data-stu-id="0566b-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="0566b-169">**图 5-3。**</span><span class="sxs-lookup"><span data-stu-id="0566b-169">**Figure 5-3.**</span></span> <span data-ttu-id="0566b-170">具有三个项目的简单整体应用程序。</span><span class="sxs-lookup"><span data-stu-id="0566b-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="0566b-171">尽管此应用程序针对组织而使用多个项目，但仍将其部署为单个单元，并与其进行交互的与其客户端将与单个 web 应用。</span><span class="sxs-lookup"><span data-stu-id="0566b-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="0566b-172">这使得非常简单的部署过程。</span><span class="sxs-lookup"><span data-stu-id="0566b-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="0566b-173">图 5-4 显示了此类应用可能会如何承载使用 Windows Azure。</span><span class="sxs-lookup"><span data-stu-id="0566b-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="0566b-174">**图 5-4。**</span><span class="sxs-lookup"><span data-stu-id="0566b-174">**Figure 5-4.**</span></span> <span data-ttu-id="0566b-175">Azure Web 应用的简单部署</span><span class="sxs-lookup"><span data-stu-id="0566b-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="0566b-176">随着应用程序需求的增长，可能需要更复杂而功能强大的部署解决方案。</span><span class="sxs-lookup"><span data-stu-id="0566b-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="0566b-177">图 5-5 所示的更复杂的部署计划所支持的其他功能的示例。</span><span class="sxs-lookup"><span data-stu-id="0566b-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="0566b-178">**图 5-5。**</span><span class="sxs-lookup"><span data-stu-id="0566b-178">**Figure 5-5.**</span></span> <span data-ttu-id="0566b-179">将 web 应用部署到 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="0566b-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="0566b-180">在内部，此项目的单位分成若干个基于责任的多个项目可以提高应用程序的可维护性。</span><span class="sxs-lookup"><span data-stu-id="0566b-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="0566b-181">此单元可以扩展或扩大来利用基于云的按需可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="0566b-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="0566b-182">向上扩展意味着添加到承载你的应用程序的服务器的额外 CPU、 内存、 磁盘空间或其他资源。</span><span class="sxs-lookup"><span data-stu-id="0566b-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="0566b-183">向外扩展意味着添加其他服务器实例的此类，无论它们是物理服务器或虚拟机。</span><span class="sxs-lookup"><span data-stu-id="0566b-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="0566b-184">当你的应用程序承载跨多个实例时，负载平衡器用于将请求分配给各个应用程序实例。</span><span class="sxs-lookup"><span data-stu-id="0566b-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="0566b-185">在 Azure 中缩放 web 应用程序的最简单方法是配置中应用程序的 App Service 计划的手动缩放。</span><span class="sxs-lookup"><span data-stu-id="0566b-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="0566b-186">图 5-6 显示相应的 Azure 仪表板的屏幕配置多少个实例都服务于应用程序。</span><span class="sxs-lookup"><span data-stu-id="0566b-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="0566b-187">**图 5-6。**</span><span class="sxs-lookup"><span data-stu-id="0566b-187">**Figure 5-6.**</span></span> <span data-ttu-id="0566b-188">App Service 计划缩放在 Azure 中。</span><span class="sxs-lookup"><span data-stu-id="0566b-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="0566b-189">干净的体系结构</span><span class="sxs-lookup"><span data-stu-id="0566b-189">Clean architecture</span></span>

<span data-ttu-id="0566b-190">请按照依赖反向原则以及 Domain-Driven 设计 (DDD) 原则的应用程序往往会到达相似的体系结构。</span><span class="sxs-lookup"><span data-stu-id="0566b-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="0566b-191">多年来，此体系结构已通过多个名称。</span><span class="sxs-lookup"><span data-stu-id="0566b-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="0566b-192">第一个名称之一已六边形体系结构，跟端口适配器。</span><span class="sxs-lookup"><span data-stu-id="0566b-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="0566b-193">最近，它已提到作为[透视体系结构](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/)或[干净的体系结构](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)。</span><span class="sxs-lookup"><span data-stu-id="0566b-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="0566b-194">它是此最后一个名称，干净体系结构，用于描述此电子书中的体系结构用作的基础。</span><span class="sxs-lookup"><span data-stu-id="0566b-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="0566b-195">使用 DDD 时构建干净的体系结构可以应用于应用程序并不是使用 DDD 原则以及生成的术语。</span><span class="sxs-lookup"><span data-stu-id="0566b-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="0566b-196">对于前者，此组合可能被称为"干净 DDD 体系结构"。</span><span class="sxs-lookup"><span data-stu-id="0566b-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="0566b-197">干净的体系结构将业务逻辑和应用程序模型放在应用程序的中心。</span><span class="sxs-lookup"><span data-stu-id="0566b-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="0566b-198">而不是让业务逻辑依赖于数据访问或其他基础结构问题，反转此依赖关系： 基础结构和实现的详细信息取决于应用程序核心。</span><span class="sxs-lookup"><span data-stu-id="0566b-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="0566b-199">这被通过在应用程序核心，然后通过在基础结构层中定义的类型实现中定义抽象或接口。</span><span class="sxs-lookup"><span data-stu-id="0566b-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="0566b-200">可视化此体系结构的常用方法是使用一系列同心圆，类似于透视。</span><span class="sxs-lookup"><span data-stu-id="0566b-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="0566b-201">图 5-X 显示举例说明这种样式的体系结构的表示形式。</span><span class="sxs-lookup"><span data-stu-id="0566b-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="0566b-202">**图 5-7。**</span><span class="sxs-lookup"><span data-stu-id="0566b-202">**Figure 5-7.**</span></span> <span data-ttu-id="0566b-203">清理体系结构;透视视图</span><span class="sxs-lookup"><span data-stu-id="0566b-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="0566b-204">在此图中，依赖关系流接近最里面的圈。</span><span class="sxs-lookup"><span data-stu-id="0566b-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="0566b-205">因此，你可以看到应用程序核心 （这将从其核心的此关系图的位置获取其名称） 上的其他应用程序层没有任何依赖项。</span><span class="sxs-lookup"><span data-stu-id="0566b-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="0566b-206">在非常中心是应用程序的实体和接口。</span><span class="sxs-lookup"><span data-stu-id="0566b-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="0566b-207">外部，但仍在应用程序核心，是由域服务，通常可通过实现在内部圆周中定义的接口。</span><span class="sxs-lookup"><span data-stu-id="0566b-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="0566b-208">在应用程序核心，外部用户界面和基础结构层取决于在应用程序核心，但不是能在另一个 （一定）。</span><span class="sxs-lookup"><span data-stu-id="0566b-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="0566b-209">图 5-X 显示更好地反映 UI 和其他层之间的依赖关系的更传统水平层关系图。</span><span class="sxs-lookup"><span data-stu-id="0566b-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="0566b-210">**图 5-8。**</span><span class="sxs-lookup"><span data-stu-id="0566b-210">**Figure 5-8.**</span></span> <span data-ttu-id="0566b-211">清理体系结构;水平层视图</span><span class="sxs-lookup"><span data-stu-id="0566b-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="0566b-212">请注意实线箭头表示编译时依赖关系，而的虚线的箭头表示仅运行时依赖项。</span><span class="sxs-lookup"><span data-stu-id="0566b-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="0566b-213">使用干净的体系结构，UI 层适用于在编译时，在应用程序核心中定义的接口，理想情况下应不具有任何知道的实现类型中定义基础结构层。</span><span class="sxs-lookup"><span data-stu-id="0566b-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="0566b-214">在运行时，但是，这些实现类型将是必需的应用程序以执行，因此它们将需要存在，并且最多的应用程序核心接口通过依赖关系注入有线。</span><span class="sxs-lookup"><span data-stu-id="0566b-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="0566b-215">图 5-9 显示 ASP.NET Core 应用程序的体系结构生成以下这些建议时的更详细的视图。</span><span class="sxs-lookup"><span data-stu-id="0566b-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASPNET 核心体系结构](./media/image5-9.png)

<span data-ttu-id="0566b-217">**图 5-9。**</span><span class="sxs-lookup"><span data-stu-id="0566b-217">**Figure 5-9.**</span></span> <span data-ttu-id="0566b-218">ASP.NET 核心体系结构关系图以下干净的体系结构。</span><span class="sxs-lookup"><span data-stu-id="0566b-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="0566b-219">应用程序核心不依赖于基础结构，因为它是很容易为该层编写自动的单元测试。</span><span class="sxs-lookup"><span data-stu-id="0566b-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="0566b-220">图 5-10 和 5-11 显示测试如何适合此体系结构。</span><span class="sxs-lookup"><span data-stu-id="0566b-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="0566b-222">**图 5-10。**</span><span class="sxs-lookup"><span data-stu-id="0566b-222">**Figure 5-10.**</span></span> <span data-ttu-id="0566b-223">中的单元测试应用程序核心隔离。</span><span class="sxs-lookup"><span data-stu-id="0566b-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="0566b-225">**图 5-11。**</span><span class="sxs-lookup"><span data-stu-id="0566b-225">**Figure 5-11.**</span></span> <span data-ttu-id="0566b-226">集成测试具有外部依赖项的基础结构实现。</span><span class="sxs-lookup"><span data-stu-id="0566b-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="0566b-227">同样，由于 UI 层基础结构项目中定义的类型上没有任何直接的依赖关系，很很容易交换出实现中，或者以便于测试或更改应用程序要求的响应。</span><span class="sxs-lookup"><span data-stu-id="0566b-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="0566b-228">ASP.NET Core 内置利用和依赖关系注入的支持使此体系结构对结构非普通整体应用程序的最佳方式。</span><span class="sxs-lookup"><span data-stu-id="0566b-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="0566b-229">对于单一应用程序的应用程序核心、 基础架构和用户界面的项目是所有以运行单个应用程序。</span><span class="sxs-lookup"><span data-stu-id="0566b-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="0566b-230">运行时应用程序体系结构可能看起来像图 5-12 中。</span><span class="sxs-lookup"><span data-stu-id="0566b-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASPNET 核心体系结构 2](./media/image5-12.png)

<span data-ttu-id="0566b-232">**图 5-12。**</span><span class="sxs-lookup"><span data-stu-id="0566b-232">**Figure 5-12.**</span></span> <span data-ttu-id="0566b-233">示例 ASP.NET Core 应用程序的运行时体系结构。</span><span class="sxs-lookup"><span data-stu-id="0566b-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="0566b-234">组织干净的体系结构中的代码</span><span class="sxs-lookup"><span data-stu-id="0566b-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="0566b-235">在干净的体系结构解决方案中，每个项目已清除的职责。</span><span class="sxs-lookup"><span data-stu-id="0566b-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="0566b-236">在这种情况下，某些类型将属于每个项目中，你将经常找到相应的项目中的这些类型相对应的文件夹。</span><span class="sxs-lookup"><span data-stu-id="0566b-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="0566b-237">应用程序核心包含业务模型，其中包括实体、 服务和接口。</span><span class="sxs-lookup"><span data-stu-id="0566b-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="0566b-238">这些接口包括用于将使用基础结构，例如数据访问、 文件系统访问、 网络调用等执行的操作的抽象。有时将需要服务或接口定义在此层可以使用没有 UI 或基础结构的依赖项的非实体类型。</span><span class="sxs-lookup"><span data-stu-id="0566b-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="0566b-239">这些可定义为简单数据传输对象 (Dto)。</span><span class="sxs-lookup"><span data-stu-id="0566b-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="0566b-240">应用程序核心类型</span><span class="sxs-lookup"><span data-stu-id="0566b-240">Application Core Types</span></span>
> -   <span data-ttu-id="0566b-241">实体 （业务模型类的持久化）</span><span class="sxs-lookup"><span data-stu-id="0566b-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="0566b-242">接口</span><span class="sxs-lookup"><span data-stu-id="0566b-242">Interfaces</span></span>
> -   <span data-ttu-id="0566b-243">服务</span><span class="sxs-lookup"><span data-stu-id="0566b-243">Services</span></span>
> -   <span data-ttu-id="0566b-244">Dto</span><span class="sxs-lookup"><span data-stu-id="0566b-244">DTOs</span></span>

<span data-ttu-id="0566b-245">基础结构项目通常将包括数据访问实现。</span><span class="sxs-lookup"><span data-stu-id="0566b-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="0566b-246">在典型的 ASP.NET 核心 web 应用程序，这将包括实体框架 DbContext、 已定义，任何 EF 核心迁移和数据访问实现类。</span><span class="sxs-lookup"><span data-stu-id="0566b-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="0566b-247">抽象数据访问实现代码的最常见方法是使用[存储库设计模式](http://deviq.com/repository-pattern/)。</span><span class="sxs-lookup"><span data-stu-id="0566b-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="0566b-248">除了数据访问实现基础结构项目应包含必须与支持基础结构进行交互的服务的实现。</span><span class="sxs-lookup"><span data-stu-id="0566b-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="0566b-249">这些服务，应实现在应用程序核心中定义的接口，并因此基础结构应具有对应用程序核心项目的引用。</span><span class="sxs-lookup"><span data-stu-id="0566b-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="0566b-250">基础结构类型</span><span class="sxs-lookup"><span data-stu-id="0566b-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="0566b-251">EF 核心类型 （DbContext，迁移）</span><span class="sxs-lookup"><span data-stu-id="0566b-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="0566b-252">数据访问实现类型 （存储库）</span><span class="sxs-lookup"><span data-stu-id="0566b-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="0566b-253">基础结构特定服务 （FileLogger、 SmtpNotifier，等等。）</span><span class="sxs-lookup"><span data-stu-id="0566b-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="0566b-254">ASP.NET 核心 MVC 应用程序的用户界面层将对应用程序的入口点，将 ASP.NET 核心 MVC 项目。</span><span class="sxs-lookup"><span data-stu-id="0566b-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="0566b-255">此项目应引用应用程序核心项目中，并且其类型应与严格通过在应用程序核心中定义的接口的基础结构进行交互。</span><span class="sxs-lookup"><span data-stu-id="0566b-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="0566b-256">没有直接实例化 （或静态调用） 基础结构层类型应允许 UI 层中。</span><span class="sxs-lookup"><span data-stu-id="0566b-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="0566b-257">UI 层类型</span><span class="sxs-lookup"><span data-stu-id="0566b-257">UI Layer Types</span></span>
> -   <span data-ttu-id="0566b-258">控制器</span><span class="sxs-lookup"><span data-stu-id="0566b-258">Controllers</span></span>
> -   <span data-ttu-id="0566b-259">筛选器</span><span class="sxs-lookup"><span data-stu-id="0566b-259">Filters</span></span>
> -   <span data-ttu-id="0566b-260">视图</span><span class="sxs-lookup"><span data-stu-id="0566b-260">Views</span></span>
> -   <span data-ttu-id="0566b-261">Viewmodel</span><span class="sxs-lookup"><span data-stu-id="0566b-261">ViewModels</span></span>
> -   <span data-ttu-id="0566b-262">启动</span><span class="sxs-lookup"><span data-stu-id="0566b-262">Startup</span></span>

<span data-ttu-id="0566b-263">Startup 类负责用于配置应用程序，并实现类型绑定到接口，允许在运行时正常工作的依赖关系注入。</span><span class="sxs-lookup"><span data-stu-id="0566b-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="0566b-264">为了连接依赖关系注入中 ConfigureServices Startup.cs 文件中的 UI 项目，项目可能需要引用基础结构项目。</span><span class="sxs-lookup"><span data-stu-id="0566b-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="0566b-265">可以消除此依赖关系，最轻松地使用自定义 DI 容器。</span><span class="sxs-lookup"><span data-stu-id="0566b-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="0566b-266">此示例的目的，最简单的方法是允许 UI 项目，以引用该基础结构项目。</span><span class="sxs-lookup"><span data-stu-id="0566b-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="0566b-267">整体应用程序和容器</span><span class="sxs-lookup"><span data-stu-id="0566b-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="0566b-268">你可以生成单个和整体部署基于的 Web 应用程序或服务，并将其部署为一个容器。</span><span class="sxs-lookup"><span data-stu-id="0566b-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="0566b-269">在应用程序，它可能不是整体但组织到多个库、 组件或图层。</span><span class="sxs-lookup"><span data-stu-id="0566b-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="0566b-270">外部它是类似于单个进程、 单个 web 应用程序或单个服务的单个容器。</span><span class="sxs-lookup"><span data-stu-id="0566b-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="0566b-271">若要管理此模型，你可以部署单个容器来表示应用程序。</span><span class="sxs-lookup"><span data-stu-id="0566b-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="0566b-272">若要缩放，只需添加对负载平衡器在前面的其他副本。</span><span class="sxs-lookup"><span data-stu-id="0566b-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="0566b-273">为了简单起见来自于管理单个部署中的单个容器或 VM。</span><span class="sxs-lookup"><span data-stu-id="0566b-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="0566b-274">你可以包括多个组件/库或内部层中每个容器，如图 5-X 中所示。</span><span class="sxs-lookup"><span data-stu-id="0566b-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="0566b-275">但是，以下的容器主体的*"做一件事，并会在一个进程中的容器*"，整体模式可能冲突。</span><span class="sxs-lookup"><span data-stu-id="0566b-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="0566b-276">此方法的缺点是如果/应用程序会增长，需要进行调整。</span><span class="sxs-lookup"><span data-stu-id="0566b-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="0566b-277">如果整个应用程序缩放，它不是真正的问题。</span><span class="sxs-lookup"><span data-stu-id="0566b-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="0566b-278">但是，在大多数情况下，应用程序的几个部分是瓶颈，需要进行缩放外，其他组件时使用小于。</span><span class="sxs-lookup"><span data-stu-id="0566b-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="0566b-279">使用典型电子商务示例;你可能需要缩放是产品信息组件。</span><span class="sxs-lookup"><span data-stu-id="0566b-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="0566b-280">许多多个客户浏览产品不是购买必需的许可证。</span><span class="sxs-lookup"><span data-stu-id="0566b-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="0566b-281">更多的客户使用他们的购物篮不是使用付款管道。</span><span class="sxs-lookup"><span data-stu-id="0566b-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="0566b-282">更少的客户添加注释，或查看其购买历史记录。</span><span class="sxs-lookup"><span data-stu-id="0566b-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="0566b-283">并且，您可能只需少量的员工组，在单个区域中，需要管理内容和市场营销活动。</span><span class="sxs-lookup"><span data-stu-id="0566b-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="0566b-284">通过缩放单一式设计，所有的代码被部署了多次。</span><span class="sxs-lookup"><span data-stu-id="0566b-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="0566b-285">除了刻度问题，所有内容对单个组件的更改需要完成重新测试整个应用程序，以及完成重新部署的所有实例。</span><span class="sxs-lookup"><span data-stu-id="0566b-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="0566b-286">整体方法很常见，并且许多组织正在开发使用此体系结构的方法。</span><span class="sxs-lookup"><span data-stu-id="0566b-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="0566b-287">许多在遇到不会有什么足够结果，而其他人已达到限制。</span><span class="sxs-lookup"><span data-stu-id="0566b-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="0566b-288">许多设计为在此模型中，其应用程序，因为工具和基础结构已太难生成面向服务体系结构 (SOA)，直到应用程序增长，他们看不到需要的。</span><span class="sxs-lookup"><span data-stu-id="0566b-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="0566b-289">如果你找到要达到的整体方法的限制，分割应用程序以使其能够更好地利用容器和微服务可能是下一步的逻辑步骤。</span><span class="sxs-lookup"><span data-stu-id="0566b-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="0566b-290">部署 Microsoft Azure 中的整体应用程序可以实现为每个实例使用专用的虚拟机。</span><span class="sxs-lookup"><span data-stu-id="0566b-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="0566b-291">使用[Azure VM 缩放集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)，你可以轻松地缩放 Vm。</span><span class="sxs-lookup"><span data-stu-id="0566b-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="0566b-292">[Azure 应用程序服务](https://azure.microsoft.com/services/app-service/)可以运行的单一应用程序并轻松缩放而无需管理虚拟机的实例。</span><span class="sxs-lookup"><span data-stu-id="0566b-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="0566b-293">Azure 应用程序服务可以运行单一实例的 Docker 容器都一样，从而简化部署。</span><span class="sxs-lookup"><span data-stu-id="0566b-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="0566b-294">使用 Docker，可以部署一个单独的 VM 为 Docker 主机，并运行多个实例。</span><span class="sxs-lookup"><span data-stu-id="0566b-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="0566b-295">使用 Azure 平衡器，在图 5-14 所示，你可以管理缩放。</span><span class="sxs-lookup"><span data-stu-id="0566b-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="0566b-296">部署到各种主机可通过传统部署技术。</span><span class="sxs-lookup"><span data-stu-id="0566b-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="0566b-297">可以使用类似的命令管理 Docker 主机**docker 运行**如连续传送 (CD) 管道执行手动或通过自动化。</span><span class="sxs-lookup"><span data-stu-id="0566b-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="0566b-298">部署为容器的整体应用程序</span><span class="sxs-lookup"><span data-stu-id="0566b-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="0566b-299">没有使用容器管理整体应用程序部署的好处。</span><span class="sxs-lookup"><span data-stu-id="0566b-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="0566b-300">缩放的容器实例是得更快比更容易地部署其他虚拟机。</span><span class="sxs-lookup"><span data-stu-id="0566b-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="0566b-301">使用 VM 缩放集缩放 Vm，即使它们到实例需要的时间。</span><span class="sxs-lookup"><span data-stu-id="0566b-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="0566b-302">在部署为应用程序实例，该应用程序的配置管理 VM 的一部分。</span><span class="sxs-lookup"><span data-stu-id="0566b-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="0566b-303">部署更新，因为 Docker 映像是得相当快和高效的网络。</span><span class="sxs-lookup"><span data-stu-id="0566b-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="0566b-304">Docker 映像通常情况下会以秒为单位，从而加快首次推出。</span><span class="sxs-lookup"><span data-stu-id="0566b-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="0566b-305">关闭的 Docker 实例非常简单，只需为颁发**docker 停止**命令，通常少于一秒内完成。</span><span class="sxs-lookup"><span data-stu-id="0566b-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="0566b-306">容器是设计使然本质上是不可变，因为您从不需要以担心损坏 Vm，而更新脚本可能会忘记帐户为某些特定的配置或剩余的文件在磁盘上。</span><span class="sxs-lookup"><span data-stu-id="0566b-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="0566b-307">整体应用可以受益于 Docker，分解到可以进行扩展，子系统整体应用程序开发而单独部署可能是你到领域的微服务的入口点。</span><span class="sxs-lookup"><span data-stu-id="0566b-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="0566b-308">引用 – 常见 Web 体系结构</span><span class="sxs-lookup"><span data-stu-id="0566b-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="0566b-309">**干净的体系结构**</span><span class="sxs-lookup"><span data-stu-id="0566b-309">**The Clean Architecture**</span></span>  
> <span data-ttu-id="0566b-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span><span class="sxs-lookup"><span data-stu-id="0566b-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span></span>
> - <span data-ttu-id="0566b-311">**透视体系结构**</span><span class="sxs-lookup"><span data-stu-id="0566b-311">**The Onion Architecture**</span></span>  
> <span data-ttu-id="0566b-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span><span class="sxs-lookup"><span data-stu-id="0566b-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span></span>
> - <span data-ttu-id="0566b-313">**存储库模式**</span><span class="sxs-lookup"><span data-stu-id="0566b-313">**The Repository Pattern**</span></span>  
> <span data-ttu-id="0566b-314"><http://deviq.com/repository-pattern/></span><span class="sxs-lookup"><span data-stu-id="0566b-314"><http://deviq.com/repository-pattern/></span></span>
> - <span data-ttu-id="0566b-315">**清理体系结构解决方案示例**</span><span class="sxs-lookup"><span data-stu-id="0566b-315">**Clean Architecture Solution Sample**</span></span>  
> <span data-ttu-id="0566b-316"><https://github.com/ardalis/cleanarchitecture></span><span class="sxs-lookup"><span data-stu-id="0566b-316"><https://github.com/ardalis/cleanarchitecture></span></span>
> - <span data-ttu-id="0566b-317">**构建微服务电子书** <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="0566b-317">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="0566b-318">[以前](体系结构-principles.md) [下一步] (常见的客户端-端-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="0566b-318">[Previous] (architectural-principles.md) [Next] (common-client-side-web-technologies.md)</span></span>
