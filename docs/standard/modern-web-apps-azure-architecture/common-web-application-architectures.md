---
title: 常用 Web 应用程序体系结构
description: 使用 ASP.NET Core 和 Microsoft Azure 构建新式 Web 应用 | 常用 Web 应用程序体系结构
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.openlocfilehash: cb9a1d68d4c7c66c6adab3a5e932ee37c3ea22b0
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106418"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="a9877-103">常用 Web 应用程序体系结构</span><span class="sxs-lookup"><span data-stu-id="a9877-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="a9877-104">“如果你认为好的体系结构很昂贵，试试糟糕的体系结构吧。”</span><span class="sxs-lookup"><span data-stu-id="a9877-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="a9877-105">_- Brian Foote 和 Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="a9877-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="a9877-106">总结</span><span class="sxs-lookup"><span data-stu-id="a9877-106">Summary</span></span>

<span data-ttu-id="a9877-107">大多数传统 .NET 应用程序都部署为单一单位，对应于单一 IIS 应用域中运行的可执行文件或单个 Web 应用程序。</span><span class="sxs-lookup"><span data-stu-id="a9877-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="a9877-108">这是最简单的部署模型，能很好地为众多内部和小型公共应用程序提供服务。</span><span class="sxs-lookup"><span data-stu-id="a9877-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="a9877-109">然而，即使提供此单一单位部署，大多数重要的业务应用程序仍能从某些逻辑分离为多层的过程中受益。</span><span class="sxs-lookup"><span data-stu-id="a9877-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="a9877-110">什么是整体式应用程序？</span><span class="sxs-lookup"><span data-stu-id="a9877-110">What is a monolithic application?</span></span>

<span data-ttu-id="a9877-111">就其行为而言，整体式应用程序是完全独立的应用程序。</span><span class="sxs-lookup"><span data-stu-id="a9877-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="a9877-112">在执行操作的过程中，该应用程序可能与其他服务或数据存储发生交互，但在自身进程或整个应用程序内行为运行的核心通常是部署为单个单位。</span><span class="sxs-lookup"><span data-stu-id="a9877-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="a9877-113">如果此类应用程序需要横向扩展，通常需要在多个服务器或虚拟机中复制整个应用程序。</span><span class="sxs-lookup"><span data-stu-id="a9877-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="a9877-114">一体式应用程序</span><span class="sxs-lookup"><span data-stu-id="a9877-114">All-in-One applications</span></span>

<span data-ttu-id="a9877-115">应用程序体系结构项目可能的最小数量是一。</span><span class="sxs-lookup"><span data-stu-id="a9877-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="a9877-116">在这种体系结构中，应用程序的完整逻辑包含在单一项目中，编译为单一程序集并部署为单一单位。</span><span class="sxs-lookup"><span data-stu-id="a9877-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="a9877-117">一个新的 ASP.NET Core 项目，不管是在 Visual Studio 中还是通过命令行创建，最初都是简单的“一体式”整体应用程序。</span><span class="sxs-lookup"><span data-stu-id="a9877-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="a9877-118">它包含应用程序的所有行为，包括演示、业务和数据访问逻辑。</span><span class="sxs-lookup"><span data-stu-id="a9877-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="a9877-119">图 5-1 展示了单项目应用的文件结构。</span><span class="sxs-lookup"><span data-stu-id="a9877-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="a9877-120">**图 5-1**。</span><span class="sxs-lookup"><span data-stu-id="a9877-120">**Figure 5-1.**</span></span> <span data-ttu-id="a9877-121">单项目 ASP.NET Core 应用</span><span class="sxs-lookup"><span data-stu-id="a9877-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="a9877-122">在单项目方案中，通过使用文件夹实现关注分离。</span><span class="sxs-lookup"><span data-stu-id="a9877-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="a9877-123">默认模板包括单独的模型、视图和控制器的 MVC 模式职责文件夹，以及其他数据和服务文件夹。</span><span class="sxs-lookup"><span data-stu-id="a9877-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="a9877-124">在这种排列中，应尽可能地将演示详细信息限制在“视图”文件夹，将数据访问实现详细信息限制在“数据”文件夹中保存的类。</span><span class="sxs-lookup"><span data-stu-id="a9877-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="a9877-125">业务逻辑应位于模型文件夹内的服务和类中。</span><span class="sxs-lookup"><span data-stu-id="a9877-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="a9877-126">尽管简单，但单项目整体解决方案也有一些缺点。</span><span class="sxs-lookup"><span data-stu-id="a9877-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="a9877-127">随着项目的大小和复杂性增加，文件和文件夹数量也会继续随之增加。</span><span class="sxs-lookup"><span data-stu-id="a9877-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="a9877-128">UI 问题（模型、视图和控制器）驻留于多个文件夹中，这些文件夹未按字母顺序组合在一起。</span><span class="sxs-lookup"><span data-stu-id="a9877-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="a9877-129">将其他 UI 级别构造（例如筛选器或 ModelBinder）添加到它们自己的文件夹时，问题只会变得更糟。</span><span class="sxs-lookup"><span data-stu-id="a9877-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="a9877-130">业务逻辑分散于“模型”和“服务”文件夹之间，没有明确地指示哪些文件中的哪些类应当依赖其他类。</span><span class="sxs-lookup"><span data-stu-id="a9877-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="a9877-131">这种项目级别缺少组织的情况通常会导致[面条式代码](http://deviq.com/spaghetti-code/)。</span><span class="sxs-lookup"><span data-stu-id="a9877-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="a9877-132">为解决这些问题，应用程序通常演变为多项目解决方案，其中将每个项目视为位于应用程序的特定层。</span><span class="sxs-lookup"><span data-stu-id="a9877-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="a9877-133">什么是层次？</span><span class="sxs-lookup"><span data-stu-id="a9877-133">What are layers?</span></span>

<span data-ttu-id="a9877-134">随着应用程序的复杂性增加，管理复杂性的方式之一是根据职责或问题分解应用程序。</span><span class="sxs-lookup"><span data-stu-id="a9877-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="a9877-135">这遵循关注分离原则，有助于使基本代码井然有序，以便开发人员可轻松找到实现特定功能的位置。</span><span class="sxs-lookup"><span data-stu-id="a9877-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="a9877-136">然而，分层体系结构提供的好处远远不止于代码组织结构。</span><span class="sxs-lookup"><span data-stu-id="a9877-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="a9877-137">通过将代码分层排列，常见的低级功能可在整个应用程序中重复使用。</span><span class="sxs-lookup"><span data-stu-id="a9877-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="a9877-138">这种重复使用很有用，因为它意味着需要编写的代码变少，还因为它可以让应用程序能够对某个实现进行标准化，从而遵循 DRY 原则。</span><span class="sxs-lookup"><span data-stu-id="a9877-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="a9877-139">借助分层体系结构，应用程序可以强制实施有关哪些层可以与其他层通信的限制。</span><span class="sxs-lookup"><span data-stu-id="a9877-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="a9877-140">这有助于实现封装。</span><span class="sxs-lookup"><span data-stu-id="a9877-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="a9877-141">某层发生更改或更换时，只有与它一起工作的那些层会受到影响。</span><span class="sxs-lookup"><span data-stu-id="a9877-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="a9877-142">通过限制哪些层依赖其他层，可缓解更改的影响，使一项更改不会影响整个应用程序。</span><span class="sxs-lookup"><span data-stu-id="a9877-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="a9877-143">分层（和封装）让替换应用程序内的功能变得更加轻松。</span><span class="sxs-lookup"><span data-stu-id="a9877-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="a9877-144">例如，应用程序最初可能使用自己的 SQL Server 数据库来实现持久性，但稍后可能选择使用基于云的持久性策略，或 Web API 后的策略。</span><span class="sxs-lookup"><span data-stu-id="a9877-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="a9877-145">如果应用程序将其持久性实现正确封装于逻辑层中，则可使用实现相同公共接口的新的 SQL Server 特定层替换它。</span><span class="sxs-lookup"><span data-stu-id="a9877-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="a9877-146">除可能的交换实现，以应对将来的要求更改之外，应用程序层还能让测试用途的交换实现变得更加轻松。</span><span class="sxs-lookup"><span data-stu-id="a9877-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="a9877-147">无需编写针对应用程序的真实数据层或 UI 层操作的测试，可在测试时使用提供请求的已知响应的假实现来替换这些层。</span><span class="sxs-lookup"><span data-stu-id="a9877-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="a9877-148">通常情况下，与针对应用程序的实际基础结构运行测试相比，这可以让测试更容易编写，运行速度也更快。</span><span class="sxs-lookup"><span data-stu-id="a9877-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="a9877-149">逻辑分层是用于改进企业软件应用程序代码的常用技术，可通过多种方式将代码分层排列。</span><span class="sxs-lookup"><span data-stu-id="a9877-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="a9877-150">层次表示应用程序内的逻辑分隔。</span><span class="sxs-lookup"><span data-stu-id="a9877-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="a9877-151">如果应用程序逻辑以物理方式分布到单独的服务器或进程中，这些单独的物理部署目标就称为“层级”。</span><span class="sxs-lookup"><span data-stu-id="a9877-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="a9877-152">具有部署到单一层级的 N 层应用程序是可能的，也很常见。</span><span class="sxs-lookup"><span data-stu-id="a9877-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="a9877-153">传统“N 层”体系结构应用程序</span><span class="sxs-lookup"><span data-stu-id="a9877-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="a9877-154">图 5-2 展示了应用程序逻辑分层最常用的组织结构。</span><span class="sxs-lookup"><span data-stu-id="a9877-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="a9877-155">**图 5-2**。</span><span class="sxs-lookup"><span data-stu-id="a9877-155">**Figure 5-2.**</span></span> <span data-ttu-id="a9877-156">典型的应用程序层次。</span><span class="sxs-lookup"><span data-stu-id="a9877-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="a9877-157">这些层经常简称为 UI、BLL（业务逻辑层）和 DAL（数据访问层）。</span><span class="sxs-lookup"><span data-stu-id="a9877-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="a9877-158">使用此体系结构，用户可通过 UI 层（仅与 BLL 交互）提出请求。</span><span class="sxs-lookup"><span data-stu-id="a9877-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="a9877-159">反过来，BLL 可为数据访问请求调用 DAL。</span><span class="sxs-lookup"><span data-stu-id="a9877-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="a9877-160">UI 层不得直接向 DAL 提出任何请求，也不得通过其他途径直接与持久性发生交互。</span><span class="sxs-lookup"><span data-stu-id="a9877-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="a9877-161">同样，BLL 应仅通过 DAL 与持久性发生交互。</span><span class="sxs-lookup"><span data-stu-id="a9877-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="a9877-162">通过这种方式，每层都有自己熟知的职责。</span><span class="sxs-lookup"><span data-stu-id="a9877-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="a9877-163">这种传统分层方法的缺点之一是编译时依赖关系由上而下运行。</span><span class="sxs-lookup"><span data-stu-id="a9877-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="a9877-164">即，UI 层依赖于 BLL，而 BLL 依赖于 DAL。</span><span class="sxs-lookup"><span data-stu-id="a9877-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="a9877-165">这意味着，通常保存应用程序中最重要的逻辑的 BLL，依赖于数据访问实现详细信息（且通常依赖于数据库的存在）。</span><span class="sxs-lookup"><span data-stu-id="a9877-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="a9877-166">在这样的体系结构中测试业务逻辑通常是有难度的，需要一个测试数据库。</span><span class="sxs-lookup"><span data-stu-id="a9877-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="a9877-167">如下节中所述，依赖倒置原则可以用来解决此问题。</span><span class="sxs-lookup"><span data-stu-id="a9877-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="a9877-168">图 5-3 展示了一个示例解决方案，其中按职责（层次）将应用程序分解为三个项目。</span><span class="sxs-lookup"><span data-stu-id="a9877-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="a9877-169">**图 5-3**。</span><span class="sxs-lookup"><span data-stu-id="a9877-169">**Figure 5-3.**</span></span> <span data-ttu-id="a9877-170">具有三个项目的简单整体式应用程序。</span><span class="sxs-lookup"><span data-stu-id="a9877-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="a9877-171">尽管出于组织架构目的，此应用程序使用多个项目，但它仍作为单一单位进行部署，且其客户端以单一 Web 应用的形式与其交互。</span><span class="sxs-lookup"><span data-stu-id="a9877-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="a9877-172">这使部署过程变得非常简单。</span><span class="sxs-lookup"><span data-stu-id="a9877-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="a9877-173">图 5-4 展示了如何使用 Microsoft Azure 承载此类应用。</span><span class="sxs-lookup"><span data-stu-id="a9877-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="a9877-174">**图 5-4**。</span><span class="sxs-lookup"><span data-stu-id="a9877-174">**Figure 5-4.**</span></span> <span data-ttu-id="a9877-175">Azure Web 应用简单部署</span><span class="sxs-lookup"><span data-stu-id="a9877-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="a9877-176">随着应用程序需求增长，可能需要更复杂、更可靠的部署解决方案。</span><span class="sxs-lookup"><span data-stu-id="a9877-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="a9877-177">图 5-5 展示了支持其他功能、更复杂的部署计划示例。</span><span class="sxs-lookup"><span data-stu-id="a9877-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="a9877-178">**图 5-5**。</span><span class="sxs-lookup"><span data-stu-id="a9877-178">**Figure 5-5.**</span></span> <span data-ttu-id="a9877-179">将 Web 应用部署到 Azure 应用服务</span><span class="sxs-lookup"><span data-stu-id="a9877-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="a9877-180">在内部，此项目的组织根据职责分为多个项目，提高了应用程序的可维护性。</span><span class="sxs-lookup"><span data-stu-id="a9877-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="a9877-181">可纵向或横向扩展此单位，以利用基于云的按需可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="a9877-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="a9877-182">纵向扩展指的是向承载应用的服务器添加额外的 CPU、内存、磁盘空间或其他资源。</span><span class="sxs-lookup"><span data-stu-id="a9877-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="a9877-183">横向扩展指的是添加此类服务器的其他实例，无论它们属于物理服务器还是虚拟机。</span><span class="sxs-lookup"><span data-stu-id="a9877-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="a9877-184">在多个实例中承载应用时，可以使用负载均衡器来将请求分配给各个应用实例。</span><span class="sxs-lookup"><span data-stu-id="a9877-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="a9877-185">在 Azure 中缩放 Web 应用程序最简单的方法是在应用程序的 应用服务计划中手动配置缩放。</span><span class="sxs-lookup"><span data-stu-id="a9877-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="a9877-186">图 5-6 展示用于配置为应用提供服务的实例数量的相应 Azure 仪表板屏幕。</span><span class="sxs-lookup"><span data-stu-id="a9877-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="a9877-187">**如 5-6**。</span><span class="sxs-lookup"><span data-stu-id="a9877-187">**Figure 5-6.**</span></span> <span data-ttu-id="a9877-188">Azure 中的应用服务计划缩放。</span><span class="sxs-lookup"><span data-stu-id="a9877-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="a9877-189">干净体系结构</span><span class="sxs-lookup"><span data-stu-id="a9877-189">Clean architecture</span></span>

<span data-ttu-id="a9877-190">遵循依赖倒置原则以及域驱动设计原则 (DDD) 的应用程序倾向于达到类似的体系结构。</span><span class="sxs-lookup"><span data-stu-id="a9877-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="a9877-191">多年来，这种体系结构有多种名称。</span><span class="sxs-lookup"><span data-stu-id="a9877-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="a9877-192">最初的名称之一是六边形体系结构，然后是端口 - 适配器。</span><span class="sxs-lookup"><span data-stu-id="a9877-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="a9877-193">最近，它被称为[洋葱体系结构](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/)或[干净体系结构](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)。</span><span class="sxs-lookup"><span data-stu-id="a9877-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="a9877-194">干净体系结构是它最新的名称，用作介绍本电子书中的体系结构的基础。</span><span class="sxs-lookup"><span data-stu-id="a9877-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="a9877-195">术语“干净体系结构”可应用于使用 DDD 原则生成以及未使用 DDD 原则生成的应用程序。</span><span class="sxs-lookup"><span data-stu-id="a9877-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="a9877-196">对于前者，这种组合可称为“干净 DDD 体系结构”。</span><span class="sxs-lookup"><span data-stu-id="a9877-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="a9877-197">干净体系结构将业务逻辑和应用程序模型置于应用程序的中心。</span><span class="sxs-lookup"><span data-stu-id="a9877-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="a9877-198">不是拥有依赖于数据访问或其他基础结构问题的业务逻辑，此依赖关系被倒置：基础结构和实现详细信息依赖于应用程序内核。</span><span class="sxs-lookup"><span data-stu-id="a9877-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="a9877-199">实现方法是在应用程序内核中定义抽象或接口，然后按基础结构层中定义的类型进行实现。</span><span class="sxs-lookup"><span data-stu-id="a9877-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="a9877-200">将此体系结构可视化的常用方法是使用一系列同心圆，类似于洋葱。</span><span class="sxs-lookup"><span data-stu-id="a9877-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="a9877-201">图 5-X 展示这种样式的体系结构表示形式的示例。</span><span class="sxs-lookup"><span data-stu-id="a9877-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="a9877-202">**图 5-7**。</span><span class="sxs-lookup"><span data-stu-id="a9877-202">**Figure 5-7.**</span></span> <span data-ttu-id="a9877-203">干净体系结构，洋葱视图</span><span class="sxs-lookup"><span data-stu-id="a9877-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="a9877-204">在此关系图中，依赖关系流向最里面的圆。</span><span class="sxs-lookup"><span data-stu-id="a9877-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="a9877-205">因此，可以看到，应用程序内核（采用此关系图核心位置中的名称）不依赖于其他应用程序层。</span><span class="sxs-lookup"><span data-stu-id="a9877-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="a9877-206">正中心是应用程序的实体和接口。</span><span class="sxs-lookup"><span data-stu-id="a9877-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="a9877-207">外部，但仍位于应用程序内核是域服务，通常可实现内部圆圈中定义的接口。</span><span class="sxs-lookup"><span data-stu-id="a9877-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="a9877-208">在应用程序内核外面，用户界面和基础结构层均依赖于应用程序内核，但不彼此依赖（必然）。</span><span class="sxs-lookup"><span data-stu-id="a9877-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="a9877-209">图 5-X 展示了可更好地反映 UI 和其他层之间的依赖关系的更传统的水平层次关系图。</span><span class="sxs-lookup"><span data-stu-id="a9877-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="a9877-210">**图 5-8**。</span><span class="sxs-lookup"><span data-stu-id="a9877-210">**Figure 5-8.**</span></span> <span data-ttu-id="a9877-211">干净体系结构，水平层次视图</span><span class="sxs-lookup"><span data-stu-id="a9877-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="a9877-212">注意，实线箭头表示编译时依赖关系，而虚线箭头表示仅运行时依赖关系。</span><span class="sxs-lookup"><span data-stu-id="a9877-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="a9877-213">使用干净体系结构，UI 层可使用编译时应用程序内核中定义的接口，理想情况下不应知道体系结构层中定义的实现类型。</span><span class="sxs-lookup"><span data-stu-id="a9877-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="a9877-214">但是在运行时，这些实现类型是应用执行所必需的，因此它们需要存在并通过依赖关系注入接通应用程序内核接口。</span><span class="sxs-lookup"><span data-stu-id="a9877-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="a9877-215">图 5-9 展示了遵循这些建议生成 ASP.NET Core 应用程序体系结构时的更详细的视图。</span><span class="sxs-lookup"><span data-stu-id="a9877-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASPNET Core 体系结构](./media/image5-9.png)

<span data-ttu-id="a9877-217">**图 5-9**。</span><span class="sxs-lookup"><span data-stu-id="a9877-217">**Figure 5-9.**</span></span> <span data-ttu-id="a9877-218">遵循干净体系结构的 ASP.NET Core 体系结构关系图。</span><span class="sxs-lookup"><span data-stu-id="a9877-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="a9877-219">由于应用程序内核不依赖于基础结构，可轻松为此层次编写自动化单元测试。</span><span class="sxs-lookup"><span data-stu-id="a9877-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="a9877-220">图 5-10 和 5-11 展示了测试如何适应此体系结构。</span><span class="sxs-lookup"><span data-stu-id="a9877-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="a9877-222">**图 5-10**。</span><span class="sxs-lookup"><span data-stu-id="a9877-222">**Figure 5-10.**</span></span> <span data-ttu-id="a9877-223">隔离状态下的单元测试应用程序内核。</span><span class="sxs-lookup"><span data-stu-id="a9877-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="a9877-225">**图 5-11**。</span><span class="sxs-lookup"><span data-stu-id="a9877-225">**Figure 5-11.**</span></span> <span data-ttu-id="a9877-226">使用外部依赖关系的集成测试基础结构实现。</span><span class="sxs-lookup"><span data-stu-id="a9877-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="a9877-227">由于 UI 层对基础结构项目中定义的类型没有任何直接依赖关系，同样，可轻松交换实现，无论是为便于测试还是为应对不断变化的应用程序要求。</span><span class="sxs-lookup"><span data-stu-id="a9877-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="a9877-228">ASP.NET Core 对内置依赖关系注入的使用及相关支持使此体系结构最适合用于构造重要的整体式应用程序。</span><span class="sxs-lookup"><span data-stu-id="a9877-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="a9877-229">对于整体式应用程序，应用程序内核、基础结构和用户界面项目均作为单一应用程序运行。</span><span class="sxs-lookup"><span data-stu-id="a9877-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="a9877-230">运行时应用程序体系结构可能类似于图 5-12。</span><span class="sxs-lookup"><span data-stu-id="a9877-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASPNET Core 体系结构 2](./media/image5-12.png)

<span data-ttu-id="a9877-232">**图 5-12**。</span><span class="sxs-lookup"><span data-stu-id="a9877-232">**Figure 5-12.**</span></span> <span data-ttu-id="a9877-233">示例 ASP.NET Core 应用的运行时体系结构。</span><span class="sxs-lookup"><span data-stu-id="a9877-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="a9877-234">采用干净体系结构排列代码</span><span class="sxs-lookup"><span data-stu-id="a9877-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="a9877-235">在干净体系结构解决方案中，每个项目都有明确的职责。</span><span class="sxs-lookup"><span data-stu-id="a9877-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="a9877-236">在这种情况下，某些类型将属于每个项目，你会经常在相应的项目中找到与这些类型相应的文件夹。</span><span class="sxs-lookup"><span data-stu-id="a9877-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="a9877-237">应用程序内核包含业务模型，后者包括实体、服务和接口。</span><span class="sxs-lookup"><span data-stu-id="a9877-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="a9877-238">这些接口包括使用基础结构执行的操作（如数据访问、文件系统访问和网络调用等）的抽象。有时，在此层定义的服务或接口需要使用与 UI 或基础结构没有任何依赖关系的非实体类型。</span><span class="sxs-lookup"><span data-stu-id="a9877-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="a9877-239">这些类型可定义为简单的数据传输对象 (DTO)。</span><span class="sxs-lookup"><span data-stu-id="a9877-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="a9877-240">应用程序内核类型</span><span class="sxs-lookup"><span data-stu-id="a9877-240">Application Core Types</span></span>
> -   <span data-ttu-id="a9877-241">实体（保存的业务模型类）</span><span class="sxs-lookup"><span data-stu-id="a9877-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="a9877-242">接口</span><span class="sxs-lookup"><span data-stu-id="a9877-242">Interfaces</span></span>
> -   <span data-ttu-id="a9877-243">服务</span><span class="sxs-lookup"><span data-stu-id="a9877-243">Services</span></span>
> -   <span data-ttu-id="a9877-244">DTO</span><span class="sxs-lookup"><span data-stu-id="a9877-244">DTOs</span></span>

<span data-ttu-id="a9877-245">基础结构项目通常包括数据访问实现。</span><span class="sxs-lookup"><span data-stu-id="a9877-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="a9877-246">在典型的 ASP.NET Core Web 应用程序中，这包括 Entity Framework DbContext、任何已定义的 EF Core 迁移以及数据访问实现类。</span><span class="sxs-lookup"><span data-stu-id="a9877-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="a9877-247">提取数据访问实现代码最常用的方式是通过使用[存储库设计模式](http://deviq.com/repository-pattern/)。</span><span class="sxs-lookup"><span data-stu-id="a9877-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="a9877-248">除数据访问实现外，基础结构项目还应包含必须与基础结构问题交互的服务的实现。</span><span class="sxs-lookup"><span data-stu-id="a9877-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="a9877-249">这些服务应实现应用程序内核中定义的接口，因此基础结构应包含对应用程序内核项目的引用。</span><span class="sxs-lookup"><span data-stu-id="a9877-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="a9877-250">基础结构类型</span><span class="sxs-lookup"><span data-stu-id="a9877-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="a9877-251">EF Core 类型（DbContext，迁移）</span><span class="sxs-lookup"><span data-stu-id="a9877-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="a9877-252">数据访问实现类型（存储库）</span><span class="sxs-lookup"><span data-stu-id="a9877-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="a9877-253">特定于基础结构的服务（FileLogger，SmtpNotifier 等）</span><span class="sxs-lookup"><span data-stu-id="a9877-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="a9877-254">ASP.NET Core MVC 应用程序中的用户界面层将作为应用程序的入口点，并会成为 ASP.NET Core MVC 项目。</span><span class="sxs-lookup"><span data-stu-id="a9877-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="a9877-255">此项目应引用应用程序内核项目，且其类型应严格通过应用程序内核中定义的接口与基础结构进行交互。</span><span class="sxs-lookup"><span data-stu-id="a9877-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="a9877-256">UI 层中不允许基础结构层类型的直接实例化（或静态调用）。</span><span class="sxs-lookup"><span data-stu-id="a9877-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="a9877-257">UI 层类型</span><span class="sxs-lookup"><span data-stu-id="a9877-257">UI Layer Types</span></span>
> -   <span data-ttu-id="a9877-258">Controllers</span><span class="sxs-lookup"><span data-stu-id="a9877-258">Controllers</span></span>
> -   <span data-ttu-id="a9877-259">筛选器</span><span class="sxs-lookup"><span data-stu-id="a9877-259">Filters</span></span>
> -   <span data-ttu-id="a9877-260">视图</span><span class="sxs-lookup"><span data-stu-id="a9877-260">Views</span></span>
> -   <span data-ttu-id="a9877-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="a9877-261">ViewModels</span></span>
> -   <span data-ttu-id="a9877-262">启动</span><span class="sxs-lookup"><span data-stu-id="a9877-262">Startup</span></span>

<span data-ttu-id="a9877-263">启动类负责配置应用程序，并将实现类型与接口接通，使依赖关系在运行时可正常工作。</span><span class="sxs-lookup"><span data-stu-id="a9877-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="a9877-264">为在 UI 项目的 Startup.cs 文件的 ConfigureServices 中接通依赖关系注入，项目可能需要引用基础结构项目。</span><span class="sxs-lookup"><span data-stu-id="a9877-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="a9877-265">可通过使用自定义 DI 容器（最轻松的方式）消除此依赖关系。</span><span class="sxs-lookup"><span data-stu-id="a9877-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="a9877-266">对于本示例，最简单的方式是允许 UI 项目引用基础结构项目。</span><span class="sxs-lookup"><span data-stu-id="a9877-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="a9877-267">整体式应用程序和容器</span><span class="sxs-lookup"><span data-stu-id="a9877-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="a9877-268">可以构建基于单个和整体部署的 Web 应用程序或服务，并将其部署为容器。</span><span class="sxs-lookup"><span data-stu-id="a9877-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="a9877-269">在应用程序内，它可能不是一个整体，而是排列在若干个库、组件或层中。</span><span class="sxs-lookup"><span data-stu-id="a9877-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="a9877-270">但在外部，它是单个容器，如单个进程、单个 Web 应用程序或单个服务。</span><span class="sxs-lookup"><span data-stu-id="a9877-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="a9877-271">若要管理此模型，可部署单个容器来表示应用程序。</span><span class="sxs-lookup"><span data-stu-id="a9877-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="a9877-272">若要进行缩放，只需添加更多副本，并将负载均衡器置于前面即可。</span><span class="sxs-lookup"><span data-stu-id="a9877-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="a9877-273">为了简单起见，在单个容器或 VM 中管理单个部署。</span><span class="sxs-lookup"><span data-stu-id="a9877-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="a9877-274">如图 5-X 中所示，可以在每个容器内添加多个组件/库或内部层。</span><span class="sxs-lookup"><span data-stu-id="a9877-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="a9877-275">但是，遵循容器原则（“一个容器在一个进程中做一件事”），整体模式可能成为冲突。</span><span class="sxs-lookup"><span data-stu-id="a9877-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="a9877-276">这种方法的缺点是应用程序增长时，需要将它进行缩放。</span><span class="sxs-lookup"><span data-stu-id="a9877-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="a9877-277">如果整个应用程序都已缩放，这就不是问题了。</span><span class="sxs-lookup"><span data-stu-id="a9877-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="a9877-278">但在大多数情况下，应用程序中只有一小部分是瓶颈，需要进行缩放，而其他组件使用较少。</span><span class="sxs-lookup"><span data-stu-id="a9877-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="a9877-279">使用典型的电子商务示例；你可能需要缩放的是产品信息组件。</span><span class="sxs-lookup"><span data-stu-id="a9877-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="a9877-280">众多客户浏览产品，但并不购买它们。</span><span class="sxs-lookup"><span data-stu-id="a9877-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="a9877-281">使用购物车的顾客比使用付款管道的多。</span><span class="sxs-lookup"><span data-stu-id="a9877-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="a9877-282">较少的顾客会评论或查看购买记录。</span><span class="sxs-lookup"><span data-stu-id="a9877-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="a9877-283">而且你可能只需要少量的员工（在一个区域内）管理货物和营销活动。</span><span class="sxs-lookup"><span data-stu-id="a9877-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="a9877-284">通过缩放整体式设计，可多次部署所有代码。</span><span class="sxs-lookup"><span data-stu-id="a9877-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="a9877-285">除了缩放所有组件问题外，更改单个组件还需要完全重新测试整个应用程序，以及完全重新部署所有实例。</span><span class="sxs-lookup"><span data-stu-id="a9877-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="a9877-286">整体式方法很常见，并且许多组织均使用此体系结构方法进行开发。</span><span class="sxs-lookup"><span data-stu-id="a9877-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="a9877-287">其中许多组织取得了足够好的成果，而其他组织已达到极限。</span><span class="sxs-lookup"><span data-stu-id="a9877-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="a9877-288">许多组织使用这种模型设计应用程序，因为工具和基础结构难以构建面向服务的体系结构 (SOA)，而且在应用程序增长之前他们也没有发现这种需要。</span><span class="sxs-lookup"><span data-stu-id="a9877-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="a9877-289">如果你发现已达到整体式方法的极限，请分解应用，使其可更好地利用可能作为下一个逻辑步骤的容器和微服务。</span><span class="sxs-lookup"><span data-stu-id="a9877-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="a9877-290">在 Microsoft Azure 中部署整体式应用程序可以通过使用每个实例的专用 VM 实现。</span><span class="sxs-lookup"><span data-stu-id="a9877-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="a9877-291">使用 [Azure VM 规模集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) 可轻松地缩放 VM。</span><span class="sxs-lookup"><span data-stu-id="a9877-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="a9877-292">[Azure 应用服务](https://azure.microsoft.com/services/app-service/) 可运行整体式应用程序并轻松缩放实例，无需管理 VM。</span><span class="sxs-lookup"><span data-stu-id="a9877-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="a9877-293">Azure 应用服务还可运行 Docker 容器的单个实例，从而简化部署。</span><span class="sxs-lookup"><span data-stu-id="a9877-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="a9877-294">通过使用 Docker，可将单个 VM 部署为 Docker 主机，并运行多个实例。</span><span class="sxs-lookup"><span data-stu-id="a9877-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="a9877-295">如图 5-14 所示，使用 Azure 均衡器可管理缩放。</span><span class="sxs-lookup"><span data-stu-id="a9877-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="a9877-296">使用传统的部署技术可以管理各种主机的部署。</span><span class="sxs-lookup"><span data-stu-id="a9877-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="a9877-297">通过 docker run 等命令可以手动管理 Docker 主机，也可以通过持续交付 (CD) 管道等自动化管理。</span><span class="sxs-lookup"><span data-stu-id="a9877-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="a9877-298">部署为容器的整体式应用程序</span><span class="sxs-lookup"><span data-stu-id="a9877-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="a9877-299">使用容器管理整体式应用程序部署有很多好处。</span><span class="sxs-lookup"><span data-stu-id="a9877-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="a9877-300">缩放容器实例比部署额外的 VM 要快得多，也容易得多。</span><span class="sxs-lookup"><span data-stu-id="a9877-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="a9877-301">即便使用 VM 规模集缩放 VM，也需要时间才能到达实例。</span><span class="sxs-lookup"><span data-stu-id="a9877-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="a9877-302">部署为应用实例时，应用的配置将作为 VM 的一部分进行管理。</span><span class="sxs-lookup"><span data-stu-id="a9877-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="a9877-303">将更新部署为 Docker 映像会快得多，并且网络效率更高。</span><span class="sxs-lookup"><span data-stu-id="a9877-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="a9877-304">Docker 映像通常会在几秒内启动，加快了推出速度。</span><span class="sxs-lookup"><span data-stu-id="a9877-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="a9877-305">拆除 Docker 实例与发出 docker stop 命令一样简单，通常在一秒钟以内便可完成。</span><span class="sxs-lookup"><span data-stu-id="a9877-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="a9877-306">正如容器从设计上来说，它的本质就是不可变的，因此你无需担心 VM 损坏，而更新脚本可能忘记考虑磁盘上剩下的某些特定配置或文件。</span><span class="sxs-lookup"><span data-stu-id="a9877-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="a9877-307">尽管整体式应用可能得益于 Docker，但将整体式应用程序分解为可以单独缩放、开发和部署的子系统是进入微服务领域的切入点。</span><span class="sxs-lookup"><span data-stu-id="a9877-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="a9877-308">参考 - 常见 Web 体系结构</span><span class="sxs-lookup"><span data-stu-id="a9877-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="a9877-309">**干净体系结构**</span><span class="sxs-lookup"><span data-stu-id="a9877-309">**The Clean Architecture**</span></span>  
> <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - <span data-ttu-id="a9877-310">**洋葱体系结构**</span><span class="sxs-lookup"><span data-stu-id="a9877-310">**The Onion Architecture**</span></span>  
> <http://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - <span data-ttu-id="a9877-311">**存储库模式**</span><span class="sxs-lookup"><span data-stu-id="a9877-311">**The Repository Pattern**</span></span>  
> <http://deviq.com/repository-pattern/>
> - <span data-ttu-id="a9877-312">**干净体系结构解决方案示例**</span><span class="sxs-lookup"><span data-stu-id="a9877-312">**Clean Architecture Solution Sample**</span></span>  
> <https://github.com/ardalis/cleanarchitecture>
> - <span data-ttu-id="a9877-313">**构建微服务电子书** <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="a9877-313">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="a9877-314">[上一页](architectural-principles.md)
[下一页](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="a9877-314">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
