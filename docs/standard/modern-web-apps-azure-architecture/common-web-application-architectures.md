---
title: 常用 Web 应用程序体系结构
description: 使用 ASP.NET Core 和 Microsoft Azure 构建新式 Web 应用 | 常用 Web 应用程序体系结构
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.openlocfilehash: cb9a1d68d4c7c66c6adab3a5e932ee37c3ea22b0
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106418"
---
# <a name="common-web-application-architectures"></a>常用 Web 应用程序体系结构

> “如果你认为好的体系结构很昂贵，试试糟糕的体系结构吧。”  
> _- Brian Foote 和 Joseph Yoder_

## <a name="summary"></a>总结

大多数传统 .NET 应用程序都部署为单一单位，对应于单一 IIS 应用域中运行的可执行文件或单个 Web 应用程序。 这是最简单的部署模型，能很好地为众多内部和小型公共应用程序提供服务。 然而，即使提供此单一单位部署，大多数重要的业务应用程序仍能从某些逻辑分离为多层的过程中受益。

## <a name="what-is-a-monolithic-application"></a>什么是整体式应用程序？

就其行为而言，整体式应用程序是完全独立的应用程序。 在执行操作的过程中，该应用程序可能与其他服务或数据存储发生交互，但在自身进程或整个应用程序内行为运行的核心通常是部署为单个单位。 如果此类应用程序需要横向扩展，通常需要在多个服务器或虚拟机中复制整个应用程序。

## <a name="all-in-one-applications"></a>一体式应用程序

应用程序体系结构项目可能的最小数量是一。 在这种体系结构中，应用程序的完整逻辑包含在单一项目中，编译为单一程序集并部署为单一单位。

一个新的 ASP.NET Core 项目，不管是在 Visual Studio 中还是通过命令行创建，最初都是简单的“一体式”整体应用程序。 它包含应用程序的所有行为，包括演示、业务和数据访问逻辑。 图 5-1 展示了单项目应用的文件结构。

**图 5-1**。 单项目 ASP.NET Core 应用

![](./media/image5-1.png)

在单项目方案中，通过使用文件夹实现关注分离。 默认模板包括单独的模型、视图和控制器的 MVC 模式职责文件夹，以及其他数据和服务文件夹。 在这种排列中，应尽可能地将演示详细信息限制在“视图”文件夹，将数据访问实现详细信息限制在“数据”文件夹中保存的类。 业务逻辑应位于模型文件夹内的服务和类中。

尽管简单，但单项目整体解决方案也有一些缺点。 随着项目的大小和复杂性增加，文件和文件夹数量也会继续随之增加。 UI 问题（模型、视图和控制器）驻留于多个文件夹中，这些文件夹未按字母顺序组合在一起。 将其他 UI 级别构造（例如筛选器或 ModelBinder）添加到它们自己的文件夹时，问题只会变得更糟。 业务逻辑分散于“模型”和“服务”文件夹之间，没有明确地指示哪些文件中的哪些类应当依赖其他类。 这种项目级别缺少组织的情况通常会导致[面条式代码](http://deviq.com/spaghetti-code/)。

为解决这些问题，应用程序通常演变为多项目解决方案，其中将每个项目视为位于应用程序的特定层。

## <a name="what-are-layers"></a>什么是层次？

随着应用程序的复杂性增加，管理复杂性的方式之一是根据职责或问题分解应用程序。 这遵循关注分离原则，有助于使基本代码井然有序，以便开发人员可轻松找到实现特定功能的位置。 然而，分层体系结构提供的好处远远不止于代码组织结构。

通过将代码分层排列，常见的低级功能可在整个应用程序中重复使用。 这种重复使用很有用，因为它意味着需要编写的代码变少，还因为它可以让应用程序能够对某个实现进行标准化，从而遵循 DRY 原则。

借助分层体系结构，应用程序可以强制实施有关哪些层可以与其他层通信的限制。 这有助于实现封装。 某层发生更改或更换时，只有与它一起工作的那些层会受到影响。 通过限制哪些层依赖其他层，可缓解更改的影响，使一项更改不会影响整个应用程序。

分层（和封装）让替换应用程序内的功能变得更加轻松。 例如，应用程序最初可能使用自己的 SQL Server 数据库来实现持久性，但稍后可能选择使用基于云的持久性策略，或 Web API 后的策略。 如果应用程序将其持久性实现正确封装于逻辑层中，则可使用实现相同公共接口的新的 SQL Server 特定层替换它。

除可能的交换实现，以应对将来的要求更改之外，应用程序层还能让测试用途的交换实现变得更加轻松。 无需编写针对应用程序的真实数据层或 UI 层操作的测试，可在测试时使用提供请求的已知响应的假实现来替换这些层。 通常情况下，与针对应用程序的实际基础结构运行测试相比，这可以让测试更容易编写，运行速度也更快。

逻辑分层是用于改进企业软件应用程序代码的常用技术，可通过多种方式将代码分层排列。

> [!NOTE]
> 层次表示应用程序内的逻辑分隔。 如果应用程序逻辑以物理方式分布到单独的服务器或进程中，这些单独的物理部署目标就称为“层级”。 具有部署到单一层级的 N 层应用程序是可能的，也很常见。

## <a name="traditional-n-layer-architecture-applications"></a>传统“N 层”体系结构应用程序

图 5-2 展示了应用程序逻辑分层最常用的组织结构。

**图 5-2**。 典型的应用程序层次。

![](./media/image5-2.png)

这些层经常简称为 UI、BLL（业务逻辑层）和 DAL（数据访问层）。 使用此体系结构，用户可通过 UI 层（仅与 BLL 交互）提出请求。 反过来，BLL 可为数据访问请求调用 DAL。 UI 层不得直接向 DAL 提出任何请求，也不得通过其他途径直接与持久性发生交互。 同样，BLL 应仅通过 DAL 与持久性发生交互。 通过这种方式，每层都有自己熟知的职责。

这种传统分层方法的缺点之一是编译时依赖关系由上而下运行。 即，UI 层依赖于 BLL，而 BLL 依赖于 DAL。 这意味着，通常保存应用程序中最重要的逻辑的 BLL，依赖于数据访问实现详细信息（且通常依赖于数据库的存在）。 在这样的体系结构中测试业务逻辑通常是有难度的，需要一个测试数据库。 如下节中所述，依赖倒置原则可以用来解决此问题。

图 5-3 展示了一个示例解决方案，其中按职责（层次）将应用程序分解为三个项目。

**图 5-3**。 具有三个项目的简单整体式应用程序。

![](./media/image5-3.png)

尽管出于组织架构目的，此应用程序使用多个项目，但它仍作为单一单位进行部署，且其客户端以单一 Web 应用的形式与其交互。 这使部署过程变得非常简单。 图 5-4 展示了如何使用 Microsoft Azure 承载此类应用。

![](./media/image5-4.png)

**图 5-4**。 Azure Web 应用简单部署

随着应用程序需求增长，可能需要更复杂、更可靠的部署解决方案。 图 5-5 展示了支持其他功能、更复杂的部署计划示例。

![](./media/image5-5.png)

**图 5-5**。 将 Web 应用部署到 Azure 应用服务

在内部，此项目的组织根据职责分为多个项目，提高了应用程序的可维护性。

可纵向或横向扩展此单位，以利用基于云的按需可伸缩性。 纵向扩展指的是向承载应用的服务器添加额外的 CPU、内存、磁盘空间或其他资源。 横向扩展指的是添加此类服务器的其他实例，无论它们属于物理服务器还是虚拟机。 在多个实例中承载应用时，可以使用负载均衡器来将请求分配给各个应用实例。

在 Azure 中缩放 Web 应用程序最简单的方法是在应用程序的 应用服务计划中手动配置缩放。 图 5-6 展示用于配置为应用提供服务的实例数量的相应 Azure 仪表板屏幕。

![](./media/image5-6.png)

**如 5-6**。 Azure 中的应用服务计划缩放。

## <a name="clean-architecture"></a>干净体系结构

遵循依赖倒置原则以及域驱动设计原则 (DDD) 的应用程序倾向于达到类似的体系结构。 多年来，这种体系结构有多种名称。 最初的名称之一是六边形体系结构，然后是端口 - 适配器。 最近，它被称为[洋葱体系结构](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/)或[干净体系结构](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)。 干净体系结构是它最新的名称，用作介绍本电子书中的体系结构的基础。

> [!NOTE]
> 术语“干净体系结构”可应用于使用 DDD 原则生成以及未使用 DDD 原则生成的应用程序。 对于前者，这种组合可称为“干净 DDD 体系结构”。

干净体系结构将业务逻辑和应用程序模型置于应用程序的中心。 不是拥有依赖于数据访问或其他基础结构问题的业务逻辑，此依赖关系被倒置：基础结构和实现详细信息依赖于应用程序内核。 实现方法是在应用程序内核中定义抽象或接口，然后按基础结构层中定义的类型进行实现。 将此体系结构可视化的常用方法是使用一系列同心圆，类似于洋葱。 图 5-X 展示这种样式的体系结构表示形式的示例。

![](./media/image5-7.png)

**图 5-7**。 干净体系结构，洋葱视图

在此关系图中，依赖关系流向最里面的圆。 因此，可以看到，应用程序内核（采用此关系图核心位置中的名称）不依赖于其他应用程序层。 正中心是应用程序的实体和接口。 外部，但仍位于应用程序内核是域服务，通常可实现内部圆圈中定义的接口。 在应用程序内核外面，用户界面和基础结构层均依赖于应用程序内核，但不彼此依赖（必然）。

图 5-X 展示了可更好地反映 UI 和其他层之间的依赖关系的更传统的水平层次关系图。

![](./media/image5-8.png)

**图 5-8**。 干净体系结构，水平层次视图

注意，实线箭头表示编译时依赖关系，而虚线箭头表示仅运行时依赖关系。 使用干净体系结构，UI 层可使用编译时应用程序内核中定义的接口，理想情况下不应知道体系结构层中定义的实现类型。 但是在运行时，这些实现类型是应用执行所必需的，因此它们需要存在并通过依赖关系注入接通应用程序内核接口。

图 5-9 展示了遵循这些建议生成 ASP.NET Core 应用程序体系结构时的更详细的视图。

![ASPNET Core 体系结构](./media/image5-9.png)

**图 5-9**。 遵循干净体系结构的 ASP.NET Core 体系结构关系图。

由于应用程序内核不依赖于基础结构，可轻松为此层次编写自动化单元测试。 图 5-10 和 5-11 展示了测试如何适应此体系结构。

![UnitTestCore](./media/image5-10.png)

**图 5-10**。 隔离状态下的单元测试应用程序内核。

![IntegrationTests](./media/image5-11.png)

**图 5-11**。 使用外部依赖关系的集成测试基础结构实现。

由于 UI 层对基础结构项目中定义的类型没有任何直接依赖关系，同样，可轻松交换实现，无论是为便于测试还是为应对不断变化的应用程序要求。 ASP.NET Core 对内置依赖关系注入的使用及相关支持使此体系结构最适合用于构造重要的整体式应用程序。

对于整体式应用程序，应用程序内核、基础结构和用户界面项目均作为单一应用程序运行。 运行时应用程序体系结构可能类似于图 5-12。

![ASPNET Core 体系结构 2](./media/image5-12.png)

**图 5-12**。 示例 ASP.NET Core 应用的运行时体系结构。

### <a name="organizing-code-in-clean-architecture"></a>采用干净体系结构排列代码

在干净体系结构解决方案中，每个项目都有明确的职责。 在这种情况下，某些类型将属于每个项目，你会经常在相应的项目中找到与这些类型相应的文件夹。

应用程序内核包含业务模型，后者包括实体、服务和接口。 这些接口包括使用基础结构执行的操作（如数据访问、文件系统访问和网络调用等）的抽象。有时，在此层定义的服务或接口需要使用与 UI 或基础结构没有任何依赖关系的非实体类型。 这些类型可定义为简单的数据传输对象 (DTO)。

> ### <a name="application-core-types"></a>应用程序内核类型
> -   实体（保存的业务模型类）
> -   接口
> -   服务
> -   DTO

基础结构项目通常包括数据访问实现。 在典型的 ASP.NET Core Web 应用程序中，这包括 Entity Framework DbContext、任何已定义的 EF Core 迁移以及数据访问实现类。 提取数据访问实现代码最常用的方式是通过使用[存储库设计模式](http://deviq.com/repository-pattern/)。

除数据访问实现外，基础结构项目还应包含必须与基础结构问题交互的服务的实现。 这些服务应实现应用程序内核中定义的接口，因此基础结构应包含对应用程序内核项目的引用。

> ### <a name="infrastructure-types"></a>基础结构类型
> -   EF Core 类型（DbContext，迁移）
> -   数据访问实现类型（存储库）
> -   特定于基础结构的服务（FileLogger，SmtpNotifier 等）

ASP.NET Core MVC 应用程序中的用户界面层将作为应用程序的入口点，并会成为 ASP.NET Core MVC 项目。 此项目应引用应用程序内核项目，且其类型应严格通过应用程序内核中定义的接口与基础结构进行交互。 UI 层中不允许基础结构层类型的直接实例化（或静态调用）。

> ### <a name="ui-layer-types"></a>UI 层类型
> -   Controllers
> -   筛选器
> -   视图
> -   ViewModels
> -   启动

启动类负责配置应用程序，并将实现类型与接口接通，使依赖关系在运行时可正常工作。

> [!NOTE]
> 为在 UI 项目的 Startup.cs 文件的 ConfigureServices 中接通依赖关系注入，项目可能需要引用基础结构项目。 可通过使用自定义 DI 容器（最轻松的方式）消除此依赖关系。 对于本示例，最简单的方式是允许 UI 项目引用基础结构项目。

## <a name="monolithic-applications-and-containers"></a>整体式应用程序和容器 

可以构建基于单个和整体部署的 Web 应用程序或服务，并将其部署为容器。 在应用程序内，它可能不是一个整体，而是排列在若干个库、组件或层中。 但在外部，它是单个容器，如单个进程、单个 Web 应用程序或单个服务。

若要管理此模型，可部署单个容器来表示应用程序。 若要进行缩放，只需添加更多副本，并将负载均衡器置于前面即可。 为了简单起见，在单个容器或 VM 中管理单个部署。

![](./media/image5-13.png)

如图 5-X 中所示，可以在每个容器内添加多个组件/库或内部层。 但是，遵循容器原则（“一个容器在一个进程中做一件事”），整体模式可能成为冲突。

这种方法的缺点是应用程序增长时，需要将它进行缩放。 如果整个应用程序都已缩放，这就不是问题了。 但在大多数情况下，应用程序中只有一小部分是瓶颈，需要进行缩放，而其他组件使用较少。

使用典型的电子商务示例；你可能需要缩放的是产品信息组件。 众多客户浏览产品，但并不购买它们。 使用购物车的顾客比使用付款管道的多。 较少的顾客会评论或查看购买记录。 而且你可能只需要少量的员工（在一个区域内）管理货物和营销活动。 通过缩放整体式设计，可多次部署所有代码。

除了缩放所有组件问题外，更改单个组件还需要完全重新测试整个应用程序，以及完全重新部署所有实例。

整体式方法很常见，并且许多组织均使用此体系结构方法进行开发。 其中许多组织取得了足够好的成果，而其他组织已达到极限。 许多组织使用这种模型设计应用程序，因为工具和基础结构难以构建面向服务的体系结构 (SOA)，而且在应用程序增长之前他们也没有发现这种需要。 如果你发现已达到整体式方法的极限，请分解应用，使其可更好地利用可能作为下一个逻辑步骤的容器和微服务。

![](./media/image5-14.png)

在 Microsoft Azure 中部署整体式应用程序可以通过使用每个实例的专用 VM 实现。 使用 [Azure VM 规模集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) 可轻松地缩放 VM。 [Azure 应用服务](https://azure.microsoft.com/services/app-service/) 可运行整体式应用程序并轻松缩放实例，无需管理 VM。 Azure 应用服务还可运行 Docker 容器的单个实例，从而简化部署。 通过使用 Docker，可将单个 VM 部署为 Docker 主机，并运行多个实例。 如图 5-14 所示，使用 Azure 均衡器可管理缩放。

使用传统的部署技术可以管理各种主机的部署。 通过 docker run 等命令可以手动管理 Docker 主机，也可以通过持续交付 (CD) 管道等自动化管理。

### <a name="monolithic-application-deployed-as-a-container"></a>部署为容器的整体式应用程序

使用容器管理整体式应用程序部署有很多好处。 缩放容器实例比部署额外的 VM 要快得多，也容易得多。 即便使用 VM 规模集缩放 VM，也需要时间才能到达实例。 部署为应用实例时，应用的配置将作为 VM 的一部分进行管理。

将更新部署为 Docker 映像会快得多，并且网络效率更高。 Docker 映像通常会在几秒内启动，加快了推出速度。 拆除 Docker 实例与发出 docker stop 命令一样简单，通常在一秒钟以内便可完成。

正如容器从设计上来说，它的本质就是不可变的，因此你无需担心 VM 损坏，而更新脚本可能忘记考虑磁盘上剩下的某些特定配置或文件。

尽管整体式应用可能得益于 Docker，但将整体式应用程序分解为可以单独缩放、开发和部署的子系统是进入微服务领域的切入点。

> ### <a name="references--common-web-architectures"></a>参考 - 常见 Web 体系结构
> - **干净体系结构**  
> <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - **洋葱体系结构**  
> <http://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - **存储库模式**  
> <http://deviq.com/repository-pattern/>
> - **干净体系结构解决方案示例**  
> <https://github.com/ardalis/cleanarchitecture>
> - **构建微服务电子书** <http://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
[上一页](architectural-principles.md)
[下一页](common-client-side-web-technologies.md)
