---
title: "PLINQ 和 TPL 的自定义分区程序"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
caps.latest.revision: "19"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 12d234b86b0067178d54d2fdcb5d37ceaee6109d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2017
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="5c1a0-102">PLINQ 和 TPL 的自定义分区程序</span><span class="sxs-lookup"><span data-stu-id="5c1a0-102">Custom Partitioners for PLINQ and TPL</span></span>
<span data-ttu-id="5c1a0-103">并行执行对数据源的操作，其中一个重要步骤是到*分区*到可由多个线程同时访问的多个部分的源。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="5c1a0-104">PLINQ 和任务并行库 (TPL) 提供了当你编写并行查询以透明方式工作的默认分区程序或<xref:System.Threading.Tasks.Parallel.ForEach%2A>循环。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="5c1a0-105">对于更高级方案，您可以插入您自己的分区程序。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>  
  
## <a name="kinds-of-partitioning"></a><span data-ttu-id="5c1a0-106">类型的分区</span><span class="sxs-lookup"><span data-stu-id="5c1a0-106">Kinds of Partitioning</span></span>  
 <span data-ttu-id="5c1a0-107">有多种方法进行分区的数据源。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="5c1a0-108">最有效方法，在多个线程之间相互协作过程原始的源序列中，而不是以物理方式将源分离到多个序列。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="5c1a0-109">对于数组和其他索引源如<xref:System.Collections.IList>集合长度提前，知道*范围分区*是最简单的分区类型。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="5c1a0-110">每个线程都接收唯一的开头和结尾的索引，以便它可以处理其范围的源，而无需覆盖或其他任何线程被覆盖。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="5c1a0-111">范围分区所涉及的唯一开销是创建范围; 的初始工作在此之后，没有其他同步是必需的。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="5c1a0-112">因此，它可提供良好的性能，只要均匀划分工作负荷。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="5c1a0-113">范围分区的缺点是，如果一个线程提前完成，它不能帮助其他线程完成其工作。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>  
  
 <span data-ttu-id="5c1a0-114">对于链接的表或其长度不知道其他集合，你可以使用*区块分区*。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="5c1a0-115">在按区块分区，每个线程或任务并行循环或查询中的使用一定数量的一个块区中的源元素，处理它们，然后再次要从中检索其他元素。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="5c1a0-116">分发的所有元素，且没有没有重复项，可确保分区程序。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="5c1a0-117">块可为任意大小。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-117">A chunk may be any size.</span></span> <span data-ttu-id="5c1a0-118">例如，分区程序中所示[如何： 实现动态分区](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)创建只包含一个元素的区块。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="5c1a0-119">只要消息块不太大，这种类型的分区是本质上负载平衡因为分配给线程的元素不预先确定。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="5c1a0-120">但是，分区程序确实会引致同步开销线程需要获取另一个区块每次。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="5c1a0-121">在这些情况下产生的同步量为反比区块的大小成正比。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>  
  
 <span data-ttu-id="5c1a0-122">一般情况下，范围分区时才是更快委托的执行时间是小到中等程度，并且源有大量的元素，和每个分区的总工作量大致相当。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="5c1a0-123">块区分区是因此在大多数情况下通常更快。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="5c1a0-124">少量的元素或委托执行时间较长的源，则文本块和范围分区的性能是大致相等。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>  
  
 <span data-ttu-id="5c1a0-125">TPL 分区程序还支持动态数量的分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="5c1a0-126">这意味着它们可以创建分区上的即时，例如，当<xref:System.Threading.Tasks.Parallel.ForEach%2A>循环生成新的任务。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="5c1a0-127">此功能使分区程序循环本身以及缩放。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="5c1a0-128">动态分区程序也是本质上负载平衡。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="5c1a0-129">当你创建自定义分区程序时，你必须支持动态的分区，若要通过<xref:System.Threading.Tasks.Parallel.ForEach%2A>循环。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>  
  
### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="5c1a0-130">配置负载平衡的 PLINQ 分区程序</span><span class="sxs-lookup"><span data-stu-id="5c1a0-130">Configuring Load Balancing Partitioners for PLINQ</span></span>  
 <span data-ttu-id="5c1a0-131">某些重载<xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType>方法让你创建数组分区程序或<xref:System.Collections.IList>源，并指定是否应尝试平衡在线程间的工作负荷。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="5c1a0-132">当分区程序配置负载平衡，使用块区分区，并元素会被移交给小区块中的每个分区会请求。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="5c1a0-133">此方法可帮助确保所有分区都具有元素才能整个循环之前，处理或查询已完成。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="5c1a0-134">可以使用另一个重载，以提供负载平衡分区的任何<xref:System.Collections.IEnumerable>源。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>  
  
 <span data-ttu-id="5c1a0-135">通常情况下，负载平衡要求请求元素相对频繁从分区程序的分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="5c1a0-136">与此相反，分区程序执行静态分区可以通过将指定元素给每个分区程序在一次范围或块区分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="5c1a0-137">这要求更少的开销不是负载平衡，但可能需要更长时间才能执行如果一个线程结束时，其比其他更多工作。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="5c1a0-138">默认情况下是 IList 或数组，传递时 PLINQ 始终使用范围分区而不负载平衡。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="5c1a0-139">若要启用负载平衡 PLINQ，使用`Partitioner.Create`方法，如下面的示例中所示。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
 [!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]  
  
 <span data-ttu-id="5c1a0-140">确定是否使用负载平衡在任何给定方案中是体验并度量时间操作在代表性的负载和计算机配置下完成的最佳方式。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="5c1a0-141">例如，静态分区可能会有仅几个核心的多核计算机上的明显加快，但它可能会导致具有相对较多的内核的计算机上的系统速度变慢。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>  
  
 <span data-ttu-id="5c1a0-142">下表列出了可用的重载的<xref:System.Collections.Concurrent.Partitioner.Create%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="5c1a0-143">这些分区程序不受限制，将仅用于 PLINQ 或<xref:System.Threading.Tasks.Task>。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="5c1a0-144">它们还可以用于任何自定义的并行构造。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-144">They can also be used with any custom parallel construct.</span></span>  
  
|<span data-ttu-id="5c1a0-145">重载</span><span class="sxs-lookup"><span data-stu-id="5c1a0-145">Overload</span></span>|<span data-ttu-id="5c1a0-146">使用负载平衡</span><span class="sxs-lookup"><span data-stu-id="5c1a0-146">Uses load balancing</span></span>|  
|--------------|-------------------------|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="5c1a0-147">Always</span><span class="sxs-lookup"><span data-stu-id="5c1a0-147">Always</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="5c1a0-148">当为 true，则指定的布尔型参数</span><span class="sxs-lookup"><span data-stu-id="5c1a0-148">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="5c1a0-149">当为 true，则指定的布尔型参数</span><span class="sxs-lookup"><span data-stu-id="5c1a0-149">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="5c1a0-150">Never</span><span class="sxs-lookup"><span data-stu-id="5c1a0-150">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="5c1a0-151">Never</span><span class="sxs-lookup"><span data-stu-id="5c1a0-151">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="5c1a0-152">Never</span><span class="sxs-lookup"><span data-stu-id="5c1a0-152">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="5c1a0-153">Never</span><span class="sxs-lookup"><span data-stu-id="5c1a0-153">Never</span></span>|  
  
### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="5c1a0-154">配置静态范围的 Parallel.ForEach 的分区程序</span><span class="sxs-lookup"><span data-stu-id="5c1a0-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>  
 <span data-ttu-id="5c1a0-155">在<xref:System.Threading.Tasks.Parallel.For%2A>循环，循环的正文提供给视为的委托方法。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="5c1a0-156">调用该委托的成本是关于虚方法调用相同的。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="5c1a0-157">在某些情况下，并行循环主体可能是足够小，每个循环迭代上的委托调用的成本变得很大。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="5c1a0-158">在这种情况下，你可以使用其中一个<xref:System.Collections.Concurrent.Partitioner.Create%2A>重载创建<xref:System.Collections.Generic.IEnumerable%601>针对源元素的范围分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="5c1a0-159">然后，将传递到此集合<xref:System.Threading.Tasks.Parallel.ForEach%2A>方法的正文包含正则表达式`for`循环。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="5c1a0-160">此方法的好处是委托调用成本发生一次每个范围，而不是一次每个元素。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="5c1a0-161">下面的示例演示了基本模式。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-161">The following example demonstrates the basic pattern.</span></span>  
  
 [!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
 [!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]  
  
 <span data-ttu-id="5c1a0-162">在循环中的每个线程都接收其自己<xref:System.Tuple%602>，其中包含起始和结束中指定的子范围的索引值。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="5c1a0-163">内部`for`循环使用`fromInclusive`和`toExclusive`值循环访问数组或<xref:System.Collections.IList>直接。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>  
  
 <span data-ttu-id="5c1a0-164">之一<xref:System.Collections.Concurrent.Partitioner.Create%2A>重载允许您指定的大小以及这两个分区的分区数。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="5c1a0-165">此重载可以在其中每个元素的工作是因此低甚至一个虚方法调用每个元素对性能产生显著影响在方案中使用。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>  
  
## <a name="custom-partitioners"></a><span data-ttu-id="5c1a0-166">自定义分区程序</span><span class="sxs-lookup"><span data-stu-id="5c1a0-166">Custom Partitioners</span></span>  
 <span data-ttu-id="5c1a0-167">在某些情况下，它可能是值得或甚至需要实现自己的分区程序。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="5c1a0-168">例如，您可能可以与默认分区程序可以基于你的类的内部结构知识更有效地进行分区的自定义集合类。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="5c1a0-169">或者，你可能想要创建基于你的需要多长时间它到源集合中的不同位置的过程元素知识的不同大小的范围分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>  
  
 <span data-ttu-id="5c1a0-170">若要创建基本的自定义分区程序，从派生类<xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType>和重写虚拟方法下, 表中所述。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="5c1a0-171">此方法由主线程调用一次，并返回 IList(IEnumerator(TSource))。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="5c1a0-172">循环或查询中的每个工作线程可以调用`GetEnumerator`上要检索的列表<xref:System.Collections.Generic.IEnumerator%601>针对不同的分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="5c1a0-173">返回`true`如果实现<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>，否则为`false`。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="5c1a0-174">如果<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>是`true`，可以根据需要调用此方法，而不是<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="5c1a0-175">如果结果必须是可排序，或者您需要到的元素的索引的访问，派生自<xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType>并重写其虚拟方法下, 表中所述。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="5c1a0-176">此方法由主线程调用一次，并返回`IList(IEnumerator(TSource))`。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="5c1a0-177">循环或查询中的每个工作线程可以调用`GetEnumerator`上要检索的列表<xref:System.Collections.Generic.IEnumerator%601>针对不同的分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="5c1a0-178">返回`true`如果实现<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; 否则为 false。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="5c1a0-179">通常情况下，这只调用<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="5c1a0-180">如果<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>是`true`，可以根据需要调用此方法，而不是<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="5c1a0-181">下表提供了其他详细介绍三种类型的负载平衡分区程序实现<xref:System.Collections.Concurrent.OrderablePartitioner%601>类。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>  
  
|<span data-ttu-id="5c1a0-182">方法/属性</span><span class="sxs-lookup"><span data-stu-id="5c1a0-182">Method/Property</span></span>|<span data-ttu-id="5c1a0-183">IList / 数组而不负载平衡</span><span class="sxs-lookup"><span data-stu-id="5c1a0-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="5c1a0-184">IList / 数组与负载平衡</span><span class="sxs-lookup"><span data-stu-id="5c1a0-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="5c1a0-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="5c1a0-185">IEnumerable</span></span>|  
|----------------------|-------------------------------------------|----------------------------------------|-----------------|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="5c1a0-186">使用范围分区</span><span class="sxs-lookup"><span data-stu-id="5c1a0-186">Uses range partitioning</span></span>|<span data-ttu-id="5c1a0-187">使用块区分区指定 partitionCount 针对列表优化</span><span class="sxs-lookup"><span data-stu-id="5c1a0-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="5c1a0-188">通过创建静态分区数使用块区分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="5c1a0-189">不支持将引发异常</span><span class="sxs-lookup"><span data-stu-id="5c1a0-189">Throws not-supported exception</span></span>|<span data-ttu-id="5c1a0-190">使用块区分区优化列表和动态分区</span><span class="sxs-lookup"><span data-stu-id="5c1a0-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="5c1a0-191">通过创建动态分区数使用块区分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="5c1a0-192">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-192">Returns `true`</span></span>|<span data-ttu-id="5c1a0-193">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-193">Returns `true`</span></span>|<span data-ttu-id="5c1a0-194">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-194">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="5c1a0-195">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-195">Returns `true`</span></span>|<span data-ttu-id="5c1a0-196">返回 `false`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-196">Returns `false`</span></span>|<span data-ttu-id="5c1a0-197">返回 `false`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-197">Returns `false`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="5c1a0-198">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-198">Returns `true`</span></span>|<span data-ttu-id="5c1a0-199">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-199">Returns `true`</span></span>|<span data-ttu-id="5c1a0-200">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-200">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="5c1a0-201">返回 `false`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-201">Returns `false`</span></span>|<span data-ttu-id="5c1a0-202">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-202">Returns `true`</span></span>|<span data-ttu-id="5c1a0-203">返回 `true`</span><span class="sxs-lookup"><span data-stu-id="5c1a0-203">Returns `true`</span></span>|  
  
### <a name="dynamic-partitions"></a><span data-ttu-id="5c1a0-204">动态分区</span><span class="sxs-lookup"><span data-stu-id="5c1a0-204">Dynamic Partitions</span></span>  
 <span data-ttu-id="5c1a0-205">如果你想要在中使用的分区<xref:System.Threading.Tasks.Parallel.ForEach%2A>方法，你必须能够返回动态数量的分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="5c1a0-206">这意味着分区程序可以在循环执行期间随时提供新分区的点播的枚举数。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="5c1a0-207">基本上，只要循环添加新的并行任务，它会请求该任务的新分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="5c1a0-208">如果你需要以可排序数据，然后派生自<xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType>，以便每个分区中的每个项分配一个唯一索引。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>  
  
 <span data-ttu-id="5c1a0-209">有关详细信息及示例，请参阅[如何： 实现动态分区](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
### <a name="contract-for-partitioners"></a><span data-ttu-id="5c1a0-210">协定分区程序</span><span class="sxs-lookup"><span data-stu-id="5c1a0-210">Contract for Partitioners</span></span>  
 <span data-ttu-id="5c1a0-211">当您实现自定义分区程序时，请遵循以下准则来帮助确保与 PLINQ 的正确交互和<xref:System.Threading.Tasks.Parallel.ForEach%2A>TPL 中：</span><span class="sxs-lookup"><span data-stu-id="5c1a0-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>  
  
-   <span data-ttu-id="5c1a0-212">如果<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>调用参数为零或更短`partitionsCount`，引发<xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="5c1a0-213">虽然 PLINQ 和 TPL 将永远不会传递中`partitionCount`等于 0，我们仍然建议抵御可能会出现。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>  
  
-   <span data-ttu-id="5c1a0-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>和<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>应始终返回`partitionsCount`的分区数。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="5c1a0-215">如果分区程序用完了数据，并且无法创建请求的所有分区，该方法应返回一个空枚举器的每个剩余的分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="5c1a0-216">否则，PLINQ 和 TPL 会引发<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="5c1a0-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A><xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>， <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>，和<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>永远不应返回`null`(`Nothing`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="5c1a0-218">如果他们这样做，PLINQ / TPL 将引发<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="5c1a0-219">返回分区的方法应始终返回可以完全并唯一地枚举数据源的分区。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="5c1a0-220">除非特别需要程序设计的分区程序，应为数据源或跳过的项目中没有重复。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="5c1a0-221">如果未遵循此规则，则输出顺序可能会混乱。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-221">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="5c1a0-222">以便不会输出顺序混乱，以下布尔 getter 必须始终准确地返回以下值：</span><span class="sxs-lookup"><span data-stu-id="5c1a0-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>  
  
    -   <span data-ttu-id="5c1a0-223">`KeysOrderedInEachPartition`： 每个分区返回不断增加的键索引的元素。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>  
  
    -   <span data-ttu-id="5c1a0-224">`KeysOrderedAcrossPartitions`： 适用于将返回分区中的密钥索引的所有分区*我*高于中分区的键索引*我*-1。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>  
  
    -   <span data-ttu-id="5c1a0-225">`KeysNormalized`： 所有键索引单调递增没有间隔，从零开始。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>  
  
-   <span data-ttu-id="5c1a0-226">所有索引必须都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-226">All indices must be unique.</span></span> <span data-ttu-id="5c1a0-227">不可能重复的索引。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-227">There may not be duplicate indices.</span></span> <span data-ttu-id="5c1a0-228">如果未遵循此规则，则输出顺序可能会混乱。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-228">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="5c1a0-229">所有索引必须都为非负数。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-229">All indices must be nonnegative.</span></span> <span data-ttu-id="5c1a0-230">如果未遵循此规则，则 PLINQ/TPL 可能会引发异常。</span><span class="sxs-lookup"><span data-stu-id="5c1a0-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5c1a0-231">另请参阅</span><span class="sxs-lookup"><span data-stu-id="5c1a0-231">See Also</span></span>  
 [<span data-ttu-id="5c1a0-232">并行编程</span><span class="sxs-lookup"><span data-stu-id="5c1a0-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="5c1a0-233">如何：实现动态分区</span><span class="sxs-lookup"><span data-stu-id="5c1a0-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)  
 [<span data-ttu-id="5c1a0-234">如何：实现静态分区程序</span><span class="sxs-lookup"><span data-stu-id="5c1a0-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
