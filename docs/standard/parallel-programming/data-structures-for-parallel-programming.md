---
title: "用于并行编程的数据结构"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: data structures, multi-threading
ms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9
caps.latest.revision: "15"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: f35c5382455021f0a001604367e59204ce4ad93c
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2017
---
# <a name="data-structures-for-parallel-programming"></a><span data-ttu-id="6870c-102">用于并行编程的数据结构</span><span class="sxs-lookup"><span data-stu-id="6870c-102">Data Structures for Parallel Programming</span></span>
<span data-ttu-id="6870c-103">.NET Framework 版本 4 引入了几种新类型，可在并行编程中，包括一套并发集合类、 轻量同步基元，以及对延迟初始化的类型。</span><span class="sxs-lookup"><span data-stu-id="6870c-103">The .NET Framework version 4 introduces several new types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.</span></span> <span data-ttu-id="6870c-104">你可以使用任何多线程应用程序代码，包括任务并行库和 PLINQ 中使用这些类型。</span><span class="sxs-lookup"><span data-stu-id="6870c-104">You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.</span></span>  
  
## <a name="concurrent-collection-classes"></a><span data-ttu-id="6870c-105">并发集合类</span><span class="sxs-lookup"><span data-stu-id="6870c-105">Concurrent Collection Classes</span></span>  
 <span data-ttu-id="6870c-106">中的集合类<xref:System.Collections.Concurrent?displayProperty=nameWithType>命名空间提供线程安全添加和删除尽可能避免锁的操作以及使用锁必需的细粒度锁定。</span><span class="sxs-lookup"><span data-stu-id="6870c-106">The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.</span></span> <span data-ttu-id="6870c-107">与不同的在.NET framework 1.0 和 2.0 版中引入的集合，并发集合类不需要用户代码时要执行的任何锁它访问项。</span><span class="sxs-lookup"><span data-stu-id="6870c-107">Unlike collections that were introduced in the .NET Framework versions 1.0 and 2.0, a concurrent collection class does not require user code to take any locks when it accesses items.</span></span> <span data-ttu-id="6870c-108">并发集合类可以显著提高性能类型如<xref:System.Collections.ArrayList?displayProperty=nameWithType>和<xref:System.Collections.Generic.List%601?displayProperty=nameWithType>（与用户实现锁定） 方案，其中多个线程中添加和删除项集合中。</span><span class="sxs-lookup"><span data-stu-id="6870c-108">The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.</span></span>  
  
 <span data-ttu-id="6870c-109">下表列出了新的并发集合类：</span><span class="sxs-lookup"><span data-stu-id="6870c-109">The following table lists the new concurrent collection classes:</span></span>  
  
|<span data-ttu-id="6870c-110">类型</span><span class="sxs-lookup"><span data-stu-id="6870c-110">Type</span></span>|<span data-ttu-id="6870c-111">描述</span><span class="sxs-lookup"><span data-stu-id="6870c-111">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|<span data-ttu-id="6870c-112">为实现 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType> 的线程安全集合提供阻塞和限制功能。</span><span class="sxs-lookup"><span data-stu-id="6870c-112">Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6870c-113">制造者线程阻止如果没有槽可用，或如果集合已满。</span><span class="sxs-lookup"><span data-stu-id="6870c-113">Producer threads block if no slots are available or if the collection is full.</span></span> <span data-ttu-id="6870c-114">如果该集合为空，将阻止使用者线程。</span><span class="sxs-lookup"><span data-stu-id="6870c-114">Consumer threads block if the collection is empty.</span></span> <span data-ttu-id="6870c-115">此类型还支持通过使用者和制造非阻止访问。</span><span class="sxs-lookup"><span data-stu-id="6870c-115">This type also supports non-blocking access by consumers and producers.</span></span> <span data-ttu-id="6870c-116"><xref:System.Collections.Concurrent.BlockingCollection%601>可以使用作为基类或后备存储，以提供阻塞和限制为支持任何集合类<xref:System.Collections.Generic.IEnumerable%601>。</span><span class="sxs-lookup"><span data-stu-id="6870c-116"><xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|<span data-ttu-id="6870c-117">提供可缩放的线程安全包实现添加和获取操作。</span><span class="sxs-lookup"><span data-stu-id="6870c-117">A thread-safe bag implementation that provides scalable add and get operations.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|<span data-ttu-id="6870c-118">一种并发且可伸缩的字典类型。</span><span class="sxs-lookup"><span data-stu-id="6870c-118">A concurrent and scalable dictionary type.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|<span data-ttu-id="6870c-119">并发和可缩放的先进先出队列。</span><span class="sxs-lookup"><span data-stu-id="6870c-119">A concurrent and scalable FIFO queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|<span data-ttu-id="6870c-120">并发和可缩放的后进先出堆栈。</span><span class="sxs-lookup"><span data-stu-id="6870c-120">A concurrent and scalable LIFO stack.</span></span>|  
  
 <span data-ttu-id="6870c-121">有关详细信息，请参阅[线程安全集合](../../../docs/standard/collections/thread-safe/index.md)。</span><span class="sxs-lookup"><span data-stu-id="6870c-121">For more information, see [Thread-Safe Collections](../../../docs/standard/collections/thread-safe/index.md).</span></span>  
  
## <a name="synchronization-primitives"></a><span data-ttu-id="6870c-122">同步基元</span><span class="sxs-lookup"><span data-stu-id="6870c-122">Synchronization Primitives</span></span>  
 <span data-ttu-id="6870c-123">中的新同步基元<xref:System.Threading?displayProperty=nameWithType>命名空间通过避免开销在旧的多线程处理代码中找到的锁定机制启用细化的并发性和更快的性能。</span><span class="sxs-lookup"><span data-stu-id="6870c-123">The new synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.</span></span> <span data-ttu-id="6870c-124">某些新类型，如<xref:System.Threading.Barrier?displayProperty=nameWithType>和<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>早期版本的.NET Framework 中具有不对应。</span><span class="sxs-lookup"><span data-stu-id="6870c-124">Some of the new types, such as <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> have no counterparts in earlier releases of the .NET Framework.</span></span>  
  
 <span data-ttu-id="6870c-125">下表列出的新同步类型：</span><span class="sxs-lookup"><span data-stu-id="6870c-125">The following table lists the new synchronization types:</span></span>  
  
|<span data-ttu-id="6870c-126">类型</span><span class="sxs-lookup"><span data-stu-id="6870c-126">Type</span></span>|<span data-ttu-id="6870c-127">描述</span><span class="sxs-lookup"><span data-stu-id="6870c-127">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Threading.Barrier?displayProperty=nameWithType>|<span data-ttu-id="6870c-128">使多个线程能够通过提供每个任务可以指示其到达并且某些或所有任务均已到达，然后等到点处理并行算法。</span><span class="sxs-lookup"><span data-stu-id="6870c-128">Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.</span></span> <span data-ttu-id="6870c-129">有关详细信息，请参阅 [Barrier](../../../docs/standard/threading/barrier.md)。</span><span class="sxs-lookup"><span data-stu-id="6870c-129">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>|  
|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|<span data-ttu-id="6870c-130">通过提供简单会合机制简化分叉和联接的方案。</span><span class="sxs-lookup"><span data-stu-id="6870c-130">Simplifies fork and join scenarios by providing an easy rendezvous mechanism.</span></span> <span data-ttu-id="6870c-131">有关详细信息，请参阅[CountdownEvent](../../../docs/standard/threading/countdownevent.md)。</span><span class="sxs-lookup"><span data-stu-id="6870c-131">For more information, see [CountdownEvent](../../../docs/standard/threading/countdownevent.md).</span></span>|  
|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|<span data-ttu-id="6870c-132">类似于一个同步基元<xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6870c-132">A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6870c-133"><xref:System.Threading.ManualResetEventSlim>轻量但仅用于内部进程通信。</span><span class="sxs-lookup"><span data-stu-id="6870c-133"><xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.</span></span> <span data-ttu-id="6870c-134">有关详细信息，请参阅[ManualResetEvent 和 ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md)。</span><span class="sxs-lookup"><span data-stu-id="6870c-134">For more information, see [ManualResetEvent and ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md).</span></span>|  
|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|<span data-ttu-id="6870c-135">一个同步基元，限制可以同时访问资源的线程数或资源池。</span><span class="sxs-lookup"><span data-stu-id="6870c-135">A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.</span></span> <span data-ttu-id="6870c-136">有关详细信息，请参阅[Semaphore 和 SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)。</span><span class="sxs-lookup"><span data-stu-id="6870c-136">For more information, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>|  
|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|<span data-ttu-id="6870c-137">一个相互排斥锁基元，导致线程尝试获取锁后，在循环中等待或*数值调节钮*，生成其量程之前的时间段内。</span><span class="sxs-lookup"><span data-stu-id="6870c-137">A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum.</span></span> <span data-ttu-id="6870c-138">在方案中等待的锁的地方短，<xref:System.Threading.SpinLock>提供更好的性能比其他形式的锁定。</span><span class="sxs-lookup"><span data-stu-id="6870c-138">In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking.</span></span> <span data-ttu-id="6870c-139">有关详细信息，请参阅[旋转锁](../../../docs/standard/threading/spinlock.md)。</span><span class="sxs-lookup"><span data-stu-id="6870c-139">For more information, see [SpinLock](../../../docs/standard/threading/spinlock.md).</span></span>|  
|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|<span data-ttu-id="6870c-140">指定的时间，并最终将旋转的小的轻型类型将线程置于等待状态，如果超过重试次数。</span><span class="sxs-lookup"><span data-stu-id="6870c-140">A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.</span></span>  <span data-ttu-id="6870c-141">有关详细信息，请参阅[SpinWait](../../../docs/standard/threading/spinwait.md)。</span><span class="sxs-lookup"><span data-stu-id="6870c-141">For more information, see [SpinWait](../../../docs/standard/threading/spinwait.md).</span></span>|  
  
 <span data-ttu-id="6870c-142">有关详细信息，请参见:</span><span class="sxs-lookup"><span data-stu-id="6870c-142">For more information, see:</span></span>  
  
-   [<span data-ttu-id="6870c-143">如何：使用 SpinLock 进行低级别同步</span><span class="sxs-lookup"><span data-stu-id="6870c-143">How to: Use SpinLock for Low-Level Synchronization</span></span>](../../../docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)  
  
-   <span data-ttu-id="6870c-144">[如何： 使并发操作保持同步使用屏障](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md)。</span><span class="sxs-lookup"><span data-stu-id="6870c-144">[How to: Synchronize Concurrent Operations with a Barrier](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span></span>  
  
## <a name="lazy-initialization-classes"></a><span data-ttu-id="6870c-145">延迟初始化类</span><span class="sxs-lookup"><span data-stu-id="6870c-145">Lazy Initialization Classes</span></span>  
 <span data-ttu-id="6870c-146">对于迟缓初始化，直到需要它时不分配对象的内存。</span><span class="sxs-lookup"><span data-stu-id="6870c-146">With lazy initialization, the memory for an object is not allocated until it is needed.</span></span> <span data-ttu-id="6870c-147">通过在程序的生存期之间均匀分配对象分配，延迟初始化可以提高性能。</span><span class="sxs-lookup"><span data-stu-id="6870c-147">Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.</span></span> <span data-ttu-id="6870c-148">你可以通过包装类型启用任何自定义类型的延迟初始化<xref:System.Lazy%601>。</span><span class="sxs-lookup"><span data-stu-id="6870c-148">You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="6870c-149">下表列出的延迟初始化类型：</span><span class="sxs-lookup"><span data-stu-id="6870c-149">The following table lists the lazy initialization types:</span></span>  
  
|<span data-ttu-id="6870c-150">类型</span><span class="sxs-lookup"><span data-stu-id="6870c-150">Type</span></span>|<span data-ttu-id="6870c-151">描述</span><span class="sxs-lookup"><span data-stu-id="6870c-151">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601?displayProperty=nameWithType>|<span data-ttu-id="6870c-152">提供轻量、 线程安全迟缓初始化。</span><span class="sxs-lookup"><span data-stu-id="6870c-152">Provides lightweight, thread-safe lazy-initialization.</span></span>|  
|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|<span data-ttu-id="6870c-153">与延迟调用的初始化函数的每个线程上为每个线程运行，提供延迟初始化值。</span><span class="sxs-lookup"><span data-stu-id="6870c-153">Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.</span></span>|  
|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|<span data-ttu-id="6870c-154">提供无需分配的专用、 延迟初始化的实例的静态方法。</span><span class="sxs-lookup"><span data-stu-id="6870c-154">Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.</span></span> <span data-ttu-id="6870c-155">相反，它们使用引用以确保目标已初始化为这些表进行访问。</span><span class="sxs-lookup"><span data-stu-id="6870c-155">Instead, they use references to ensure targets have been initialized as they are accessed.</span></span>|  
  
 <span data-ttu-id="6870c-156">若要了解详细信息，请参阅[迟缓初始化](../../../docs/framework/performance/lazy-initialization.md)</span><span class="sxs-lookup"><span data-stu-id="6870c-156">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="aggregate-exceptions"></a><span data-ttu-id="6870c-157">聚合异常</span><span class="sxs-lookup"><span data-stu-id="6870c-157">Aggregate Exceptions</span></span>  
 <span data-ttu-id="6870c-158"><xref:System.AggregateException?displayProperty=nameWithType>类型可以用于捕获多个异常单独线程上同时引发，并且将它们返回到为单个异常的联接线程。</span><span class="sxs-lookup"><span data-stu-id="6870c-158">The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.</span></span> <span data-ttu-id="6870c-159"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType>和<xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>类型和 PLINQ 使用<xref:System.AggregateException>广泛用于此目的。</span><span class="sxs-lookup"><span data-stu-id="6870c-159">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose.</span></span> <span data-ttu-id="6870c-160">有关详细信息，请参阅[NIB： 如何： 处理由任务引发异常](http://msdn.microsoft.com/en-us/d6c47ec8-9de9-4880-beb3-ff19ae51565d)和[如何： 处理 PLINQ 查询中的异常](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md)。</span><span class="sxs-lookup"><span data-stu-id="6870c-160">For more information, see [NIB: How to: Handle Exceptions Thrown by Tasks](http://msdn.microsoft.com/en-us/d6c47ec8-9de9-4880-beb3-ff19ae51565d) and [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6870c-161">另请参阅</span><span class="sxs-lookup"><span data-stu-id="6870c-161">See Also</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>  
 <xref:System.Threading?displayProperty=nameWithType>  
 [<span data-ttu-id="6870c-162">并行编程</span><span class="sxs-lookup"><span data-stu-id="6870c-162">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
