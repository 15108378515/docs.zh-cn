---
title: "了解 PLINQ 中的加速"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: c3373cb6a2c535bd7d42eb062e1f9727952f7cfb
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/18/2017
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="118e0-102">了解 PLINQ 中的加速</span><span class="sxs-lookup"><span data-stu-id="118e0-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="118e0-103">PLINQ 的主要目的是为了加快执行 LINQ 对对象查询通过在多核计算机上的并行执行查询委托。</span><span class="sxs-lookup"><span data-stu-id="118e0-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="118e0-104">PLINQ 的性能最佳时源集合中每个元素的处理是独立的不涉及各个委托之间的共享状态。</span><span class="sxs-lookup"><span data-stu-id="118e0-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="118e0-105">此类操作在 LINQ to Objects 与 PLINQ 中, 很常见和通常称为"*适合并行*"因为它们有助于使自身轻松地在多个线程上执行计划。</span><span class="sxs-lookup"><span data-stu-id="118e0-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="118e0-106">但是，并非所有查询都包含完全适合并行操作;在大多数情况下，查询涉及到或者无法并行化，或的速度变慢并行执行某些运算符。</span><span class="sxs-lookup"><span data-stu-id="118e0-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="118e0-107">和完全适合并行的查询，即使使用 PLINQ 必须仍分区的数据源，并在上计划工作线程，并通常合并结果，查询完成时。</span><span class="sxs-lookup"><span data-stu-id="118e0-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="118e0-108">所有这些操作将添加到并行化; 的计算成本添加并行化的这些成本称为*开销*。</span><span class="sxs-lookup"><span data-stu-id="118e0-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="118e0-109">若要实现最佳性能 PLINQ 查询中的，目标是最大化适合并行的部分并最大程度减少需要开销的部分。</span><span class="sxs-lookup"><span data-stu-id="118e0-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="118e0-110">本文提供了将帮助你编写时仍然能产生正确的结果会尽可能高效的 PLINQ 查询的信息。</span><span class="sxs-lookup"><span data-stu-id="118e0-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="118e0-111">影响 PLINQ 查询性能的因素</span><span class="sxs-lookup"><span data-stu-id="118e0-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="118e0-112">下列各节列出了一些最重要的因素影响并行查询性能。</span><span class="sxs-lookup"><span data-stu-id="118e0-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="118e0-113">这些是常规的语句，仅凭不足以预测在所有情况下的查询性能。</span><span class="sxs-lookup"><span data-stu-id="118e0-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="118e0-114">与往常一样，它进行测量非常重要的计算机上的特定查询的代表性配置和负载的一系列的实际性能。</span><span class="sxs-lookup"><span data-stu-id="118e0-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="118e0-115">整体工作的计算成本。</span><span class="sxs-lookup"><span data-stu-id="118e0-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="118e0-116">若要实现加速，PLINQ 查询必须具有足够的适合并行工作来弥补开销。</span><span class="sxs-lookup"><span data-stu-id="118e0-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="118e0-117">工作可以表示为每个委托的源集合中的元素数的乘积的计算成本。</span><span class="sxs-lookup"><span data-stu-id="118e0-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="118e0-118">假设操作可以并行化，更占用计算开销很，较大的一个加速的可能性。</span><span class="sxs-lookup"><span data-stu-id="118e0-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="118e0-119">例如，如果函数采用一个毫秒执行，超过 1000 个元素将只采用一个秒的时间来执行该操作，而四个核心的计算机上进行的并行查询的顺序查询可能需要仅 250 毫秒。</span><span class="sxs-lookup"><span data-stu-id="118e0-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="118e0-120">这会生成 750 毫秒的加速。</span><span class="sxs-lookup"><span data-stu-id="118e0-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="118e0-121">如果该函数需要一个秒的时间来执行的每个元素，则加速将为 750 秒。</span><span class="sxs-lookup"><span data-stu-id="118e0-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="118e0-122">如果委托代价很高，PLINQ 可能会提供与只有几项源集合中的明显加快。</span><span class="sxs-lookup"><span data-stu-id="118e0-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="118e0-123">相反，使用普通的委托的小源集合通常不是最适合 PLINQ。</span><span class="sxs-lookup"><span data-stu-id="118e0-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="118e0-124">在下面的示例中，queryA 可能是很适合 PLINQ 中，假定其选择的功能，包括大量工作。</span><span class="sxs-lookup"><span data-stu-id="118e0-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="118e0-125">queryB 可能并不是很好的候选项，因为没有足够的 Select 语句中的工作和并行化的开销将偏移量的速度提高大部分或全部。</span><span class="sxs-lookup"><span data-stu-id="118e0-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="118e0-126">系统 （并行度） 上的逻辑内核数。</span><span class="sxs-lookup"><span data-stu-id="118e0-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="118e0-127">此点是上一节显而易见的必然结果，适合并行的查询更快地在计算机上运行具有更多内核因为更多的并发线程间设置可划分工作。</span><span class="sxs-lookup"><span data-stu-id="118e0-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="118e0-128">加速整体量取决于查询的整体工作的百分比是可并行化。</span><span class="sxs-lookup"><span data-stu-id="118e0-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="118e0-129">但是，不会假定两次作为将运行所有查询快速上四核计算机八核计算机。</span><span class="sxs-lookup"><span data-stu-id="118e0-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="118e0-130">当优化查询以获得最佳性能，务必衡量具有多个内核的计算机上的实际结果。</span><span class="sxs-lookup"><span data-stu-id="118e0-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="118e0-131">此点与相关点 #1： 大型数据集所需利用更多的计算资源。</span><span class="sxs-lookup"><span data-stu-id="118e0-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="118e0-132">数量和类型的操作。</span><span class="sxs-lookup"><span data-stu-id="118e0-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="118e0-133">PLINQ 提供 AsOrdered 运算符的情况下它有必要保留源序列中的元素的顺序。</span><span class="sxs-lookup"><span data-stu-id="118e0-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="118e0-134">排序，会带来开销，但此开销通常是适度。</span><span class="sxs-lookup"><span data-stu-id="118e0-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="118e0-135">GroupBy 和联接操作同样会产生开销。</span><span class="sxs-lookup"><span data-stu-id="118e0-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="118e0-136">它允许处理按任意顺序，对源集合中的元素并将它们传递到下一步的运算符，只要准备好时，PLINQ 的性能最佳。</span><span class="sxs-lookup"><span data-stu-id="118e0-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="118e0-137">有关详细信息，请参阅 [PLINQ 中的顺序保留](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="118e0-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="118e0-138">查询执行的窗体。</span><span class="sxs-lookup"><span data-stu-id="118e0-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="118e0-139">如果你要通过调用 ToArray 或 ToList 存储查询的结果，所有并行线程的结果必须合并到单个数据结构。</span><span class="sxs-lookup"><span data-stu-id="118e0-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="118e0-140">这涉及到不可避免的计算成本。</span><span class="sxs-lookup"><span data-stu-id="118e0-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="118e0-141">同样，如果通过使用 （用于在 Visual Basic 中的每个） 的 foreach 循环中循环结果，则需要从工作线程的结果在枚举器线程序列化。</span><span class="sxs-lookup"><span data-stu-id="118e0-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="118e0-142">但如果你只是想要执行一些操作基于每个线程的结果，你可以使用 ForAll 方法以在多个线程上执行此工作。</span><span class="sxs-lookup"><span data-stu-id="118e0-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="118e0-143">合并选项的类型。</span><span class="sxs-lookup"><span data-stu-id="118e0-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="118e0-144">PLINQ 可以配置为缓冲其输出，并生成它小区块中或在一次后整个结果集生成，或者到流单个结果产生。</span><span class="sxs-lookup"><span data-stu-id="118e0-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="118e0-145">以前的结果是降低总执行时间，而后者生成元素之间的降低延迟。</span><span class="sxs-lookup"><span data-stu-id="118e0-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="118e0-146">虽然的合并选项并不总是有重大影响总体查询性能，它们可以影响感知的性能，因为它们控制多长时间的用户必须等待以查看结果。</span><span class="sxs-lookup"><span data-stu-id="118e0-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="118e0-147">有关详细信息，请参阅 [PLINQ 中的合并选项](../../../docs/standard/parallel-programming/merge-options-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="118e0-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="118e0-148">分区的种类。</span><span class="sxs-lookup"><span data-stu-id="118e0-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="118e0-149">在某些情况下，可建立索引的源集合的 PLINQ 查询可能会导致不平衡的工作负载。</span><span class="sxs-lookup"><span data-stu-id="118e0-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="118e0-150">当发生这种情况时，你可以通过创建自定义分区程序来提高查询性能。</span><span class="sxs-lookup"><span data-stu-id="118e0-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="118e0-151">有关详细信息，请参阅 [PLINQ 和 TPL 的自定义分区程序](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="118e0-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="118e0-152">当 PLINQ 选择顺序模式</span><span class="sxs-lookup"><span data-stu-id="118e0-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="118e0-153">PLINQ 将始终尝试执行至少速度一样快查询将按顺序运行查询。</span><span class="sxs-lookup"><span data-stu-id="118e0-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="118e0-154">尽管 PLINQ 不会计算查找如何昂贵的用户委托，或者如何大输入的源，它看起来一查询"形状"。</span><span class="sxs-lookup"><span data-stu-id="118e0-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="118e0-155">具体而言，它查找查询运算符或通常会导致要在并行模式下执行速度更慢的查询运算符的组合。</span><span class="sxs-lookup"><span data-stu-id="118e0-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="118e0-156">当它找到此类形状时，默认情况下的 PLINQ 回退到顺序模式。</span><span class="sxs-lookup"><span data-stu-id="118e0-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="118e0-157">但是，在衡量特定查询的性能，可能会确定，它实际上更快地在并行模式下运行。</span><span class="sxs-lookup"><span data-stu-id="118e0-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="118e0-158">在这种情况下可以使用<xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType>标志通过<xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A>方法以指示 PLINQ 并行执行查询。</span><span class="sxs-lookup"><span data-stu-id="118e0-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="118e0-159">有关详细信息，请参阅[如何：在 PLINQ 中指定执行模式](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="118e0-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="118e0-160">以下列表描述 PLINQ 默认情况下的会在顺序模式中执行的查询形状：</span><span class="sxs-lookup"><span data-stu-id="118e0-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="118e0-161">包含 Select、 查询，其中，索引索引的 SelectMany，或已删除或重新排列原始索引的排序或筛选运算符后的 ElementAt 子句。</span><span class="sxs-lookup"><span data-stu-id="118e0-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="118e0-162">查询包含的 Take、 TakeWhile，跳过，SkipWhile 运算符和源序列中的索引不按原始顺序。</span><span class="sxs-lookup"><span data-stu-id="118e0-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="118e0-163">包含 Zip 或 SequenceEquals 的查询，除非其中一个数据源具有按原始顺序排列的索引，并且另一个数据源是可索引的（即，数组或 IList(T)）。</span><span class="sxs-lookup"><span data-stu-id="118e0-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="118e0-164">包含 Concat，除非将其应用到可索引数据源的查询。</span><span class="sxs-lookup"><span data-stu-id="118e0-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="118e0-165">包含反向，除非应用到可索引数据源的查询。</span><span class="sxs-lookup"><span data-stu-id="118e0-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="118e0-166">另请参阅</span><span class="sxs-lookup"><span data-stu-id="118e0-166">See Also</span></span>  
 [<span data-ttu-id="118e0-167">并行 LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="118e0-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
