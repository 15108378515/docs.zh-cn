---
title: "同步基元概述"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
caps.latest.revision: "17"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 58fb520365d0a80a8f8bc46e3fdbd23483fdf07f
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/21/2017
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="e1ee3-102">同步基元概述</span><span class="sxs-lookup"><span data-stu-id="e1ee3-102">Overview of Synchronization Primitives</span></span>
<span data-ttu-id="e1ee3-103"><a name="top"></a> .NET Framework 提供一系列用于控制线程交互和避免争用情况的同步基元。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-103"><a name="top"></a> The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="e1ee3-104">这大致可分为 3 个类别：锁定、发出信号和联锁操作。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="e1ee3-105">类别不整齐也非明确定义：某些同步机制具有多个类别的特征；一次释放一个线程的事件在功能上类似锁定；任何锁定的释放可均可被视为一个信号；并且联锁操作可用于构造锁定。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="e1ee3-106">但是，类别仍然有用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="e1ee3-107">请务必记住线程同步是协作的。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="e1ee3-108">即使是某个线程绕过同步机制直接访问了受保护的资源，此同步机制也不能为有效机制。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="e1ee3-109">本概述包含以下几节：</span><span class="sxs-lookup"><span data-stu-id="e1ee3-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="e1ee3-110">锁定</span><span class="sxs-lookup"><span data-stu-id="e1ee3-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="e1ee3-111">发出信号</span><span class="sxs-lookup"><span data-stu-id="e1ee3-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="e1ee3-112">轻量同步类型</span><span class="sxs-lookup"><span data-stu-id="e1ee3-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="e1ee3-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="e1ee3-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="e1ee3-114">互锁操作</span><span class="sxs-lookup"><span data-stu-id="e1ee3-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="e1ee3-115">锁定</span><span class="sxs-lookup"><span data-stu-id="e1ee3-115">Locking</span></span>  
 <span data-ttu-id="e1ee3-116">锁定控制一次针对一个线程的资源，或控制针对指定数目线程的资源。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="e1ee3-117">锁定正在使用时请求排他锁的线程将受阻，直到锁定变为可用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="e1ee3-118">排他锁</span><span class="sxs-lookup"><span data-stu-id="e1ee3-118">Exclusive Locks</span></span>  
 <span data-ttu-id="e1ee3-119">最简单的锁定形式是 C# 中的 `lock` 语句和 Visual Basic 中的 `SyncLock` 语句），它控制对代码块的访问。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="e1ee3-120">此类块经常被称为关键部分。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="e1ee3-121">`lock`语句实现通过使用<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>和<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>方法，并使用`try…catch…finally`块以确保该锁被释放。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses `try…catch…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="e1ee3-122">一般情况下，使用`lock`或`SyncLock`语句来保护小块的代码，永远不会跨越多个一个简单方法是使用的最佳办法<xref:System.Threading.Monitor>类。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="e1ee3-123"><xref:System.Threading.Monitor> 类虽然功能强大，但容易形成孤立锁和死锁情况。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="e1ee3-124">Monitor 类</span><span class="sxs-lookup"><span data-stu-id="e1ee3-124">Monitor Class</span></span>  
 <span data-ttu-id="e1ee3-125"><xref:System.Threading.Monitor> 类提供了附加功能，可以与 `lock` 语句配合使用：</span><span class="sxs-lookup"><span data-stu-id="e1ee3-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="e1ee3-126"><xref:System.Threading.Monitor.TryEnter%2A> 方法允许受阻线程等待资源在指定的时间间隔后放弃。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="e1ee3-127">它返回一个指示成功或失败布尔值，该值可用于检测和避免潜在的死锁。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="e1ee3-128"><xref:System.Threading.Monitor.Wait%2A> 方法由关键部分中的线程调用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="e1ee3-129">它放弃对资源和块的控制，直到资源再次可用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="e1ee3-130"><xref:System.Threading.Monitor.Pulse%2A> 和 <xref:System.Threading.Monitor.PulseAll%2A> 方法允许将要释放锁或要调用 <xref:System.Threading.Monitor.Wait%2A> 的线程将一个或多个线程放置到准备就绪的队列中，以便它们能够获取此锁。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="e1ee3-131"><xref:System.Threading.Monitor.Wait%2A>方法重载上的超时允许正在等待的线程跳转到就绪的队列。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="e1ee3-132">如果用于锁的对象派生自<xref:System.MarshalByRefObject>，则 <xref:System.Threading.Monitor> 类可以在多个应用程序域中提供锁定。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="e1ee3-133"><xref:System.Threading.Monitor> 具有线程关联。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="e1ee3-134">即，进入监视器的线程必须通过调用 <xref:System.Threading.Monitor.Exit%2A> 或 <xref:System.Threading.Monitor.Wait%2A> 退出。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="e1ee3-135"><xref:System.Threading.Monitor> 类不可实例化。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="e1ee3-136">其方法是静态方法（Visual Basic 中为 `Shared`），并在用于可实例化的锁对象。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="e1ee3-137">有关概念性概述，请参阅 [Monitor](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-137">For a conceptual overview, see [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="e1ee3-138">Mutex 类</span><span class="sxs-lookup"><span data-stu-id="e1ee3-138">Mutex Class</span></span>  
 <span data-ttu-id="e1ee3-139">线程通过调用其 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法的重载来请求 <xref:System.Threading.Mutex>。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="e1ee3-140">提供了超时的重载，以允许线程放弃等待。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="e1ee3-141">与 <xref:System.Threading.Monitor> 类不同，互斥可以是局部的，也可以是全局的。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="e1ee3-142">全局互斥（也称为已命名互斥）在整个操作系统中均可见，且可用于同步多个应用程序域或进程中的线程。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="e1ee3-143">局部互斥派生自 <xref:System.MarshalByRefObject>，且可跨应用程序域边界使用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="e1ee3-144">此外，<xref:System.Threading.Mutex> 派生自 <xref:System.Threading.WaitHandle>，这意味着它可以与 <xref:System.Threading.WaitHandle> 提供的信号机制（如 <xref:System.Threading.WaitHandle.WaitAll%2A>、<xref:System.Threading.WaitHandle.WaitAny%2A> 和 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法）一起使用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="e1ee3-145">和 <xref:System.Threading.Monitor> 一样，<xref:System.Threading.Mutex> 也具有线程关联。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="e1ee3-146">与 <xref:System.Threading.Monitor> 不同，<xref:System.Threading.Mutex> 是可实例化的对象。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="e1ee3-147">有关概念性概述，请参阅 [Mutex](../../../docs/standard/threading/mutexes.md)。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="e1ee3-148">SpinLock 类</span><span class="sxs-lookup"><span data-stu-id="e1ee3-148">SpinLock Class</span></span>  
 <span data-ttu-id="e1ee3-149">从开始[!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)]，你可以使用<xref:System.Threading.SpinLock>类在由所需的开销<xref:System.Threading.Monitor>会降低性能。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="e1ee3-150">当 <xref:System.Threading.SpinLock> 遇到锁定关键部分时，它只在循环中旋转，直到锁变为可用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="e1ee3-151">如果锁被保留的时间很短，旋转可以比阻止提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="e1ee3-152">但是，如果锁被保留超过数十个周期数，<xref:System.Threading.SpinLock>同样执行作为<xref:System.Threading.Monitor>，但将使用更多 CPU 周期，因此会降低其他线程或进程的性能。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="e1ee3-153">其他锁</span><span class="sxs-lookup"><span data-stu-id="e1ee3-153">Other Locks</span></span>  
 <span data-ttu-id="e1ee3-154">锁不必为排他锁。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-154">Locks need not be exclusive.</span></span> <span data-ttu-id="e1ee3-155">在允许有限数量的线程并发访问资源时，这通常很有用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="e1ee3-156">信号量和读取器/编写器锁旨在控制此类连入池的资源访问。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="e1ee3-157">ReaderWriterLock 类</span><span class="sxs-lookup"><span data-stu-id="e1ee3-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="e1ee3-158"><xref:System.Threading.ReaderWriterLockSlim> 类解决了更改数据的线程（即编写器）必须具有资源的独占访问权的情况。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="e1ee3-159">编写器处于非活动状态时，任意数量的读取器均可访问资源（例如，通过调用 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> 方法）。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="e1ee3-160">当某个线程请求独占访问时，（例如，通过调用 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> 方法），后续读取器请求将被阻止，直到所有现有读取器均已退出锁，并且编写器已进入并退出锁。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="e1ee3-161"><xref:System.Threading.ReaderWriterLockSlim> 具有线程关联。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="e1ee3-162">有关概念性概述，请参阅[读取器-编写器锁](../../../docs/standard/threading/reader-writer-locks.md)。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="e1ee3-163">Semaphore 类</span><span class="sxs-lookup"><span data-stu-id="e1ee3-163">Semaphore Class</span></span>  
 <span data-ttu-id="e1ee3-164"><xref:System.Threading.Semaphore> 类允许指定数量的线程访问资源。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="e1ee3-165">请求资源的其他线程将受阻，直到一个线程释放信号量。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="e1ee3-166">和 <xref:System.Threading.Mutex> 类一样，<xref:System.Threading.Semaphore> 也派生自 <xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="e1ee3-167">也和 <xref:System.Threading.Mutex>一样，<xref:System.Threading.Semaphore> 可以是局部的，也可以是全局的。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="e1ee3-168">它也可跨应用程序域边界使用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="e1ee3-169">与 <xref:System.Threading.Monitor>、<xref:System.Threading.Mutex> 和<xref:System.Threading.ReaderWriterLock> 不同，<xref:System.Threading.Semaphore> 不具有线程关联。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="e1ee3-170">这意味着它可以在一个线程获取信号量而另一个线程释放此信号量的情况下使用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="e1ee3-171">有关概念性概述，请参阅 [Semaphore 和 SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="e1ee3-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> 是单个流程边界内用于同步的轻量级信号量。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="e1ee3-173">返回页首</span><span class="sxs-lookup"><span data-stu-id="e1ee3-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="e1ee3-174">Signaling</span><span class="sxs-lookup"><span data-stu-id="e1ee3-174">Signaling</span></span>  
 <span data-ttu-id="e1ee3-175">等待来自另一个线程的信号的最简单方法是调用 <xref:System.Threading.Thread.Join%2A> 方法，此方法在其他线程完成前受阻。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="e1ee3-176"><xref:System.Threading.Thread.Join%2A> 具有两个重载，允许受阻线程在经过指定的时间间隔后跳出等待。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="e1ee3-177">等待句柄提供一组更为丰富的等待和信号功能。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="e1ee3-178">等待句柄</span><span class="sxs-lookup"><span data-stu-id="e1ee3-178">Wait Handles</span></span>  
 <span data-ttu-id="e1ee3-179">等待句柄派生自 <xref:System.Threading.WaitHandle> 类，后者转而派生自 <xref:System.MarshalByRefObject>。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="e1ee3-180">因此，等待句柄可用于跨应用程序域边界同步线程的活动。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="e1ee3-181">线程通过调用实例方法 <xref:System.Threading.WaitHandle.WaitOne%2A> 或其中一个静态方法（<xref:System.Threading.WaitHandle.WaitAll%2A>、<xref:System.Threading.WaitHandle.WaitAny%2A> 或 <xref:System.Threading.WaitHandle.SignalAndWait%2A>来阻止等待句柄。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="e1ee3-182">释放方式取决于调用的方法类型和等待句柄的类型。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="e1ee3-183">有关概念性概述，请参阅[等待句柄](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-183">For a conceptual overview, see [Wait Handles](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="e1ee3-184">事件等待句柄</span><span class="sxs-lookup"><span data-stu-id="e1ee3-184">Event Wait Handles</span></span>  
 <span data-ttu-id="e1ee3-185">事件等待句柄包括 <xref:System.Threading.EventWaitHandle>类及其派生类（<xref:System.Threading.AutoResetEvent> 和 <xref:System.Threading.ManualResetEvent>）。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="e1ee3-186">当通过调用事件等待句柄的 <xref:System.Threading.EventWaitHandle.Set%2A> 方法或通过使用 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法来发出事件等待句柄的信号时，将从事件等待句柄中释放线程。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="e1ee3-187">事件等待句柄可以像旋转栅在每次发出信号时仅允许一个线程通过一样，自动对进行重置，也可以像接收到信号前保持关闭、然后在被关闭前保持打开的大门一样，必须手动进行重置。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="e1ee3-188">顾名思义，<xref:System.Threading.AutoResetEvent> 和 <xref:System.Threading.ManualResetEvent> 分别表示前者和后者。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="e1ee3-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> 是单个流程边界内用于同步的轻量事件。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="e1ee3-190"><xref:System.Threading.EventWaitHandle> 可表示其中任一类型的事件，并且可为局部也可为全局。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="e1ee3-191">派生类 <xref:System.Threading.AutoResetEvent> 和 <xref:System.Threading.ManualResetEvent> 始终是局部的。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="e1ee3-192">事件等待句柄不具有线程关联。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="e1ee3-193">任何线程均可以向事件等待句柄发送信号。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="e1ee3-194">有关概念性概述，请参阅 [EventWaitHandle、AutoResetEvent、CountdownEvent、ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="e1ee3-195">Mutex 和 Semaphore 类</span><span class="sxs-lookup"><span data-stu-id="e1ee3-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="e1ee3-196">因为 <xref:System.Threading.Mutex> <xref:System.Threading.Semaphore> 类派生自 <xref:System.Threading.WaitHandle>，因此可与 <xref:System.Threading.WaitHandle> 的静态方法一起使用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="e1ee3-197">例如，线程可以使用 <xref:System.Threading.WaitHandle.WaitAll%2A> 方法来等待直到以下全部 3 个条件均为 True：向<xref:System.Threading.EventWaitHandle> 发出信号，释放了 <xref:System.Threading.Mutex>，且释放了 <xref:System.Threading.Semaphore>。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="e1ee3-198">同样，线程可使用<xref:System.Threading.WaitHandle.WaitAny%2A> 方法等待直到其中任一条件为 true。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="e1ee3-199">对于 <xref:System.Threading.Mutex> 或 <xref:System.Threading.Semaphore>，被发送信号意味着被释放。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="e1ee3-200">如果两者中任一类型被用作 <xref:System.Threading.WaitHandle.SignalAndWait%2A> 方法的第一个参数，则将其释放。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="e1ee3-201">对于具有线程关联的 <xref:System.Threading.Mutex>，如果调用线程不具有互斥，则引发异常。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="e1ee3-202">按前面所述，信号量不具有线程关联。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="e1ee3-203">屏障</span><span class="sxs-lookup"><span data-stu-id="e1ee3-203">Barrier</span></span>  
 <span data-ttu-id="e1ee3-204"><xref:System.Threading.Barrier> 类提供了一种以循环方式同步多个线程的方法，以便所有线程在同一个点受阻并等待其他线程完成。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="e1ee3-205">一个或多个线程需要另一个线程的结果时，继续到算法的下一阶段之前，一个屏障很有用。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="e1ee3-206">有关详细信息，请参阅 [Barrier](../../../docs/standard/threading/barrier.md)。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="e1ee3-207">返回页首</span><span class="sxs-lookup"><span data-stu-id="e1ee3-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="e1ee3-208">轻量同步类型</span><span class="sxs-lookup"><span data-stu-id="e1ee3-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="e1ee3-209">从 [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] 起，可在可能时使用同步基元，该基元通过避免对 Win32 内核对象（如等待句柄）形成高开销的依赖来提供快速性能。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="e1ee3-210">通常，在等待时间较短且仅当已尝试并发现原始同步类型让人不满意时，才应使用这些类型。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="e1ee3-211">在需要跨进程通信的情况下，不能使用轻量类型。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="e1ee3-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> 是 <xref:System.Threading.Semaphore?displayProperty=nameWithType> 的轻量版本。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="e1ee3-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> 是 <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> 的轻量版本。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="e1ee3-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> 表示当其计数为零时将被发送信号的事件。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="e1ee3-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> 使多个线程能够相互同步而无需由主线程控制。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="e1ee3-216">屏障会阻止每个线程继续，直到所有线程均已到达指定点。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="e1ee3-217">返回页首</span><span class="sxs-lookup"><span data-stu-id="e1ee3-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="e1ee3-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="e1ee3-218">SpinWait</span></span>  
 <span data-ttu-id="e1ee3-219">从开始[!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]，你可以使用<xref:System.Threading.SpinWait?displayProperty=nameWithType>结构当线程必须等待事件接收信号或必须满足条件，但如果实际等待时间预计小于使用等待句柄或 otherwi 所需的等待时间时se 妨碍当前线程。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="e1ee3-220">通过使用 <xref:System.Threading.SpinWait>，你可以指定等待期间要旋转的一小段时间，且只在特定时间不满足条件时让行（例如，通过等待或休眠）。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="e1ee3-221">返回页首</span><span class="sxs-lookup"><span data-stu-id="e1ee3-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="e1ee3-222">互锁操作</span><span class="sxs-lookup"><span data-stu-id="e1ee3-222">Interlocked Operations</span></span>  
 <span data-ttu-id="e1ee3-223">联锁操作是 <xref:System.Threading.Interlocked> 类的静态方法在内存位置执行的简单原子操作。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="e1ee3-224">这些原子操作包括添加、递增和递减、交换、取决于比较的条件交换以及在 32 位平台上读取 64 位值的操作。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e1ee3-225">仅保证单个操作的原子性；当多个操作必须作为一个单元执行时，必须使用更粗粒度的同步机制。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="e1ee3-226">尽管这些操作均不是锁或信号，但可用于构造锁和信号。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="e1ee3-227">它们源于 Windows 操作系统，因此联锁操作非常快。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="e1ee3-228">联锁操作可以与易失内存保证一起使用，用于编写展示强大的非阻塞并发功能的应用程序。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="e1ee3-229">但是，它们需要复杂的、低级别编程，因此在大多数情况下，简单锁是更好的选择。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="e1ee3-230">有关概念性概述，请参阅[互锁操作](../../../docs/standard/threading/interlocked-operations.md)。</span><span class="sxs-lookup"><span data-stu-id="e1ee3-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e1ee3-231">另请参阅</span><span class="sxs-lookup"><span data-stu-id="e1ee3-231">See Also</span></span>  
 [<span data-ttu-id="e1ee3-232">为多线程处理同步数据</span><span class="sxs-lookup"><span data-stu-id="e1ee3-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [<span data-ttu-id="e1ee3-233">监视器</span><span class="sxs-lookup"><span data-stu-id="e1ee3-233">Monitors</span></span>](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
 [<span data-ttu-id="e1ee3-234">Mutex</span><span class="sxs-lookup"><span data-stu-id="e1ee3-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
 [<span data-ttu-id="e1ee3-235">Semaphore 和 SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="e1ee3-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
 [<span data-ttu-id="e1ee3-236">EventWaitHandle、AutoResetEvent、CountdownEvent、ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="e1ee3-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
 [<span data-ttu-id="e1ee3-237">等待句柄</span><span class="sxs-lookup"><span data-stu-id="e1ee3-237">Wait Handles</span></span>](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
 [<span data-ttu-id="e1ee3-238">互锁操作</span><span class="sxs-lookup"><span data-stu-id="e1ee3-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="e1ee3-239">读取器-编写器锁</span><span class="sxs-lookup"><span data-stu-id="e1ee3-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
 [<span data-ttu-id="e1ee3-240">Barrier</span><span class="sxs-lookup"><span data-stu-id="e1ee3-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
 [<span data-ttu-id="e1ee3-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="e1ee3-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
 [<span data-ttu-id="e1ee3-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="e1ee3-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
